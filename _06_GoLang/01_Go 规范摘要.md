## Go 规范摘要

### 1. 语法摘要

> **层次结构**

Go 程序是通过将包链接在一起来构建的，大写开头标记程序元素为外部链接。作用域层次结构分为 *universe*（全局） > *package*（包） > *file*（文件） > *function*（函数） > *block*（块）。

```go
package main       // 包声明
import "fmt"       // 包导入
 
// Send the sequence 2, 3, 4, … to channel 'ch'.
func generate(ch chan<- int) {
	for i := 2; ; i++ {
		ch <- i  // Send 'i' to channel 'ch'.
	}
}
// Copy the values from channel 'src' to channel 'dst',
// removing those divisible by 'prime'.
func filter(src <-chan int, dst chan<- int, prime int) {
	for i := range src {  // Loop over values received from 'src'.
		if i%prime != 0 {
			dst <- i  // Send 'i' to channel 'dst'.
		}
	}
}
// The prime sieve: Daisy-chain filter processes together.
func sieve() {
	ch := make(chan int)  // Create a new channel.
	go generate(ch)       // Start generate() as a subprocess.
	for {
		prime := <-ch
		fmt.Print(prime, "\n")
		ch1 := make(chan int)
		go filter(ch, ch1, prime)
		ch = ch1
	}
}
func main() {  // Main Entrypoint.
	sieve()
}
```

> **程序初始化**

一个完整程序的包是逐步初始化的：包初始化 ➡ 变量初始化 ➡ 调用 `func init()` 函数。全局变量按声明顺序和依赖关系依次进行初始化，未设值变量被零初始化：布尔类型为 `false`，数值类型为 `0`，字符串为 `""`，指针、函数、接口、 切片、通道和映射类型为 `nil`。

`init` 可以启动其他 *goroutine*，这些 *goroutine* 可以与初始化代码并发运行，可以声明任意数量的 `init`。一个完整的 Go 程序是通过将一个主包（`package main`，非导入包）与所有依赖包递归链接起来创建的。*main goroutine* 结束时，其他子 *goroutine* 不会等待结束。

```go
// 首先初始化 V，其次按序调用 init，最后执行 main
var V int = Init(10)    

func main() { 
	println("Enter main")
}
func init() { fmt.Println("Enter init A") }
func init() { fmt.Println("Enter init B") }
func Init[T any](t T) (rt T) {
	rt = t
	fmt.Println("Init V = ", rt)
	return
}
/* 
	Init V = 10
	Enter init A
	Enter init B
	Enter main
*/
```

> **标准关键字**

```go
package     	// 包声明                                          
import      	// 依赖包导入                                          
const       	// 常量声明                                        
type        	// 类型定义或别名声明，TypeSwitch 中的类型推断 identifier.(type) 
var         	// 变量声明，支持类型推断                                        

chan        	// 通道类型声明                  
interface   	// 接口类型声明                                    
func        	// 函数声明关键字                                    
map         	// 映射类型声明                                    
struct      	// 结构体声明            

if          	// if 条件语句                                   
else        	// if 语句的否定分支                             
switch      	// switch 条件语句                               
select      	// 选择语句                                        
case        	// switch、select 语句的 case 分支           
default     	// switch、select 语句的 default 分支        
fallthrough 	// switch 语句直落语句                           

for         	// for 迭代语句                                  
range       	// for 语句范围表达式                            
      	  
break       	// 跳出当前循环或分支                              
continue    	// 跳转至当前循环体末尾                            
return      	// 函数返回语句                                    
goto        	// 无条件跳转语句   

defer       	// 延时函数调用                                    
go          	// 开启一个并发线程或 goroutine                      
```

> **预定义内置类型**

```go
any        		// 空接口 interface{} 的别名，它代表所有（非接口）类型的集合 
bool       		// 布尔                                                    
byte       		// bytestring 的单个字节                                                    
comparable 		// 接口约束，严格可比较接口                                                  
complex64  		// float32 复数                                          
complex128 		// float64 复数                                          
error      		// 接口，包含一个 Error 函数                                                    
float32    		// 32 位浮点类型                                              
float64    		// 64 位浮点类型                                              
int        		// 32 或 64 位有符号整数                                       
int8       		// 8 位有符号整数                                              
int16      		// 16 位有符号整数                                             
int32      		// 32 位有符号整数                                             
int64      		// 64 位有符号整数                                             
rune       		// UTF-8 Unicode 码位表示                         
string     		// 字符串                                                  
uint       		// 32 或 64 位无符号整数                                       
uint8      		// 8 位无符号整数                                              
uint16     		// 16 位无符号整数                                             
uint32     		// 32 位无符号整数                                             
uint64     		// 64 位无符号整数                                             
uintptr    		// 足以存储指针值的无符号整数类型                              
true       		// 布尔值真                                                    
false      		// 布尔值假                                                    
iota       		// 特殊常量值，连续的无类型整数常量，只能用于常量赋值          
nil        		// 空值                                                        
```

> **预定义内置函数**

```go
func append(slice []Type, elems ...Type) []Type // slice 扩展
func cap(v Type) int                            // 获取 slice, array, *array, chan 容量
func len(v Type) int                            // 获取 slice, array, *array 元素个数, string 长度, chan 排队元素个数
func clear[T ~[]Type | ~map[Type]Type1](t T)    // 清空 slice, map
func close(c chan<- Type)                       // 关闭 chan
func complex(r, i FloatType) ComplexType        // 构造复数类型
func copy(dst, src []Type) int                  // 复制 slice
func delete(m map[Type]Type1, key Type)         // 删除 map 元素
func imag(c ComplexType) FloatType              // 读取复数虚部
func real(c ComplexType) FloatType              // 读取复数实部
func make(t Type, size ...IntegerType) Type     // 构造 slice, map, chan
func max[T cmp.Ordered](x T, y ...T) T          // 一组 cmp.Ordered 中的最大值
func min[T cmp.Ordered](x T, y ...T) Tn         // 一组 cmp.Ordered 中的最小值
func new(Type) *Type                            // 返回类型零值指针
func panic(v any)                               // 异常抛出
func print(args ...Type)                        // 格式化输出到标准错误
func println(args ...Type)                      // 格式化输出行到标准错误
func recover() any                              // 恢复发生 panicking 例程的执行
```

> **运算符**

```go
+    -    *	   /    %	 ++   --
+= 	 -=   *=   /=   %=   =    :=
<    >    >=   <=   ==   !=
|    &    ^    &^	<<   >>   ~	   !	
|=   &=   ^=   &^=  <<=  >>=  ||   &&
[    ]    (    )    {    }
<-   ,    ;
```

---
### 2. 字面值文本

> **整数文本**

```go
42, 4_2    					// 数字分隔符
0b1010, 0B_0101				// 二进制前缀: 0b,0B 
0600, 0_600, 0o600, 0O600   // 八进制前缀: 0,0o,0O
0xBadFace, 0xBad_Face,      // 十六进制前缀: 0x,0X
```

> **浮点文本**

浮点文本支持 *E* 或 *P* 指数表示法。

```go
// 十进制
0., 72.40, 072.40, 2.71828
1.e+0, 6.67428e-11, 1E6				// e, E 指数表示法
.25, .12345E+5, 1_5., 0.15e+0_2
// 十六进制: p, P 指数表示法 
0x1p-2       // == 0.25
0x2.p10      // == 2048.0
0x1.Fp+0     // == 1.9375
0X.8p-0      // == 0.5
0X_1FFFP-16  // == 0.1249847412109375
```

> **虚数文本**

仅以前导 0 开头的数字序列被视为十进制数字。

```go
0i, 0123i, 0.i, 6.67428e-11i, 0x1p-2i
0o123i        // == 0o123 * 1i == 83i
0xabci        // == 0xabc * 1i == 2748i
```

> **字符文本**

Go 使用 UTF-8 编码的 Unicode 字符，支持多字节。支持 `\x hh`、`\u hhhh`、`\U hhhhhhhh`、`\ nnn`（*h* 表示十六进制数字，*n* 表示八进制数字）。

```go
'\'','a', 'ä', '本', '\t', 
'\xff', 
'\000', '\007', '\377', '\x07',
'\u12e4', 
'\U00101234'
```

> **转义字符**

```go
'\a'   // U+0007 响铃
'\b'   // U+0008 退格
'\f'   // U+000C 换页
'\n'   // U+000A 换行
'\r'   // U+000D 回车
'\t'   // U+0009 水平制表
'\v'   // U+000B 垂直制表
'\\'   // U+005C \
'\''   // U+0027 single quote  (valid escape only within rune literals)
'\"'   // U+0022 double quote  (valid escape only within string literals)
```

> **字符串文本**

字符串支持原始字符串和解释字符串。

```go
// 原始字符串
`abc`                // same as "abc"
`\n
\n`                  // same as "\\n\n\\n"
// 解释字符串
"\""                 // same as `"`
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
```

---
### 3. 常量与变量

> **常量**

常量有布尔常量、数值常量（字符常量、整数常量、浮点常量、复数常量）和字符串常量。常量可以是类型化或非类型化的，非类型化常量的默认类型分别是 `bool`、`rune`、`int`、`float64`、`complex128` 或 `string`。

```go
const Pi float64 = 3.14159265358979323846
const zero = 0.0         // untyped floating-point constant: float64
const (
	size int64 = 1024	 // typed
	eof        = -1      // untyped
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo"
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
```

Go 是静态强类型语言，不允许混合数值类型的操作。不同类型之间必须强制类型转换（例如 `int(3.1) + 1`）。

```go
type myString string      
const untypedStr = "World"      // const untyped string
const typedStr string = "World" // const string

var s1 myString = typedStr           // error
var s2 myString = myString(typedStr) // 强制转换, string => myString
var s3 myString = untypedStr         // 隐式转换, untyped string => myString
```

> **iota**

标识符 `iota` 在一组 `const` 常量声明中表示从零开始的连续整数常量，可以借助 `iota` 构建枚举常量。

```go
const x = iota  // x == 0
const y = iota  // y == 0

const (
	a  = 1 << iota //  1 << 0 (iota = 0)
	a1 = 2         //  (iota == 1, unused)
	b  = 2 * iota  //  2 * 2  (iota = 2)
	b1             //  2 * 3  (iota = 3)
	b2             //  2 * 4  (iota = 4)
	b3             //  2 * 5  (iota = 5)
	c  = 1 + iota  //  1 + 6  (iota = 6)
	c1             //  1 + 7  (iota = 7)
	c2             //  1 + 8  (iota = 8)
)
```

> **变量**

变量保存值的存储位置和数据，允许的值集由变量类型决定。

```go
var x interface{}  // nil, interface{}
var v *T           // nil, *T
x = 42             // 42, dynamic type int
x = v              // (*T)(nil), *T

// 多变量声明
var U, V, W int
var x, y float32 = -1, -2
var (
	i       int
	u, v, s = 2.0, 3.0, "bar"
	j = nil   // error
)
var re, im = complexSqrt(-1)
```

块范围可以使用短变量声明方式：`idenList := exprList`，`_` 表示弃元。*短变量重声明* 要求左侧至少有一个新声明非空变量。

```go
i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w, _ := os.Pipe()  // os.Pipe() returns a connected pair of Files and an error
_, y, _ := coord(p)   

// 短变量重声明 要求左侧至少有一个新声明非空变量
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // redeclare offset, field2 is new
x, y, x := 1, 2, 3                        // illegal: x repeated on left side of :=
```

---
### 4. 类型

#### 4.1. 内置类型

布尔类型（`bool`）表示 `true` 和 `false` 布尔值集。

```go
var f bool = false
t := true 
```

数值类型包含整数、浮点数、复数和字符类型。

```go
uint8, uint16, uint32, uint64  // unsigned integers    
int8, int16, int32, int64      // signed integers 
float32, float64      		   // IEEE754 floating-points
complex64, complex128		   // complex

uint, int        // 32 or 64 bits
uintptr          // store pointer values      

byte        // alias for uint8
rune        // alias for int32
```

不同的数值类型之间需要显式转换。

```go
var x, y = 1, 1.0      // int,float64
sum := float64(x) + y  // 不同数值类型之间需要显式转换
```

>---
#### 4.2. String

字符串 `string` 不可变且不可寻址，`len` 获取字符串的长度。字符串字节 `byte` 可索引，字符串字节不代表单个字符。遍历字符使用字符类型 `rune`。

```go
var str string = "Hello World"
var last byte = str[len(str)-1]    
var r rune
// 遍历字符
for _,r = range str { 
	// do ...
}
// 字符串拼接
str := "hi" + string(c)     
str += " and good bye"   
```


>---
#### 4.3. Array

数组是单一类型元素的编号序列，具有值属性。`len` 来获取数组的长度。数组始终是一维的，可以组合成多维数组。

```go
var arr [10]int= [10]int{1,2,3}    // 指定长度
var arr2 = [...]int{0,2,4,8,10}    // 静态推断
// 多维数组
[3][5]int		  // [3]([5]int)
[2][2][2]float64  // [2]([2]([2]float64))
```

Go 数组若要类似 C 的行为或效率，可以传递一个指向数组的指针。

```go
func Sum(arr *[3]float64) (sum float64) {
    for _, v := range *arr {
        sum += v
    }
    return sum
}
```

>---
#### 4.4. Slice

切片是提供其底层数组某个连续段的描述符。切片由一个指向数组的指针、段的长度及切片容量组成，与底层数组共享内存空间。`len` 获取长度，`cap(s)` 来获取容量。`nil` 切片的长度和容量为 0。

```go
var s []int    // nil
a := [100]int{}
s = a[10:50]   // 截取数组索引为 10 到 49 的元素
// cap(s) = len(a) - 10 = 90
```

`make` 为类型 `T` 创建一个长度为 `length` 和可选容量大小为 `capacity`（默认等于 `length`）、零值初始化的切片，并关联一个长度为 `capacity` 的底层数组。

```go
s := make([]T, length [, capacity]?)
// 相当于
a := [capacity]T{}
s := a[0:length]
```

切片表达式（`a[low : high <: max>?]`）从数组、指向数组的指针、切片中构造切片，或从字符串中构造子字符串。例如表达式 `a[1:4]` 创建关联数组 `a` 索引 1~3 的切片。

```go
a[low : high]        
a[low : high : max]  // 除字符串外

a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]
a[2:]  // same as a[2 : len(a)]
a[:3]  // same as a[0 : 3]
a[:]   // same as a[0 : len(a)]

a := [100]int{}
s1 := a[20:50:100]   // len = 30, cap = 100-20 = 80
s2 := a[30:50:60]	 // len = 20, cap = 60-30 = 30 
s3 := a[30:50]	     // len = 20, cap = len(a)-30 = 70 

str := "Hello"[:3]   // "Hel"
```

`copy` 将数据从源切片复制到目标切片（可重叠），返回复制元素数，最多复制较短切片长度的元素个数。 

```go
dst := make([]byte, len(s), (cap(s)+1)*2)
copy(dst, src)
src = dst
```

内置的 `append` 函数将元素 `x` 附加到切片 `s` 的末尾，并且如果需要更大的容量则增大切片（重新创建一个新的足够容纳切片元素的底层数组）。

```go
a := []string{"John", "Paul"}
b := []string{"George", "Ringo", "Pete"}
a = append(a, b...) // equivalent to "append(a, b[0], b[1], b[2])"
// a == []string{"John", "Paul", "George", "Ringo", "Pete"}

// append 的行为相当于 AppendByte：将数据附加到切片的末尾
func AppendByte(slice []byte, data ...byte) []byte {
    m := len(slice)
    n := m + len(data)
    if n > cap(slice) { // if necessary, reallocate
        // allocate double what's needed, for future growth.
        newSlice := make([]byte, (n+1)*2)
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:n]
    copy(slice[m:n], data)
    return slice
}

p := []byte{2, 3, 5} 
p = AppendByte(p, 7, 11, 13)
// p == []byte{2, 3, 5, 7, 11, 13}
```

> **多维切片**

切片始终是一维的，可以组合成多维切片，内部切片必须单独初始化。要创建二维数组或切片的等价物，需要定义一个数组的数组或切片的切片：

```go
type Transform [3][3]float64  // A 3x3 array, really an array of arrays.
type LinesOfText [][]byte     // A slice of byte slices.

text := LinesOfText{   // 每个内部切片可能具有不同的长度
    []byte("Now is the time"),
    []byte("for all good gophers"),
    []byte("to bring some fun to the party."),
}
```

>---
#### 4.5. Struct

结构包含一组命名唯一的元素字段，不能自包含。字段可以是显式指定（*IdentifierList*）或嵌入指定（*EmbeddedField*）。`_` 在结构声明中可以充当填充字节。

```go
// An empty struct.
struct {}
// A struct with 6 fields.
struct {
	x, y int
	u float32
	_ float32  // 填充 4 字节 
	A *[]int
	F func()
}
```

结构的嵌入字段必须指定为类型 `T` 或指向非接口类型 `*T` 的指针，并且 `T` 其本身可能不是指针类型。`T` 的非限定类型名称充当字段名称。

```go
// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4
struct {
	T1        // field name is T1
	*T2       // field name is T2
	P.T3      // field name is T3
	*P.T4     // field name is T4
	x, y int  // field names are x and y
}

// 以下声明是非法的，名称不唯一：
struct {
	T     // conflicts with embedded field *T and *P.T
	*T    // conflicts with embedded field T and *P.T
	*P.T  // conflicts with embedded field T and *T
}
```

如果 `x.f` 是表示 `x` 的字段 `f` 或方法 `f` 的合法选择器（*selector*），则结构体 `S` 中嵌入字段 `x` 的 `f` 被称为提升字段（`S.f`）或提升方法（`S.f()`）。提升字段无法直接作为结构体初始化器的显示指定字段名称。相同的名称不能出现在相同的嵌套级别，更浅层次的名称将覆盖更深层次的相同名称成员。

```go
type Point2D struct {
	X, Y int
}
type Point3D struct {
	Point2D
	Z int
}

var Origin3D = Point3D{Point2D: Point2D{0, 0}, Z: 0}
var p = Origin3D
p.X += 1 // 提升字段 X, 相当于 p.Point2D.X
p.Y += 1 // 提升字段 Y
```

给定结构类型 `S` 和命名类型 `T`，*提升方法* 包含在结构的方法集中：
- 如果 `S` 包含嵌入字段 `T`，则 `S` 和 `*S` 的方法集都包含带有接收器 `T` 的提升方法。`*S` 的方法集还包括带有接收器 `*T` 的提升方法。
- 如果 `S` 包含嵌入字段 `*T`，则 `S` 和 `*S` 的方法集都包含带有接收器的 `*T` 或 `T` 的提升方法。

```go
type Embed struct{}
type Sample struct {
	Embed
}
func (Embed) Func() {}

func test() {
	s := Sample{}
	s.Func() // 提升方法
}
```

结构字段可以尾随一个可选的字符串标记作为属性。这些标记可由反射接口可见。

```go
struct {
	x, y float64 ""  // an empty tag string is like an absent tag
	name string  "any string is permitted as a tag"
	_    [4]byte "ceci n'est pas un champ de structure"
}

// A struct corresponding to a TimeStamp protocol buffer.
// The tag strings define the protocol buffer field numbers;
// they follow the convention outlined by the reflect package.
struct {
	microsec  uint64 `protobuf:"1"`  // key:value
	serverIP6 uint64 `protobuf:"2"`
}
```

>---
#### 4.6. Function

函数类型可表示具有相同参数和结果类型的所有函数声明的集合。未初始化值为 `nil`。

```go
type VoidFunc func()
type Add func(a int, b int) int
type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)   // 多值返回

var split SplitFunc  // nil
```

函数声明在参数或结果列表中，标识符名称必须全部存在或全部不存在。可变参数 `...` 位于参数列表的最后一个。

```go
func foo()
func foo(x int)
func foo(a, _ int, z float32) bool
func foo(a, b int, z float32) (bool)
func foo(prefix string, values ...int)
func foo(a, b int, z float64, opt ...any) (success bool)    
func foo(int, int, float64) (float64, *[]int)
func foo() func(int,int)     // return type func(int,int)
```

与 C 家族的所有语言一样，Go 中的所有内容都是通过值传递的。也就是说，一个函数总是得到一个传递对象的副本。与 C 不同的是，Go 可以返回局部变量或按值传递的函数参数的地址；与变量相关的存储在函数返回后可以存在。可以对复合文本进行地址运算：

```go
return &File{fd, name, nil, 0}
```

> **函数声明**

函数声明将标识符绑定到函数。如果函数声明指定了类型参数，则函数表示为泛型函数。

```go
func IndexRune(s string, r rune) int {
	for i, c := range s {
		if c == r {
			return i
		}
	}
	// invalid: missing return statement
}
func Min[T ~int | ~float64](x, y T) T {
	if x < y {
		return x
	}
	return y
}
```

非泛型函数声明可以省略函数体，以导入非 Go 实现的函数，例如汇编例程。

```go
func flushICache(begin, end uintptr)  // implemented externally
```

> **可变参数**

可变参函数 `func f(arg T1, p ...T)` 包含可变参数 `p ...T`，`p ...T` 等价于类型 `[]T`。未传递可变参数时，`p` 值为 `nil`。

```go
func Greeting(prefix string, who ...string)
Greeting("nobody")   // who == nil
Greeting("hello:", "Joe", "Anna", "Eileen")  // who = []string{"Joe", "Anna", "Eileen"}
```

可变参数 `p ...T` 可以赋值 `[]T...`，它作为 `p` 的实参进行传递。在这种情况下，不会创建新切片。

```go
s := []string{"James", "Jasmine"}
Greeting("goodbye:", s...)   // who = s
```

> **函数文本**

函数文本可以表示匿名函数，或作为值赋值给变量或直接调用。函数文本不能声明类型参数。

```go
// 赋值变量
f := func(x, y int) int { return x + y }
rt = f(x, y)

// 直接调用
func(ch chan int) { ch <- ACK }(replyChan)   
```

> **函数闭包**

闭包可以直接引用其包围函数中定义的局部变量。

```go
func main() {
	done := make(chan bool)

	values := []string{"a", "b", "c"}
	for _, v := range values {
		go func() {
			fmt.Println(v)
			done <- true
		}()
	}

	// wait for all goroutines to complete before exiting
	for range values {
		<-done
	}
}
// before go1.22  output is c, c, c
// since go1.22   output is a, b, c
// 注：在 GO 1.22 之前，由于每次迭代在闭包中都使用一个变量 v 的同一实例，因此最终的输出可能是 `c, c, c`。
//     也就是说自 goroutine 启动时，闭包变量已经发生了改变。这种语言的行为被认为是一个错误，并且在
//     Go 1.22 中得到了解决，它为每次迭代创建了一个新变量，并消除了这个问题。
```

> **方法与接收器**

方法是一个带有接收器的函数，可以为任何非指针或接口的命名类型定义方法。接收器的类型可以是已定义类型 `T` 或 `*T`。方法绑定到其接收器基类型 `T`，并且仅在 `T` 或 `*T` 的选择器中可见。

```go
func (t T) Method(args) 	// receiver is T
func (pt *T) Method(args)	// receiver is *T
func (T) Method(args) 		// 省略接收器和参数的标识符
```

如果接收器基类型是泛型类型，则接收器规范必须声明要使用的方法的相应类型参数。

```go
type Pair[U T1, V T2] struct { ... }
func (p Pair[A, B]) Swap() Pair[B, A]  { ... }  // receiver declares A, B
func (p Pair[First, _]) First() First  { ... }  // receiver declares First, corresponds to A in Pair
```
在类型方法集中，每个方法单一定义。方法集关联了对该类型的操作（方法集可能是空的）：
- 类型 `T` 的方法集由所有使用接收器类型 `T` 声明的方法组成，不包含 `*T` 接收器方法集。
- 指向类型 `T` 的指针的方法集是使用接收器 `*T` 或 `T` 声明的所有方法的集合。
- 接口类型的方法集是接口类型集中每个类型的方法集的交集（结果方法集通常只是接口中声明的方法集）。

若嵌入成员的方法集提升为结构的方法集，则该结构同样实现了嵌入成员的接口。

```go
type I interface {
	Func()
}
type Embed struct{}
func (Embed) Func() {}   // Embed 实现 I
type S struct {          // S 实现 I
	Embed	
}
func main() {
	I(S{}).Func()
}
```


>---

#### 4.7. Interface

接口类型定义类型集。接口变量可以存储其关联类型集中任何类型的值，这样的类型被称为实现接口类型。未初始化接口值为 `nil`。接口元素可以是方法、嵌入接口、类型约束（类型约束可以是一个或多个类型项的联合），不能自包含。

> **基接口**

基接口完全由方法列表组成定义，不包含嵌入接口和类型约束。基接口定义的类型集是实现所有这些方法的类型集。所有定义类型都实现了空接口 `interface {}`，它代表所有（非接口）类型的集合。预声明 `any` 是空接口的别名，即 `type any = interface{}`。

```go
// A simple File interface.
type File interface {
	Read([]byte) (int, error)
	Write([]byte) (int, error)
	Close() error
}
// 类型 T 实现了接口 File
func (p T) Read(p []byte) (n int, err error) { ... }
func (p T) Write(p []byte) (n int, err error) { ... }
func (p T) Close() error { ... }
```


> **嵌入接口**

接口 `T` 可以使用接口 `E` （可能是限定的）作为嵌入的接口元素。`T` 的类型集是所有符合 `T` 类型约束并实现 `T` 和 `E` 所有方法的类型集合。嵌入接口时，具有相同名称的方法必须具有相同的签名。
  
```go
type Reader interface {
	Read(p []byte) (n int, err error)
	Close() error
}

type Writer interface {
	Write(p []byte) (n int, err error)
	Close() error
}

// ReadWriter's methods are Read, Write, and Close.
type ReadWriter interface {
	Reader 
	Writer 
}
```

> **类型集与类型约束**

类型约束限定接口的类型集。类型约束项可以是任意类型项 `T`、或是非接口类型的底层形式 `~T`、或是类型项的联合 `t1 | t2 | … | tn`。
- 空接口的类型集是所有非接口类型的集合。
- 非空接口的类型集是与其所有嵌入接口类型集的交集。
- 方法规范的类型集是其方法集包含该方法的所有非接口类型的集合。
- 非接口类型项的类型集是仅由该类型组成的集合。
- 形式为 `~T` 项的类型集是底层类型为 `T` 的所有类型的集合。
- 项 `t1 | t2 | … | tn` 联合的类型集是项类型集的联合。

根据构造，接口的类型集从不包含接口类型。

```go
// An interface representing only the type int.
interface {
	int
}

// An interface representing all types with underlying type int.
interface {
	~int
}

// An interface representing all types with underlying type int that implement the String method.
interface {
	~int
	String() string
}

// An interface representing an empty type set: there is no type that is both an int and a string.
interface {
	int
	string
}

// The interface represents all floating-point types.
interface {
	~float32 | ~float64
}
```

形式 `T` or `~T` 的项中的类型 `T` 不能是类型参数，一组约束联合中的所有非接口项的类型集必须两两不相交（类型集的两两相交必须为空）。给定一个类型参数 `P`：

```go
type Float interface {
	~float32 | ~float64
}
type I[P string] interface {
	P               // illegal: P is a type parameter
	int | ~P        // illegal: P is a type parameter
	~int | MyInt    // illegal: the type sets for ~int and MyInt are not disjoint (~int includes MyInt)
	float32 | Float // overlapping type sets but Float is an interface
}
```

联合类型约束列表中不能包含是 `comparable` 或嵌入 `comparable` 的指定方法或包含该特定方法的接口。`comparable` 是一个由所有可比较类型（布尔、数值、字符串、指针、通道、可比较类型的数组、字段都是可比较类型的结构）实现的接口。`comparable` 只能用作类型参数约束。

```go
type IComparable interface{
	comparable
}
```

非基接口只能用作类型约束，或用作约束其他接口的元素。

```go
var x Float                     // illegal: Float is not a basic interface
var x interface{} = Float(nil)  // illegal

type Floatish struct {
	f Float                     // illegal
}
```

> **实现接口**

如果满足以下条件：
- `T` 不是接口，是 `I` 类型集的一个元素；或
- `T` 是一个接口，`T` 的类型集是 `I` 类型集的一个子集。

如果 `T` 实现了接口或它的方法集中包含接口的方法，则类型 `T` 的值实现了接口。

```go
type ISample interface {
	~int | ~float32 | ~float64
	Foo()
}
type MInt int
func (MInt) Foo() { ... }    // MInt 实现了泛型接口 ISample[int]
type MFloat float32
func (MFloat) Foo() { ... }  // MFloat 实现了泛型接口 ISample[float32]

func Foo[I ISample](i I) {
	i.Foo()
}
func main() {
	Foo[MInt](10)
	Foo[MFloat](3.1415)
}
```

>---
#### 4.8. Map

映射是一种由键值对组成的无序组，可以用来表示哈希表，未初始化值为 `nil`。映射包含对底层数据结构的引用。映射的键可以是任何 `comparable` 类型，如布尔、整数、浮点数、复数、字符串、指针、接口（只要动态类型支持相等）、通道、结构和数组；元素类型可以是任何类型。

映射、切片、函数不能用作映射的键类型，因为没有在这些类型上实现定义 `==` 运算（只支持与 `nil` 的相等运算）。

```go
var m map[string]int                 	// nil
var m2 map[*T]struct{ x, y float64 } 	// nil
var m3 map[string]interface{}    		// nil
```

`nil` 映射无法添加任何元素，尝试写入 `nil` 映射将导致 *panicking*。使用 `make(map [,capacity])` 构造一个非 `nil` 空映射，或使用复合文本构造映射。映射初始容量不受 `capacity` 限制，其长度会随着存储键值对的数量而增长。使用 `len` 获取映射的长度。通过 `delete(map, key)` 删除键值对或 `clear(map)` 清空映射。

```go
// 映射复合文本初始化
var timeZone = map[string]int{    
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
// 读取映射
offset := timeZone["EST"]  

var s_map map[string]bool = make(map[string]bool)   // 相当于 var s_map = map[string]bool{}
// 添加元素
s_map["a"] = true
s_map["b"] = true
s_map["c"] = true
s_map["d"] = true
s_map["e"] = true
s_map["f"] = true

// 删除或清空
delete(s_map, "a")
clear(s_map)
```

读取映射不存在键的值时返回零值。多重赋值检查映射是否包含该键。

```go
if rt, ok := timeZone[tz]; ok{
	 // read successful
	 // and use rt ... 
}
```

使用 `for ... range` 迭代映射：

```go
for k, v := range m {
    fmt.Println("Key:", k, "Value:", v)
}
```

> **并发中的映射**

并发中使用映射并不安全：它没有定义当多个 *goroutine* 同时读写它们时会发生什么。如果需要从并发执行的 *goroutine* 中读取和写入一个映射，那么访问必须同步，例如使用 `sync.RWMutex`。下面声明了一个 `counter` 变量，该变量是一个包含 `map` 和嵌入的 `sync.RWMutex` 的匿名结构。

```go
var counter = struct{
    sync.RWMutex
    m map[string]int
}{m: make(map[string]int)}
```

若要从 `counter` 读取，使用读锁：

```go
counter.RLock()
n := counter.m["some_key"]
counter.RUnlock()
fmt.Println("some_key:", n)
```

要写入 `counter`，使用写锁：

```go
counter.Lock()
counter.m["some_key"]++
counter.Unlock()
```

>---
#### 4.9. Channel

通道用于在并发中进行数据通信，未初始化值为 `nil`。可选 `<-` 运算符指定通道方向	，通道被限制为仅发送（`<-chan`）、仅接收（`chan<-`）或双通道（`chan`）。通道充当先进先出队列。如果一个 *goroutine* 在通道上发送值，而另一个 *goroutine* 接收这些值，则将按发送顺序接收这些值。

```go
var ch  chan T          // can be used to send and receive values of type T
var ch1 chan<- float64  // can only be used to send float64s
var ch2 <-chan int      // can only be used to receive ints
```


使用 `make(chan [, capacity])` 构造初始化通道，`capacity` 设置通道缓冲区的大小，零值表示为无缓冲，即仅当发送方和接收方都准备就绪时，通信才会成功。否则，如果缓冲区未满（发送）或未空（接收）时，通道将缓冲且不会阻塞。 `nil` 通道永远无法进行通信。

```go
ch := make(chan int, 100)  
// send data
ch <- 1
// receive data
rt := <- ch
```

使用 `close` 关闭通道，关闭后的通道无法继续充当发送方。*接收运算符* 的多值分配报告是否在通道关闭之前发送了接收值。

```go
if _, ok := <-ch; ok {
	close(ch)
} 
```

>---
#### 4.10. 复合文本

复合文本的核心类型 `T` 必须是 `struct`、`array`、`slice` 或 `map` 类型（或该类型的命名类型）。复合文本成员的值按字段声明顺序全部列出；或以 *field : value* 对可选列出，缺失项零初始化。*field* 解释为结构文本的字段名称、数组和切片文本的索引、映射文本的键。取址复合文本值会生成一个指针，并为该值创建堆存储。

```go
type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }
// 结构复合文本
origin := Point3D{}                            // zero value for Point3D
line := Line{origin, Point3D{y: -4, z: 12.3}}  // zero value for line.q.x
line2 := Line{p:origin}                        // zero value for line.q

// 数组、切片和映射文本
var arr = [5]int{0, 1: 0, 3: 3, 4}   // arr[2] == 0
days := [...]string{"Sat", "Sun"}    // 静态推断，len(days) == 2
s := []T{x1, x2, … xn}
var m = map[string]int{
	"a": 1,
	"b": 2,
	"c": 3,
	...
}
```

切片或映射的零值与已初始化但为空的值不同。取址空切片或映射复合文本与使用 `new` 的效果不同。

```go
p1 := &[]int{}    // p1 points to an initialized, empty slice with value []int{} and length 0
p2 := new([]int)  // p2 points to an uninitialized slice with value nil and length 0
```

在数组、切片或映射类型 `T` 的复合文本中，若文本与 `T` 的元素或键类型相同，本身又是复合文本的元素或映射键时，可以省略相应的文本类型。类似地，当元素或键类型为 `*T` 时，作为复合文本地址的元素或键可以省略 `&T`。

```go
[...]Point{{1.5, -3.5}, {0, 0}}     // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}          // same as [][]int{[]int{1, 2, 3}, []int{4, 5}}
[][]Point{{{0, 1}, {1, 2}}}         // same as [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}
map[string]Point{"orig": {0, 0}}    // same as map[string]Point{"orig": Point{0, 0}}
map[Point]string{{0, 0}: "orig"}    // same as map[Point]string{Point{0, 0}: "orig"}

type PPoint *Point
[2]*Point{{1.5, -3.5}, {}}          // same as [2]*Point{&Point{1.5, -3.5}, &Point{}}
[2]PPoint{{1.5, -3.5}, {}}          // same as [2]PPoint{PPoint(&Point{1.5, -3.5}), PPoint(&Point{})}
```


>---
#### 4.11. Pointer

指针类型表示指向给定类型变量的所有指针的集合，未初始化值为 `nil`。函数 `new` 返回指向给定类型零初始化后的对象的指针。

```go
var p *Point = &Point{0, 0}
var pa *[4]int    // nil

pm := new(map[int]bool)   // *pm = nil
p := new(Point2D)         // *Point2D
p.X = 10                  // (*p).X = 10

var pa = new([10]int)
pa[0] = 10                // (*p)[0] = 10
print(unsafe.Sizeof(*pa)) // 80
```

`&` 地址运算符用于获取变量的地址，无法从函数标识符或函数文本直接获取函数地址。

```go
type Func func()
func f() {}

func F(*Func) {}

F(&f)  // illegal

var p Func = f
F(&p)  // ok, 函数变量
```

可以直接获取堆栈变量或复合文本的地址。

```go
func NewPoint2D() *Point2D {
	return &Point2D{0, 0}
}
```

>---
#### 4.12. 命名类型

命名类型包括 *别名声明* 和 *类型定义*。类型别名与原类型等价，具有与原类型相同的方法集；类型定义定义新类型，它们的底层类型相同。

```go
type byte = uint8			// byte 是 uint8 的别名
type myString string		// myString 是新类型定义

var myStr myString = "Hello"
var b byte = myStr[0]

fmt.Printf("myStr is %T\n", myStr)		// myStr is main.myString
fmt.Printf("b is %T\n", b)				// b is uint8

type List[T any] struct {   // 定义泛型结构
	next  *List[T]
	value T
}

type IBlock interface {     // 定义接口类型
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}
```

>---
#### 4.13. 类型和值的属性

> **底层类型**

每个类型 `T` 都有一个底层类型：如果是布尔类型、数值类型或字符串类型之一，或者是类型模板，则 `T` 相应的底层类型就是 `T` 其本身；否则 `T` 的底层类型是其声明中引用的底层类型。对于类型参数，底层类型其类型约束（始终为接口）的底层类型。

```go
type (
	A1 = string     // string
	A2 = A1		    // string
)

type (
	B1 string		// string
	B2 B1			// string
	B3 []B1         // []B1
	B4 B3 			// []B1
)

func f[P any](x P) { … }     // interface{}
```

> **核心类型**

每个非接口类型 `T` 都有一个核心类型，该类型与底层类型 `T` 相同。如果满足以下条件之一，则接口 `I` 具有核心类型：
- 有一个单一类型 `U`，它是 `I` 类型集中所有类型的底层类型；或
- `I` 的类型集只包含具有相同元素类型 `E` 的通道类型，且所有具有方向的通道方向相同。

根据定义，核心类型从来都不是定义类型、类型参数或接口类型。具有核心类型的接口示例：

```go
type Celsius float32
type Kelvin  float32

interface{ int }                          // int
interface{ Celsius|Kelvin }               // float32
interface{ ~chan int }                    // chan int
interface{ ~chan int|~chan<- int }        // chan<- int
interface{ ~[]*data; String() string }    // []*data
```

不带核心类型的接口示例：

```go
interface{}                               // no single underlying type
interface{ Celsius | float64 }            // no single underlying type
interface{ chan int | chan<- string }     // channels have different element types
interface{ <-chan int | chan<- int }      // directional channels have different directions
```

一些操作（例如切片表达式，切片拼接或复制）依赖于接受字节切片和字符串切片的宽松类型形式。具体来说，如果有恰好两种类型 `[]byte` 和 `string`，它们是接口 `T` 类型集中所有类型的底层类型，`T` 的核心类型称为 *`bytestring`*。

```go
interface{ []byte | string }              // bytestring
interface{ ~[]byte | myString }           // bytestring
```

>---
#### 4.14. 泛型声明

泛型类型的反射信息包括完整的编译时类型信息。

```go
// 泛型类型
type T[P *C] …
type T[P (C)] …
type T[P *C|Q] …

func foo[U T1 | T2](args)  
func foo[U T1, V T2 | ~string](args)  
```

在泛型类型 `T` 的类型参数列表内，类型约束不能自引用 `T`。

```go
type T1[P T1[P]] …                    // illegal: T1 refers to itself
type T2[P interface{ T2[int] }] …     // illegal: T2 refers to itself
type T3[P interface{ m(T3[int])}] …   // illegal: T3 refers to itself
type T4[P T5[P]] …                    // illegal: T4 refers to T5 and
type T5[P T4[P]] …                    //          T5 refers to T4

type T6[P int] struct{ f *T6[P] }     // ok: reference to T6 is not in type parameter list
```

> **泛型约束**

泛型约束是定义所有允许的类型参数集的接口类型，并控制该类型参数的值所允许的操作。形式为 `P E` 的泛型约束，相当于 `P interface{E}`（`interface` 可省略）。

```go
[T []P]                      // 相当于 [T interface{[]P}]
[T ~int]                     // 相当于 [T interface{~int}]
[T int|string]               // 相当于 [T interface{int|string}]
```

预声明接口类型 `comparable` 表示所有严格可比较的非接口类型的集合。尽管非类型参数的接口是可比较的，但它们不是严格可比较的，因为它们不能实现 `comparable`，但它们满足 `comparable` 约束。

```go
int                          // implements comparable (int is strictly comparable)
[]byte                       // does not implement comparable (slices cannot be compared)
interface{}                  // does not implement comparable (see above)
interface{ ~int | ~string }  // type parameter only: implements comparable (int, string types are strictly comparable)
interface{ comparable }      // type parameter only: implements comparable (comparable implements itself)
interface{ ~int | ~[]byte }  // type parameter only: does not implement comparable (slices are not comparable)
interface{ ~struct{ any } }  // type parameter only: does not implement comparable (field any is not strictly comparable)
```

> **泛型实例化**

首先在泛型声明中，每个类型参数都替换为其对应的类型实参；在替换之后，每个类型实参必须满足相应类型参数的约束（必要时实例化）。实例化类型会产生一个新的非泛型命名类型；实例化函数会产生一个新的非泛型函数。

```go
type parameter list    type arguments    after substitution
-----------------------------------------------------------------
[P any]                int               // int satisfies any
[S ~[]E, E any]        []int, int        // []int satisfies ~[]int, int satisfies any
[P io.Writer]          string            // illegal: string doesn't satisfy io.Writer
[P comparable]         any               // any satisfies (but does not implement) comparable
```

类型参数可以显式提供，或者根据上下文推断。对于泛型类型，必须始终显式提供所有类型参数。

```go
// sum returns the sum (concatenation, for strings) of its arguments.
func sum[T ~int | ~float64 | ~string](x... T) T { … }

x := sum                       // illegal: the type of x is unknown
intSum := sum[int]             // intSum has type func(x... int) int
a := intSum(2, 3)              // a has value 5 of type int
b := sum[float64](2.0, 3)      // b has value 5.0 of type float64
c := sum(b, -1)                // c has value 4.0 of type float64

type sumFunc func(x... string) string
var f sumFunc = sum            // same as var f sumFunc = sum[string]
```


---
### 5. 表达式与运算符


一元运算符具有最高的优先级。二元运算符优先级，依次是：

```go
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||
```

>---
#### 5.1. 算术运算

一元运算符 `+`、`-` 和 `^` 定义如下：


| Operator | description                                                                     | range                            |
| :------- | :------------------------------------------------------------------------------ | :------------------------------- |
| +x       | 0 + x                                                                           | integers, floats, complex values |
| -x       | 0 - x                                                                           | integers, floats, complex values |
| ^x       | bitwise complement :  m ^ unsigned x (m = "all bits set to 1") or -1 ^ signed x | integers                         |

二元算术运算符（`+`、`-`、`*`、`/`）适用于整数、浮点和复数类。按位逻辑运算符和移位运算符仅适用于整数。

| Operator | description         | range                                     |
| :------- | :------------------ | :---------------------------------------- |
| +        | sum                 | integers, floats, complex values, strings |
| -        | difference          | integers, floats, complex values          |
| *        | product             | integers, floats, complex values          |
| /        | quotient            | integers, floats, complex values          |
| %        | remainder           | integers                                  |
| &        | bitwise AND         | integers                                  |
| \|       | bitwise OR          | integers                                  |
| ^        | bitwise XOR         | integers                                  |
| &^       | bit clear (AND NOT) | integers                                  |
| <<       | left shift          | integer << uint                           |
| >>       | right shift         | integer >> uint                           |

注：整数商 `q = x / y` 和余数 `r = x % y` 满足关系 `x = q*y + r` 和 `|r| < |y|`。其中 `x / y` 向零截断（“截断除法”）：

```go
 x     y     x / y     x % y
 5     3       1         2
-5     3      -1        -2
 5    -3      -1         2
-5    -3       1        -2
```

>---
#### 5.2. 赋值运算

```go
assign_op  	   =
add_assign_op  +=  -=  |=  ^= 
mul_assign_op  *=  /=  %=  <<= >>=  &=  &^= 
-----------------------------------------------
x = 1
*p = f()
a[i] = 23
(k) = <-ch   // 接收
_ = g()      // 弃用
```

多值赋值将表达式结果的各个元素赋值给变量列表。分配是按从左到右的顺序进行的。

```go
x, y = f()
a, b = b, a  // exchange a and b

x, i := []int{1, 2, 3}, 0
i, x[i] = 1, 2  // set i = 1, x[0] = 2
x[i], i = 2, 2  // set x[1] = 2, i = 2

type Point struct { x, y int }
var p *Point      // nil
x[2], p.x = 6, 7  // set x[2] = 6, then panic setting p.x = 7
```

>---
#### 5.3. 比较运算

```go
==    equal
!=    not equal
<     less
<=    less or equal
>     greater
>=    greater or equal
```

排序运算符 `<`、`<=`、`>` 和 `>=` 适用于有序类型的操作数，包括非复数数值类型和字符串类型。

相等运算符 `==` 和 `!=` 适用于可比类型的操作数，包括布尔、数值、字符串、指针、通道、非类型参数接口、具有可比较动态值的接口、接口动态值与接口比较、字段为可比较的结构、长度相等的可比较数组、严格可比较类型参数的实例化类型等。布尔、数值、字符串、指针和通道等类型是严格可比的（*strictly comparable*）。切片、映射和函数类型不可比较，但支持与 `nil` 进行比较。也允许将指针、通道和接口值与 `nil` 进行比较。

```go
const c = 3 < 4            // c is the untyped boolean constant true

type MyBool bool
var x, y int
var (
	// The result of a comparison is an untyped boolean.
	// The usual assignment rules apply.
	b3        = x == y // b3 has type bool
	b4 bool   = x == y // b4 has type bool
	b5 MyBool = x == y // b5 has type MyBool
)
```

>---
#### 5.4. 逻辑运算

逻辑运算符应用于布尔表达式，遵从短路原则：

```go
&&    conditional AND    p && q  is  "if p then q else false"
||    conditional OR     p || q  is  "if p then true else q"
!     NOT                !p      is  "not p"
```

>---
#### 5.5. 选择表达式

选择表达式 `x.f` 表示对象 `x` 的字段或方法 `f`，或其类型 `T` 嵌入字段的提升字段或提升方法。在 `T` 中声明的字段或方法 `f` 的深度为零，提升字段或提升方法按其深度依次递增。以下规则适用于选择器：
- 对于非指针或接口类型 `T` 或 `*T` 的值 `x`，`x.f` 表示在 `T` 中最浅深度的字段或方法，深层次的 `f` 被更浅层次的 `f` 隐藏。
- 对于接口类型 `I` 的值 `x`，`x.f` 表示具有动态值 `x` 的实际方法 `f`。
- 如果 `x` 的类型是定义的指针类型，而 `(*x).f` 是表示字段（但不是方法）的有效选择表达式，则 `x.f` 是 `(*x).f` 的简写。
- 在所有其他情况下，`x.f` 都是非法的。

```go
// 给定类型
type T0 struct {
	x int
}
func (*T0) M0()

type T1 struct {
	y int
}
func (T1) M1()

type T2 struct {
	z int
	T1
	*T0
}
func (*T2) M2()
type Q *T2
// 给定对象
var t T2     // with t.T0 != nil
var p *T2    // with p != nil and (*p).T0 != nil
var q Q = p
// 有效调用
t.z          // t.z
t.y          // t.T1.y
t.x          // (*t.T0).x
p.z          // (*p).z
p.y          // (*p).T1.y
p.x          // (*(*p).T0).x
q.x          // (*(*q).T0).x        (*q).x is a valid field selector
p.M0()       // ((*p).T0).M0()      M0 expects *T0 receiver
p.M1()       // ((*p).T1).M1()      M1 expects T1 receiver
p.M2()       // p.M2()              M2 expects *T2 receiver
t.M2()       // (&t).M2()           M2 expects *T2 receiver, see section on Calls
// 无效调用
q.M0()       // (*q).M0 is valid but not a field selector, Q 是类型定义，非 *T2 别名
// 若 type Q = *T2, 则 q.M0() 成立
```

>---
#### 5.6. 方法表达式

如果方法 `M` 在类型 `T` 的方法集中，则方法表达式 `T.M` 可作为常规函数调用，方法接收器 `T` 的值作为 `T.M` 的第一个参数。例如一个类型为 `T` 的结构体，它有两个方法：`Mv`，其接收器类型为 `T`；`Mp`，其接收器类型为 `*T`。

```go
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver
```

方法表达式 `T.Mv` 生成一个与 `Mv` 等效的函数，它的第一个参数是显式传递的接收器变量值；`T.Mv` 具有签名 `func(tv T, a int) int`，以下调用是等效的：

```go
var t T

t.Mv(7)
T.Mv(t, 7)
(T).Mv(t, 7)
f := T.Mv; f1(t, 7)
```

方法表达式 `(*T).Mp` 也生成一个函数值，表示带有签名的 `Mp`：`func(tp *T, f float32) float32`。对于具有值接收器的方法 `T.Mv`，可以导出具有显式指针接收器的函数 `(*T).Mv`，`(*T).Mv` 生成 `func(tv *T, a int) int`。

```go
(&t).Mp(7.1)
(*T).Mp(&t, 7)
(*T).Mv(&t, 7)
f := (*T).Mp; f(&T{1}, 1)
``` 														

>---
#### 6.9. 类型断言

对于接口值 `x`（非类型参数）和类型 `T`：如果 `T` 不是接口类型，则 `x.(T)` 断言 `x` 的动态类型与类型 `T` 相同；如果 `T` 是接口类型，则 `x.(T)` 断言 `x` 的动态类型实现了接口 `T`。`i, ok := x.(T)` 检查类型断言是否成功：若断言成立，则 `i` 的值是存储在 `x` 中的值，类型为 `T`；否则 `i` 的值是类型 `T` 的零值。

```go
var x interface{} = 7          // x has dynamic type int and value 7
i := x.(int)                   // i has type int and value 7

type I interface { m() }
func f(y I) {
	s := y.(string)        // illegal: string does not implement I (missing method m)
	r := y.(io.Reader)     // r has type io.Reader and the dynamic type of y must implement both I and io.Reader
	if rt, ok := y.(IFace); ok {  // if ok == true, rt has dynamic type which implements IFace
		// use rt...
	}
}
```

>---
#### 5.7. 类型转换

类型转换 `T(expr)` 将表达式 `expr` 的类型更改为指定类型 `T`。

```go
*Point(p)        // same as *(Point(p))
(*Point)(p)      // p is converted to *Point
<-chan int(c)    // same as <-(chan int(c))
(<-chan int)(c)  // c is converted to <-chan int
func()(x)        // function signature func() x
(func())(x)      // x is converted to func()
(func() int)(x)  // x is converted to func() int
func() int(x)    // x is converted to func() int (unambiguous)
string([]byte{'a'})  // []byte{'h','e','l'} is converted to string
```

在以下任何情况下，非常量值 `x` 都可以转换为类型 `T`：
- `x` 可分配给 `T`。
- 忽略结构标记，`x` 和 `T` 不是类型参数，但具有相同的底层类型。
- `x` 和 `T` 都是整数或浮点类型。
- `x` 和 `T` 都是复数类型。
- `x` 是一个整数、字节切片、或字符切片，`T` 是一个字符串类型。
- `x` 是一个字符串，`T` 是 `[]byte` 或 `[]rune`。
- `x` 是一个切片，`T` 是切片元素类型的数组或数组指针。
- 没有语言机制可以在指针和整数之间进行转换。包 *`unsafe`* 在受限环境下实现此功能。

如果 `T` 或 `x` 的类型 `V` 是类型参数，如果满足以下条件之一，`x` 可以转换为类型 `T`：
- `V` 和 `T` 都是类型参数，并且 `V` 类型集中每个类型都可以转换为 `T` 类型集中的每个类型。
- 只有 `V` 是类型参数，并且 `V` 类型集中每个类型可以被转换为 `T`。
- 只有 `T` 是类型参数，而 `x` 可以转换为 `T` 类型集中的每个类型。

当为了转换的目的而比较结构类型的标识时，忽略结构标记：

```go
type Person struct {
	Name    string
	Address *struct {
		Street string
		City   string
	}
}

var data *struct {
	Name    string `json:"name"`
	Address *struct {
		Street string `json:"street"`
		City   string `json:"city"`
	} `json:"address"`
}

var person = (*Person)(data)  // ignoring tags, the underlying types are identical
```

---
### 6. 语句

#### 6.1. 递增递减语句：++, -- 


```go
IncDec statement    Assignment
----------------------------------
x++                 x += 1
x--                 x -= 1
```

>---
#### 6.2. 条件跳转语句：If, Switch

> **if-else**

```go
if [ SimpleStmt; ]? Expression { 
	Block 
} [ else ( IfStmt | Block ) ]?
```
```go
if x > max {
	x = max
}

if x := f(); x < y {    // SimpleStmt
	return x
} else if x > z {
	return z
} else {
	return y
}
```

> **ExprSwitch**

```go
switch [ SimpleStmt; ]? ExprSwitchGuard? {  
	case state [, state...]?:   // nil 不能作为 case 的检查条件
		StatementList 
		[fallthrough]?  // ExprSwitch 允许在 case 之间贯穿
	[default block]?
} 
```
```go
switch tag {
	case 0, 1, 2, 3: 
		s1()
	case 4, 5, 6, 7: 
		s2()
		fallthrough	
	default: s3()
}

switch x := f(); { 
	case x < 0: return -x
	default: return x
}

switch {
	case x < y: f1()
	case x < z: f2()
	case x == 4: f3()
}
```

> **TypeSwitch**

```go
switch [ SimpleStmt; ]? TypeSwitchGuard.(type) {   // TypeSwitchGuard 必须是接口类型
	case TypeList | default :  // 每个分支的 Type 必须实现 TypeSwitchGuard 或是 nil
		 StatementList
}  
```
```go
switch i := x.(type) {
	case nil:
		printString("x is nil")                
	case int:
		printInt(i)                            
	case float64:
		printFloat64(i)                        
	case func(int) float64:
		printFunction(i)                       
	case bool, string:
		printString("type is bool or string")  
	default:
		printString("don't know the type")     
}
```

类型参数或泛型类型可以用作 `case` 中的类型。泛型实例化后存在重复 `case` 分支时以首次匹配为准。

```go
func f[P any](x any) int {
	switch x.(type) {
	case P:
		return 0
	case string:
		return 1
	case []P:		// 首次匹配
		return 2			
	case []byte:
		return 3
	default:
		return 4
	}
}

var v1 = f[string]("foo")   // v1 == 0
var v2 = f[byte]([]byte{})  // v2 == 2
```

>---
#### 6.3. 迭代语句：For

```go
for [ ConditionExpr | ForClause | RangeClause ]? {
	Block
} 
```

> **单条件控制**

```go
for ConditionExpr? { 
	Block
}
for {  // ConditionExpr = true
	Block
}
```

>  **ForClause**


```go
for [ InitStmt ]? ; [ Condition ]? ; [ PostStmt ]? {
	Block
} 

for i := 0; i < 10; i++ {
	foo(i)
}
```

> **RangeClause**

`for-range` 迭代数组、切片、映射，逐字符迭代字符串、通道上接收值、或从零到指定上限的整数值。

```go
for [ IdentifierList ]? range RangeExpr  {
	Block
}
```

*RangeExpr* 的核心类型是数组、数组指针、切片、字符串、映射、接收通道、整数。如果范围表达式是通道或整数，最多允许一个迭代变量，否则最多可以有两个。

```go
for [index, elem :=]? range array, slice,*parray
for [index, rune :=]? range string
for [key, value  :=]? range map
for [receive 	 :=]? range chan, <-chan  // until closed 
for [index 	     :=]? range integer   // 0 ~ integer-1
```
```go
for i, r := range "Hello, 世界" { 
	println(i, r)
}

for key, val := range map[string]int{"mon":0, "tue":1, "wed":2, "thu":3, "fri":4, "sat":5, "sun":6} {
	println(key, val)
}

var ch chan Work = producer()
for w := range ch {
	doWork(w)
}
for range ch {}	// empty a channel

for i := range 10 { // from 0 to 9
	do(i)  // call do(0), do(1), ... do(9)
}
```

>---
#### 6.4. 跳转语句：Goto, Continue, Break, Return

标签语句可以是 `goto`、`break` 或 `continue` 语句的目标。

```go
func foo(){
    // ...
Error:    // 标签
    log.Panic("error encountered")
    // ...
}
```

> **goto**

`goto` 语句将控制转移到同一函数体中声明的非内层块标签处。

```go
Block{
	// ...
	goto Error 
	// ...
Error: 
	statement?
}
```

> **break**

`break` 语句用于终止最内层或指定标签的外层 `for`、`switch` 或 `select` 语句的执行。

```go
break [ Label ]? 

OuterLoop:
	for i = 0; i < n; i++ {
	InterLoop:
		for j = 0; j < m; j++ {
			switch a[i][j] {
			case nil:
				state = Error
				break   // break switch
			case item:
				state = Found
				break OuterLoop  // break OuterLoop for
			}
		}
	}
```

> **continue**

`continue` 语句通过将控制推进最内层 `for` 迭代体的末尾来开始下一次迭代。如果有标签，它必须是一个封闭的 `for` 语句的标签。

```go
continue [ Label ]? 

RowLoop:
	for y, row := range rows {
		for x, data := range row {
			if data == endOfRow {
				continue RowLoop
			}
			row[x] = data + bias(x, y)
		}
	}
```

> **return**

`return` 语句终止函数或方法的执行，并根据函数返回类型可选地提供一个或多个结果值。任何 `defer` 延迟函数都会在函数返回前执行。

有三种方法可以从具有结果类型的函数返回值：
- 返回值在 “`return`” 语句中显式列出。

	```go
	func simpleF() int {
		return 2
	}
	func complexF1() (re float64, im float64) {
		return -7.0, -4.0
	}
	```

+ “`return`” 可以是对多值函数的单个调用。

	```go
	func complexF2() (re float64, im float64) {
		return complexF1()
	}
	```

- 函数提供了结果参数名称并在函数返回前赋值，则 `return` 可能为空。

	```go
	func complexF3() (re float64, im float64) {
		re = 7.0
		im = 4.0
		return
	}

	func (devnull) Write(p []byte) (n int, _ error) {
		n = len(p)
		return
	}
	```

>---
#### 6.5. 并发语句：Go

`go calling-function` 开启一个独立的并发控制线程或 *goroutine* 以执行函数调用，函数参数在调用方 *goroutine* 中进行计算，执行在新例程中执行并且当前例程不会等待被调用函数完成。函数终止时，非 *main goroutine* 都会终止；任何返回值在并发函数完成时被丢弃。

```go
go Server()
go func(ch chan<- bool) { 
	for { 
		sleep(10)
		ch <- true 
	}
} (c)
```

>---
#### 6.6. 通道控制语句：Select

`select` 语句检查一组正在等待发送或接收的通道分支：
- 当某个通道未被阻塞时，`select` 执行该 `case chan` 或 `default`。
- 如果一个或多个通信可以进行，则经由统一的伪随机来选择。
- 否则，如果存在 `default`，则选择该分支。如果没有 `default`，则 `select` 阻塞，直到至少有一个通信可以继续。
- 由于 `nil` 通道上的通信永远无法继续，因此仅有 `case nil-chan` 分支的 `select` 将永远阻塞。

```go
select {
	[case ( SendStmt | RecvStmt )]* | default? : 
		StatementList
}
```
```go
var a []int
var c, c1, c2, c3, c4 chan int
var i1, i2 int
select {
	case i1 = <-c1:
		print("received ", i1, " from c1\n")
	case c2 <- i2:
		print("sent ", i2, " to c2\n")
	case i3, ok := (<-c3):  // same as: i3, ok := <-c3
		if ok {
			print("received ", i3, " from c3\n")
		} else {
			print("c3 is closed\n")
		}
	case a[f()] = <-c4:
		// same as
		// 	 case t := <-c4:
		//	 	a[f()] = t
	default:
		print("no communication\n")
}

for {  // send random sequence of bits to c
	select {
		case c <- 0:  // note: no statement, no fallthrough, no folding of cases
		case c <- 1:
	}
}

select {}  // block forever
```

>---
#### 6.7. 延迟语言：Defer

`defer` 语句挂起一个延迟函数，参数在挂起时计算。所有的延迟函数在当前函数返回前（设置任何结果参数之后）或 *panicking* 时按挂起逆序立即被调用。

```go
defer calling-function

func foo() {
	var l sync.Mutex
	l.Lock()
	defer l.Unlock() // unLock happens before surrounding function returns
	
	// prints 4 3 2 1 0 before surrounding function returns
	for i := 0; i < 5; i++ {
		defer fmt.Printf("%d ", i) // 4 3 2 1 0
	}
}

func(i, j int) {
	defer func(i, j int) {  
		println(i, j)
	}(i, j)   // i, j 参数在挂起时计算
	i++
	j++
}(1,2)   // print: 1 2
```

延迟函数可以通过闭包在返回结果参数之前访问和修改结果参数。

```go
func f() (result int) {
	defer func() {
		result *= 7   // f return 6*7
	}()
	return 6   // set result = 6
}
```

`defer` 应用的典型例子是解锁互斥锁或关闭文件。

```go
// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
```

---
### 7. 内置函数

#### 7.1. append：切片扩展

```go
func append(slice []Type, elems ...Type) []Type 
func append(slice []byte, str ...byteString) []byte  // 字节切片拼接字符串
```

`slice` 容量不足时自动扩容（长度一般为原容量的二倍）。

```go
s0 := []int{0, 0}
s1 := append(s0, 2)                // append a single element     s1 is []int{0, 0, 2}
s2 := append(s1, 3, 5, 7)          // append multiple elements    s2 is []int{0, 0, 2, 3, 5, 7}
s3 := append(s2, s0...)            // append a slice              s3 is []int{0, 0, 2, 3, 5, 7, 0, 0}
s4 := append(s3[3:6], s3[2:]...)   // append overlapping slice    s4 is []int{3, 5, 7, 2, 3, 5, 7, 0, 0}

var t []interface{}
t = append(t, 42, 3.1415, "foo")   //                             t is []interface{}{42, 3.1415, "foo"}

var b []byte
b = append(b, "bar"...)            // append string contents      b is []byte{'b', 'a', 'r' }
```

>---
#### 7.2. copy：切片复制

```go
func copy(dst, src []Type) int
func copy(dst []byte, src byteString) int   // 复制字符串到字节切片
```

函数 `copy` 将切片元素从源 `src` 复制到 `dst`，并返回所复制的元素的数目，最多复制较短切片长度个数的元素。支持在两个重叠内存的切片之间操作。

```go
var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
var b = make([]byte, 5)
n1 := copy(s, a[0:])            // n1 == 6, s is []int{0, 1, 2, 3, 4, 5}
n2 := copy(s, s[2:])            // n2 == 4, s is []int{2, 3, 4, 5, 4, 5}
n3 := copy(b, "Hello, World!")  // n3 == 5, b is []byte("Hello")
```

>---
#### 7.3. clear：清零或删除元素

```go
func clear[T ~[]Type | ~map[Key]Value](t T)
```

函数 `clear` 清空切片或映射的所有元素并使长度为 0，`clear(nil)` 无任何操作。如果 `clear` 的参数类型是类型参数，则其类型集中的所有类型都必须是映射或切片。

>---
#### 7.4. close：关闭通道

```go
func close(c chan<- Type)
```

函数 `close` 关闭非 `nil` 通道 `c` 并停止通信。在已关闭的通道上发送或再次调用 `close` 将导致 *panicking*。在通道关闭之后，在接收任何先前已发送的通信之后，任何接收操作将返回通道类型的零值且不会阻塞。多值接收操作 `_, ok := <-ch` 可以检查通道是否关闭。

>---
#### 7.5. complex、real、imag：复数操作

```go
func complex(r, i FloatType) ComplexType
func real(c ComplexType) FloatType
func imag(c ComplexType) FloatType
```

函数 `complex` 构造一个复数值，`real` 和 `imag` 提取复数的实部和虚部。`float32` 对应 `complex64`，`float64` 对应 `complex128`。`real` 和 `imag` 返回对应的浮点类型。对于复数类型 `Z` 的值 `z`，相当于 `Z(complex(real(z), imag(z)))`。

```go
var a = complex(2, -2)             // complex128
const b = complex(1.0, -1.4)       // untyped complex constant 1 - 1.4i
x := float32(math.Cos(math.Pi/2))  
var c64 = complex(5, -x)           // complex64
var s int = complex(1, 0)          // untyped complex constant 1 + 0i can be converted to int
_ = complex(1, 2<<s)               // illegal: 2 assumes floating-point type, cannot shift
var rl = real(c64)                 // float32
var im = imag(a)                   // float64
const c = imag(b)                  // untyped constant -1.4
_ = imag(3 << s)                   // illegal: 3 assumes complex type, cannot shift
```

>--- 
#### 7.6. delete：删除映射元素

```go
func delete(m map[Key]Value, key Key)
```

函数 `delete` 从映射 `m` 中删除键为 `key` 的键值对。如果操作数 `m` 是类型参数，则该类型集中的所有类型都必须是映射，且它们必须具有相同的键类型。如果映射 `m` 是 `nil` 或 `key` 不存在，则 `delete` 无操作。

```go
var m = map[int]string{
	0: "zero",
	1: "one",
	2: "two",
	3: "three",
	4: "four",
}
delete(m, 0)
for _, v := range m {
	print(v + ",")  // maybe: one,two,three,four,
}
```

>---
#### 7.7. len、cap：长度与容量

```go
func len(v Type) int
func cap(v Type) int
```

函数 `len` 和 `cap` 接受数组、数组指针、切片、映射、字符串、通道类型的参数，并返回相应的长度或通道缓冲区大小。如果操作数是类型参数 `P`，则调用 `len` 或 `cap` 必须对 `P` 类型集中的所有类型有效。在任何时候，`0 <= len(s) <= cap(s)` 关系成立。`nil` 切片、映射或通道的长度为 0，`nil` 切片或通道的容量为 0。

```go
Call      Argument type      Result
  
len(s)    string type        string length in bytes
          [n]T, *[n]T        array length (== n)
          []T                slice length
          map[K]T            map length (number of defined keys)
          chan T             number of elements queued in channel buffer
  
cap(s)    [n]T, *[n]T        array length (== n)
          []T                slice capacity
          chan T             channel buffer capacity
```

>---
#### 7.8. new：分配

```go
func new(t Type) *Type
// 相当于
func new(t T) *T{
	var t Type
	return &t
}
```

函数 `new(T)` 为类型 `T` 分配零初始化值的存储空间并返回其地址，结果类型为 `*T`。切片、映射、接口类型零初始化为 `nil`。 
 
```go
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
```

>---
#### 7.9. make：分配

```go
func make(s Slice [, length uinteger] [, capacity uinteger]) Slice    // length <= capacity
func make(m Map [, capacity uinteger]) Map
func make(ch Chan [, bufsize uuinteger]) Chan
```

函数 `make` 接受类型切片、映射、通道并创建相应类型零初始化的值。

```go
s := make([]int, 10, 100)       // slice with len(s) = 10, cap(s) = 100
s := make([]int, 1e3)           // slice with len(s) = cap(s) = 1000
s := make([]int, 1<<63)         // illegal: len(s) is not representable by a value of type int
s := make([]int, 10, 0)         // illegal: len(s) > cap(s)
c := make(chan int, 10)         // channel with a buffer size of 10
m := make(map[string]int, 100)  // map with initial space for approximately 100 elements
```

以下说明了 `new` 和 `make` 之间的区别。

```go
var p *[]int = new([]int)       // allocates slice structure; *p = nil
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100, 100)
*p := &v
```

>---
#### 7.10. min、max：极值

```go
func min[T cmp.Ordered](x T, y ...T) T
func max[T cmp.Ordered](x T, y ...T) T
```

函数 `min` 和 `max` 分别计算有序参数列表中的最小值或最大值。如果所有参数都是常量，则结果也是常量。

```go
var x, y int
m := min(x)                 // m == x
m := min(x, y)              // m is the smaller of x and y
m := max(x, y, 10)          // m is the larger of x and y but at least 10
c := max(1, 2.0, 10)        // c == 10.0 (floating-point kind)
f := max(0, float32(x))     // type of f is float32
var s []string
_ = min(s...)               // invalid: slice arguments are not permitted
t := max("", "foo", "bar")  // t == "foo" (string kind)
```

对于浮点参数负零、NaN 和无穷大，以下规则适用：

```go
   x        y    min(x, y)    max(x, y)
---------------------------------------------------------------------------------------------------
  -0.0    0.0         -0.0          0.0    // negative zero is smaller than (non-negative) zero
  -Inf      y         -Inf            y    // negative infinity is smaller than any other number
  +Inf      y            y         +Inf    // positive infinity is larger than any other number
   NaN      y          NaN          NaN    // if any argument is a NaN, the result is a NaN
```

>---
#### 7.11. panic、recover：异常处理

```go
func panic(v any)
func recover() any
```

函数 `panic` 和 `recover` 有助于报告和处理运行时异常和程序定义的错误条件。

在执行函数 `F` 过程中调用 `panic` 或 *panicking* 时会终止 `F` 的执行；任何 `F` 中延迟函数正常执行；最后由 `F` 返回它的调用方，未处理的 *panicking* 将传递给调用方并继续引发 *panicking* 并执行调用方的延迟函数。依此类推，直到执行至 *goroutine* 中的顶级函数延迟函数执行。此时程序终止并报告错误条件，并返回 `panic` 的参数值。

```go
panic(42)
panic("unreachable")
panic(Error("cannot parse"))
```

函数 `recover` 允许程序管理一个 *panicking* *goroutine* 的行为。假设一个函数 `G` 在它的延迟函数中调用 `recover` 并捕捉到了一个 *panicking*， `recover` 返回之前调用 `panic` 的参数，并终止当前 *goroutine* 上发生的 *panicking* 序列。在调用 `G` 和调用 `panic` 之间调用的函数的状态被丢弃，并且恢复后续执行。`recover` 未捕捉到 *panicking* 时的返回值是 `nil`。`panic` 的参数不能是 `nil`。

下面示例中的 `protect` 函数调用函数参数 `g`，并保护调用方免受 `g` 引发的运行时异常。

```go
func main() {
	protect(func() {
		var a, b int = 1, 0
		_ = a / b
	})
}
func protect(g func()) {
	defer func() {
		log.Println("done") // Println executes normally even if there is a panic
		if x := recover(); x != nil {
			log.Printf("run time panic: %v", x)
		}
	}()
	log.Println("start")
	g()
}
```

>---
#### 7.12. print、println：格式化输出

```go
func print(args ...Type)
func println(args ...Type)
```

函数 `print` 以特定方式格式化其参数，并将结果写入标准错误。函数 `println` 以特定方式格式化其参数，并将结果写入标准错误，参数之间总是添加空格，并在末尾附加换行符。

```go
m := map[int]int{1: 2, 3: 4, 5: 6}
s := []byte("Hello")
fmt.Println(1, 2, m, s) // 1 2 map[1:2 3:4 5:6] [72 101 108 108 111]
println(1, 2, m, s)     // 1 2 0xc000022180 [5/5]0xc00000a0d8
print(1, 2, m, s)       // 120xc000022180[5/5]0xc00000a0d8
```

---
### 8. Error 与 Run-time Panic

库例程必须经常向调用者返回某种错误指示。函数在返回结果值时可以同时返回某种详细的错误描述。例如，`os.Open` 在失败时不仅返回一个 `nil` 指针，它还返回一个描述错误的错误值。描述错误的接口类型为 `error`。

```go
type error interface {
	Error() string
}
```

预定义类型 `error` 表示错误条件的常规接口，返回 `nil` 值表示没有错误。例如可以定义一个从文件中读取数据的函数，在读取失败时返回 `0, err`：

```go
func Read(f* File, b []byte) (n int, err error)
```

在可行的情况下，错误字符串应该标识它们的来源，例如通过使用一个前缀来命名生成错误的操作或包。例如，在包 `image` 中，由于未知格式导致的解码错误的字符串表示是 “`image：unknown format`”。关心精确错误细节的调用方可以使用 *TypeSwitch* 或类型断言来查找特定错误并提取细节。

```go
for try := 0; try < 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
	// 类型断言
    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
```

执行错误（如试图将数组索引到边界之外）会触发一个运行时异常，相当于使用实现定义的接口类型 `runtime.Error` 的值调用函数 `panic`。该类型满足预先声明的接口类型 `error`。未指定表示不同运行时错误条件的确切错误值。

```go
package runtime

type Error interface{
	error
	// and perhaps other methods
}
```

函数通常在最后的返回值中返回错误信息。使用 `errors.New` 可返回一个错误信息：

```go
func Sqrt(f float64) (float64, error) {
    if f < 0 {
        return 0, errors.New("math: square root of negative number")
    }
    // ...
}
```

>---
#### 8.1. Panic

向调用方报告错误的常用方法是返回一个 `error` 作为额外的返回值。与之不同的是，调用函数 `panic` 会创建一个运行时错误，从而停止程序。该函数接受一个非 `nil` 任意类型的参数（通常是一个字符串）。

```go
// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
    z := x/3   // Arbitrary initial value
    for i := 0; i < 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // A million iterations has not converged; something is wrong.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
```

用户设计的库函数应该避免使用 `panic`。当加载一个库时无法满足一些条件或无法安全初始化时，那么 `panic` 可能是合理的。

```go
var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}
```

>---
#### 8.2. Recover

当 `panic` 被调用时，它会立即停止执行当前函数，同时展开当前 *goroutine* 调用堆栈，并运行当前函数的任何延迟函数。如果 *panicking* 序列到达了 *goroutine* 堆栈顶部，程序就会终止。但是，可以使用函数 `recover` 捕获 *panicking* 并恢复 *panicking goroutine* 的控制。对 `recover` 的调用会停堆栈展开并返回传递给 `panic` 的参数。在堆栈展开时可运行的唯一代码是在延迟函数中，所以 `recover` 只在延迟函数中有用。

在下面例子中，如果 `do(work)` 出现异常，结果将被记录，*goroutine* 将干净地退出，而不会干扰其他程序。在延迟闭包中不需要做任何其他事情；调用 `recover` 可以完全处理这种情况。
```go
func server(workChan <-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
```

未捕获异常的 `recover` 总是返回 `nil`。可以用这类操作简化复杂软件中的错误处理，例如一个理想化的 `regexp` 包，它通过使用本地 `Error` 类型调用 `panic` 来报告解析错误。下面是 `Error` 的定义、`error` 方法和 `Compile` 函数。

```go
// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}
```

>---
#### 8.3. 自定义 Error

可以在编码中通过实现 `error` 接口类型自定义实现错误处理程序。

```go
type errno struct {
	code    int
	message string
}

var (
	errFormat string = `
	Error code = %d
	Message >>>> %s
`
	GO_ERR_001 = errno{1, "TMP_GO_ERR_001"}
	GO_ERR_002 = errno{2, "TMP_GO_ERR_002"}
	GO_ERR_003 = errno{3, "TMP_GO_ERR_003"}
	GO_ERR_004 = errno{4, "TMP_GO_ERR_004"}
)
// 实现 error 接口
func (e errno) Error() string {   
	return fmt.Sprintf(errFormat, e.code, e.message)
}

func Test(b bool) (e error) {
	if !b {
		e = GO_ERR_001
	}
	return
}

func main() {
	err := Test(false)
	if err != nil {
		fmt.Print(err)
	}
/*
        Error code = 1
        Message >>>> TMP_GO_ERR_001
*/
}
```

---