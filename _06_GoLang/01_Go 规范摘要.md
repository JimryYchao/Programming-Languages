## Go 规范摘要

### 基本概念

#### 程序结构和词法元素

> **层次结构**

Go 程序是通过将包链接在一起来构建的，大写开头标记程序元素为外部链接。作用域层次结构分为 *universe*（全局） > *package*（包） > *file*（文件） > *function*（函数） > *block*（块）。

```go
package main       // 包声明
import "fmt"       // 包导入
 
// Send the sequence 2, 3, 4, … to channel 'ch'.
func generate(ch chan<- int) {
	for i := 2; ; i++ {
		ch <- i  // Send 'i' to channel 'ch'.
	}
}
// Copy the values from channel 'src' to channel 'dst',
// removing those divisible by 'prime'.
func filter(src <-chan int, dst chan<- int, prime int) {
	for i := range src {  // Loop over values received from 'src'.
		if i%prime != 0 {
			dst <- i  // Send 'i' to channel 'dst'.
		}
	}
}
// The prime sieve: Daisy-chain filter processes together.
func sieve() {
	ch := make(chan int)  // Create a new channel.
	go generate(ch)       // Start generate() as a subprocess.
	for {
		prime := <-ch
		fmt.Print(prime, "\n")
		ch1 := make(chan int)
		go filter(ch, ch1, prime)
		ch = ch1
	}
}
func main() {  // Main Entrypoint.
	sieve()
}
```

> **程序初始化**

包初始化 ➡ 变量初始化 ➡ 调用 `func init()` 函数 ➡ 执行 `main()`。全局变量按声明顺序和依赖关系依次进行初始化或零初始化：布尔为 `false`，数值为 `0`，字符串为 `""`，指针、函数、接口、 切片、通道和映射类型为 `nil`。

`init` 可以启动其他 *goroutine*，可以声明任意数量的 `init`。完整的 Go 程序通过将主包（`package main`，非导入包）与所有依赖包递归链接起来创建的。*main goroutine* 结束时，不会等待其他 *goroutine* 结束。

```go
// 首先初始化 V，其次按序调用 init，最后执行 main
var V int = Init(10)    

func main() { 
	println("Enter main")
}
func init() { fmt.Println("Enter init A") }
func init() { fmt.Println("Enter init B") }
func Init[T any](t T) (rt T) {
	rt = t
	fmt.Println("Init V = ", rt)
	return
}
/* 
	Init V = 10
	Enter init A
	Enter init B
	Enter main
*/
```

> **标准关键字**

```go
package     	// 包声明                                          
import      	// 依赖包导入                                          
const       	// 常量声明                                        
type        	// 类型定义或别名声明，TypeSwitch 中的类型推断 identifier.(type) 
var         	// 变量声明，支持类型推断                                        

chan        	// 通道声明                  
interface   	// 接口声明                                    
func        	// 函数声明                                    
map         	// 映射声明                                    
struct      	// 结构声明            

if-else         // if 条件语句                                   
switch-case     // switch 条件语句                               
fallthrough 	// switch 贯穿                  
select-case     // select 语句                                        
default     	// switch、select 的 default 分支        

for         	// for 迭代语句                                  
range       	// for 语句范围表达式                            
      	  
break       	// 跳出当前循环或分支                              
continue    	// 跳转至当前循环体末尾                            
return      	// 函数返回                                  
goto        	// 跳转标签   

defer       	// 延时函数调用                                    
go          	// 开启并发                      
```

> **预定义内置类型**

```go
any        		// 空接口 interface{} 别名，它代表所有（非接口）类型的集合 
bool       		// 布尔                                                    
true       		// 布尔值真                                                    
false      		// 布尔值假                                                    
iota       		// 特殊常量值，连续的无类型整数常量，只能用于常量赋值          
nil        		// 空值                                                        
byte       		// bytestring 的单个字节                                                    
comparable 		// 接口约束，严格可比较接口                                                  
error      		// 接口，包含一个 Error 函数                                                    
rune       		// UTF-8 Unicode 码位表示                         
int8       		// 8 位有符号整数                                              
int16      		// 16 位有符号整数                                             
int32      		// 32 位有符号整数                                             
int64      		// 64 位有符号整数                                             
uint8      		// 8 位无符号整数                                              
uint16     		// 16 位无符号整数                                             
uint32     		// 32 位无符号整数                                             
uint64     		// 64 位无符号整数                                             
int        		// 32 或 64 位有符号整数                                       
uint       		// 32 或 64 位无符号整数                                       
float32    		// 32 位浮点类型                                              
float64    		// 64 位浮点类型                                              
complex64  		// float32 复数                                          
complex128 		// float64 复数                                          
string     		// 字符串                                                  
uintptr    		// 足以存储指针值的无符号整数类型                              
```

> **预定义内置函数**

```go
func append(slice []Type, elems ...Type) []Type // slice 扩展
func cap(v Type) int                            // 获取 slice, array, *array, chan 容量
func len(v Type) int                            // 获取 slice, array, *array 元素个数, string 长度, chan 排队元素个数
func clear[T ~[]Type | ~map[Key]Value](t T)    // 清空 slice, map
func close(c chan<- Type)                       // 关闭 chan
func complex(r, i FloatType) ComplexType        // 构造复数类型
func copy(dst, src []Type) int                  // 复制 slice
func delete(m map[Type]Type1, key Type)         // 删除 map 元素
func imag(c ComplexType) FloatType              // 读取复数虚部
func real(c ComplexType) FloatType              // 读取复数实部
func make(t Type, size ...IntegerType) Type     // 构造 slice, map, chan
func max[T cmp.Ordered](x T, y ...T) T          // 一组 cmp.Ordered 中的最大值
func min[T cmp.Ordered](x T, y ...T) Tn         // 一组 cmp.Ordered 中的最小值
func new(Type) *Type                            // 返回类型零值指针
func panic(v any)                               // 异常抛出
func print(args ...Type)                        // 格式化输出到标准错误
func println(args ...Type)                      // 格式化输出行到标准错误
func recover() any                              // 恢复发生 panicking 例程的执行
```

> **运算符**

```go
+    -    *	   /    %	 ++   --
+= 	 -=   *=   /=   %=   =    :=
<    >    >=   <=   ==   !=
|    &    ^    &^	<<   >>   ~	   !	
|=   &=   ^=   &^=  <<=  >>=  ||   &&
[    ]    (    )    {    }
<-   ,    ;
```

>---
#### 字面值文本

> **整数文本**

```go
42, 4_2    					// 数字分隔符
0b1010, 0B_0101				// 二进制前缀: 0b,0B 
0600, 0_600, 0o600, 0O600   // 八进制前缀: 0,0o,0O
0xBadFace, 0xBad_Face,      // 十六进制前缀: 0x,0X
```

> **浮点文本**

浮点文本支持 *E* 或 *P* 指数表示法。

```go
// 十进制
0., 72.40, 072.40, 2.71828
1.e+0, 6.67428e-11, 1E6				// e, E 指数表示法
.25, .12345E+5, 1_5., 0.15e+0_2
// 十六进制: p, P 指数表示法 
0x1p-2       // == 0.25
0x2.p10      // == 2048.0
0x1.Fp+0     // == 1.9375
0X.8p-0      // == 0.5
0X_1FFFP-16  // == 0.1249847412109375
```

> **虚数文本**

仅以前导 0 开头的数字序列被视为十进制数字。

```go
0i, 0123i, 0.i, 6.67428e-11i, 0x1p-2i
0o123i        // == 0o123 * 1i == 83i
0xabci        // == 0xabc * 1i == 2748i
```

> **字符文本**

Go 使用 UTF-8 编码的 Unicode 字符，支持多字节。支持十六进制 `\x hh`、`\u hhhh`、`\U hhhhhhhh` 和八进制 `\ nnn`。

```go
'\'','a', 'ä', '本', '\t', 
'\xff', 
'\000', '\007', '\377', '\x07',   // 八进制
'\u12e4', 
'\U00101234'
```

> **转义字符**

```go
'\a'   // U+0007 响铃
'\b'   // U+0008 退格
'\f'   // U+000C 换页
'\n'   // U+000A 换行
'\r'   // U+000D 回车
'\t'   // U+0009 水平制表
'\v'   // U+000B 垂直制表
'\\'   // U+005C \
'\''   // U+0027 single quote  (valid escape only within rune literals)
'\"'   // U+0022 double quote  (valid escape only within string literals)
```

> **字符串文本**

字符串支持原始字符串和解释字符串。

```go
// 原始字符串
`abc`                // same as "abc"
`\n
\n`                  // same as "\\n\n\\n"
// 解释字符串
"\""                 // same as `"`
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
```

>---
#### 常量与变量

> **常量**

常量有布尔常量、数值常量（字符常量、整数常量、浮点常量、复数常量）和字符串常量。常量可以是类型化或非类型化的，默认类型是 `bool`、`rune`、`int`、`float64`、`complex128` 或 `string`。

```go
const Pi float64 = 3.14159265358979323846
const zero = 0.0         // untyped floating-point constant: float64
const (
	size int64 = 1024	 // typed
	eof        = -1      // untyped
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo"
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
```

Go 是静态强类型语言，不允许混合数值类型的操作。不同类型之间必须强制类型转换（例如 `int(3.1) + 1`）。

```go
type myString string      
const untypedStr = "World"           // const untyped string
const typedStr string = "World"      // const string

var s1 myString = typedStr           // error
var s2 myString = myString(typedStr) // 强制转换, string => myString
var s3 myString = untypedStr         // 隐式转换, untyped string => myString
```

> **iota**

标识符 `iota` 在一组 `const` 常量声明中可以表示从零开始的连续整数常量，可以借助 `iota` 构建枚举常量。

```go
const x = iota  // x == 0
const y = iota  // y == 0

const (
	a  = 1 << iota //  1 << 0 (iota = 0)
	a1 = 2         //  (iota == 1, unused)
	b  = 2 * iota  //  2 * 2  (iota = 2)
	b1             //  2 * 3  (iota = 3)
	b2             //  2 * 4  (iota = 4)
	b3             //  2 * 5  (iota = 5)
	c  = 1 + iota  //  1 + 6  (iota = 6)
	c1             //  1 + 7  (iota = 7)
	c2             //  1 + 8  (iota = 8)
)
```

> **变量**

变量保存值的存储位置和数据，值集由变量类型决定。块范围支持短变量声明：`idenList := exprList`。`_` 表示弃元。

```go
var (
	U, V, W int // 多变量声明
	i       int
	u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)

func Values() {
	i, j := 0, 10
	re, im := complexSqrt(-1)
	_, y, _ := coord(p) // 弃元
	// 短变量重声明 要求左侧至少有一个新声明非空变量
	i, k := 10, j
}
```

---
### 4. 类型

#### 4.1. 内置类型

| Type                               | Description             |
| :--------------------------------- | :---------------------- |
| `bool`                             | 布尔，`true` 和 `false` |
| `int8`,`int16`,`int32`,`int64`     | 有符号整数              |
| `uint8`,`uint16`,`uint32`,`uint64` | 无符号整数              |
| `float32`,`float64`                | 浮点数                  |
| `complex64`,`complex128`           | 复数                    |
| `uint`,`int`                       | 本机大小的整数          |
| `uintptr`                          | 指针整数                |
| `byte`,`rune`,`string`             | 字符与字符串            |


不同的数值类型之间需要显式转换。

```go
var x, y = 1, 1.0      // int,float64
sum := float64(x) + y  // 不同数值类型之间需要显式转换
```

字符串 `string` 不可变且不可寻址，索引字符串返回字节 `byte`，迭代字符串返回字符 `rune`。`+` 拼接字符串。

```go
var str string = "Hello 世界"
println(str[len(str)-1]) // last byte = 140
for _, r := range str {  // 遍历字符
	fmt.Print(string(r) + ",") // H,e,l,l,o, ,世,界,
}
str += " and good bye" // 拼接
```

>---
#### 4.3. Array

数组是单一类型元素的编号序列，始终是一维的，可以组合成多维数组。

```go
arr1 := [10]int{1, 2, 3}         // 指定长度
arr2 := [...]int{0, 2, 4, 8, 10} // 静态推断
// 多维数组
arr3 := [3][5]int{}              // [3]([5]int)
arr4 := [2][2][2]float64{}       // [2]([2]([2]float64))
```

>---
#### 4.4. Slice

切片是其底层数组某个连续段的编号序列，底层由指向数组的指针、长度及容量组成。切片可以由切片表达式生成，或由 `make` 构造。

```go
a := [100]int{}
s1 := a[10:50]   // 切片表达式，截取数组 10 到 49 元素

s2 := make([]T, len [, cap]?)
// 相当于
a := [cap]T{}
s2 := a[0:len]
```

切片表达式（`a[low : high <: max>?]`）从数组、数组指针、切片中构造切片，或由 `a[low : high]` 从字符串中构造子字符串。

```go
a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]   // 索引 1~3
a[2:]  // same as a[2 : len(a)]
a[:3]  // same as a[0 : 3]
a[:]   // same as a[0 : len(a)]

a := [100]int{}
s1 := a[20:50:100]   // len = 30, cap = 100-20 = 80
s2 := a[30:50:60]	 // len = 20, cap = 60-30 = 30 
s3 := a[30:50]	     // len = 20, cap = len(a)-30 = 70 

str := "Hello"[:3]   // "Hel"
```

切片始终是一维的，可以组合成多维切片，每层切片都需要单独初始化。

```go
type LinesOfText [][]byte     // A slice of byte slices.
text := LinesOfText{          // 每个内部切片可能具有不同的长度
    []byte("Now is the time"),
    []byte("for all good gophers"),
    []byte("to bring some fun to the party."),
}
```

>---
#### 4.5. Struct

结构包含一组字段成员，字段可以显式声明或是嵌入声明。`_` 可以充当填充字节。嵌入字段指定为类型 `T` 或非接口 `*T`。`T` 非限定类型名称充当字段名称。字段可以包含一个字符串标记作为属性，这些标记可由反射可见。

```go
// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4
struct {
	T1        // T1
	*T2       // T2
	P.T3      // T3
	*P.T4     // T4
	_    [4]byte // 填充
	x, y float64 "any string is permitted as a tag"  
	name string  `protobuf:"1"`  // key:value
}
```

嵌入字段 `S.T` 的成员或方法 `T.f` 将作为提升字段或提升方法，可由 `S.f` 或 `S.f()` 访问。若 `T` 实现了接口 `I`，则 `S` 也实现了 `I`。

```go
type Point2D struct {
	X, Y int
}
type Point3D struct {
	Point2D
	Z int
}

var Origin = Point3D{Point2D: Point2D{0, 0}, Z: 0}
var p = Origin
p.X += 1 	// 提升字段 X, 相当于 p.Point2D.X
```

给定结构类型 `S` 和命名类型 `T`，*提升方法* 包含在结构的方法集中：
- `S` 嵌入 `T`，则 `S` 和 `*S` 包含 `T` 的提升方法。`*S` 还包括 `*T` 的提升方法。
- `S` 嵌入 `*T`，则 `S` 和 `*S` 包含 `*T` 或 `T` 的提升方法。

```go
type I interface {
	Func()
}
type Embed struct{}
func (Embed) Func() {}   // Embed 实现 I
type S struct {          // S 实现 I
	Embed	
}
func main() {
	s := S{}
	s.Func()     // 提升方法
	I(s).Func()     
}
```

>---
#### 4.6. Function

函数声明的参数名称可省略。可变参数 `...` 位于参数列表的最后一个。省略函数体的函数声明表示外部方法，例如汇编例程。


```go
func Fun( <param-list>? ) <ret-list>? { statements }
func GeneFun( <param-list>? )[ TypeParam-List ] <ret-list>? { statements }   // 泛型

func foo()
func foo(x int)
func foo(a, _ int, z float32) bool
func foo[T ~int](a, b T) (bool)
func foo[T ~int | ~float64](x, y T) T
func foo(prefix string, values ...int)
func foo(a, b int, z float64, opt ...any) (success bool)    
func foo(int, int, float64) (float64, *[]int)
func foo() func(int,int)     // return type func(int,int)
```

函数类型声明可以表示具有相同方法签名的函数集合。

```go
type Add func(a int, b int) int
type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)   // 多值返回
func SumInt(x, y int) int {
	return x + y
}

var ac Action = SumInt
var sum = ac(1,1)  // use like a func
```

函数可以返回参数、局部变量或复合文本的地址：

```go
return &File{fd, name, nil, 0}
```

> **可变参数**

可变参函数 `func f(arg T1, p ...T)` 的可变参数 `p ...T` 等价于 `[]T`。可以传递 `slice...` 作为 `p` 实参。

```go
func Greeting(prefix string, who ...string)

Greeting("nobody")   // who = nil
Greeting("hello:", "Joe", "Anna", "Eileen")  // who = []string{"Joe", "Anna", "Eileen"}

s := []string{"James", "Jasmine"}
Greeting("goodbye:", s...)   // who = s
```

> **匿名函数**

匿名函数可以作为函数文本赋值给函数类型的变量。匿名函数不能声明类型参数。

```go
// 赋值变量
SumInt := func(x, y int) int { return x + y }
sum := SumInt(1, 1)
// 直接调用
sum = func(x, y int) int { return x + y }(1, 1)
```

匿名函数支持闭包原则，可以捕获局部变量并建立堆存储。

```go
func main() {
	done := make(chan bool)
	values := []string{"a", "b", "c"}
	for _, v := range values {
		go func() {
			fmt.Println(v)
			done <- true
		}()
	}

	// wait for all goroutines to complete
	for range values {
		<-done
	}
}
// before go1.22  output is c, c, c
// since go1.22   output is a, b, c
```

> **成员方法**

方法声明绑定到以 `T` 或 `T*` 为接收器的方法集。如果接收器是泛型类型，则必须声明相应的类型参数。`T` 的方法集由以接收器 `T` 声明的方法组成。`*T` 的方法集由以接收器 `*T` 或 `T` 声明的方法组成。接口方法集是接口类型集中每个类型方法集的交集。

```go
func (t T) Method(args) 	// receiver is T
func (pt *T) Method(args)	// receiver is *T
func (T) Method(args) 		// 省略名称
// 泛型
type Pair[U T1, V T2] struct {  }
func (p Pair[U, V]) Swap() Pair[V, U]  { ... }  
func (p Pair[First, _]) First() First  { ... }  
```

>---
#### 4.7. Interface

接口定义类型集和方法集协议。任何实现接口的类型都可以赋值给接口对象。接口元素可以是方法、嵌入接口或类型约束。

> **基接口**

基接口完全由方法列表组成定义，类型集为 `interface{}`。空接口 `type any = interface{}` 是 Go 统一类型系统的最终基。

```go
type File interface {
	Read([]byte) (int, error)
	Write([]byte) (int, error)
	Close() error
}
// 类型 T 实现接口 File
func (p T) Read(p []byte) (n int, err error) { ... }
func (p T) Write(p []byte) (n int, err error) { ... }
func (p T) Close() error { ... }
```

> **嵌入接口**

接口 `T` 的类型集是所有实现 `T` 和 `E` 所有方法并满足约束的类型集合。类型约束是 `T` 和 `E` 的约束交集。
  
```go
type Reader interface {
	Read(p []byte) (n int, err error)
	Close() error
}

type Writer interface {
	Write(p []byte) (n int, err error)
	Close() error
}

// ReadWriter's methods are Read, Write, and Close.
type ReadWriter interface {
	Reader 
	Writer 
}
```

> **类型约束**

类型约束限定接口的类型集。类型约束项可以是任意类型 `T`、非接口类型底层类型 `~T`、类型项联合 `T1 | T2 | ...`。嵌入接口的类型元素是所有接口约束的交集。接口的类型集不包含接口类型。

```go
interface {		// int
	int        
}
interface {		// underlying type int
	~int	  
}
interface {		// ~int that implement the String
	~int	   
	String() string
}
interface {     // empty type set
	int			
	string
}
interface {		// all floating-point types
	~float32 | ~float64
}
```

联合约束集项之间不存在交集，不能是 `comparable` 约束的接口。`comparable` 是所有可比较类型（布尔、数值、字符串、指针、通道、`comparable` 数组、`comparable` 结构）实现的接口，只能用作类型约束。

```go
type IComparable interface{
	comparable
}
```

> **接口实现**

如果 `T` 实现了接口 `I` 的所有方法列表并满足类型约束，则 `T` 实现了接口 `I`。

```go
type ISample interface {
	~int | ~float32 | ~float64
	Foo()
}
type MInt int
func (MInt) Foo() { ... }    // MInt 实现了 ISample[int]
type MFloat float32
func (MFloat) Foo() { ... }  // MFloat 实现了 ISample[float32]

func Foo[I ISample](i I) {
	i.Foo()
}
func main() {
	Foo[MInt](10)
	Foo[MFloat](3.1415)
}
```

>---
#### 4.8. Map

映射是一种由键值对组成的无序组。键可以是任何 `comparable` 类型，元素可以是任何类型。映射、切片、函数不能用作键类型，没有定义 `==` 运算。使用初始化器或 `make(map [,cap])` 构造一个映射。

映射初始容量不受 `cap` 限制，长度会随着存储新的键值对而增长。使用 `delete(map, key)` 删除键值对或 `clear(map)` 清空映射。

```go
// 映射复合文本初始化
var timeZone = map[string]int{    
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}

var m = make(map[string]int)   // 相当于 var m = map[string]bool{}
// 添加元素
m["A"] = 65
m["B"] = 66
m["C"] = 67
m["D"] = 68
// 删除或清空
delete(m, "A")
clear(m)
```

读取不存在的键返回零值。多重赋值检查映射是否包含该键。

```go
if value, ok := m[key]; ok{
	 // read successful
	 // and use rt ... 
}
```

> **并发中的映射**

并发中使用映射并不安全。可以对映射的访问执行同步，例如使用 `sync.RWMutex`。

```go
var counter = struct{
    sync.RWMutex
    m map[string]int
}{m: make(map[string]int)}

// 读取 counter，使用读锁：
counter.RLock()
n := counter.m["key"]
counter.RUnlock()

// 写入 counter，使用写锁：
counter.Lock()
counter.m["key"] = value
counter.Unlock()
```

>---
#### 4.9. Channel

通道用于在并发中进行数据通信，可选 `<-` 指定通道方向（仅发送 `<-chan`、仅接收 `chan<-`、双通道 `chan`），默认为双向通道。通道充当先进先出队列，接收操作按发送队列的逆序进行接收。

使用 `make(chan [, cap])` 构造通道，`cap` 不为 0 时表示为缓冲通道。无缓冲通道只有在发送方和接收方都准备就绪时，通信才会成功。缓冲通道未满之前不会阻塞。

```go
ch := make(chan int, 100)  
// send data
ch <- 1
// receive data
rt := <- ch
```

使用 `close` 关闭发送通道。*接收运算符* 的多值分配报告是否在通道关闭之前发送了数据。

```go
if _, ok := <-ch; ok {
	close(ch)
} 
```

>---
#### 4.11. Pointer

指针指向给定类型变量的内存地址，函数 `new` 返回指向给定类型零初始化后的对象指针。

```go
var p *Point = &Point{0, 0}
var pa *[4]int    // nil

pm := new(map[int]bool)   // *pm = nil
p := new(Point2D)         // *Point2D
p.X = 10                  // (*p).X = 10

var pa = new([10]int)
pa[0] = 10                // (*p)[0] = 10
print(unsafe.Sizeof(*pa)) // 80
```

`&` 地址运算符用于获取变量的地址，无法从函数绑定名称或匿名函数直接取址。

```go
type Func func()
func f() {}
func F(*Func) {}

F(&f)  // illegal
var p Func = f
F(&p)  // ok, 函数类型变量
```

>---
#### 4.10. 复合文本

复合文本的核心类型 `T` 必须是 `struct`、`array`、`slice` 或 `map` 类型（或该类型的命名类型）。复合文本成员的值按字段声明顺序全部列出；或以 *field : value* 对可选列出，缺失项零初始化。

```go
type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }
// 结构复合文本
origin := Point3D{}                            // zero value for Point3D
line := Line{origin, Point3D{y: -4, z: 12.3}}  // zero value for line.q.x
line2 := Line{p:origin}                        // zero value for line.q

// 数组、切片和映射文本
var arr = [5]int{0, 1: 0, 3: 3, 4}   // arr[2] == 0
days := [...]string{"Sat", "Sun"}    // 静态推断，len(days) == 2
s := []T{x1, x2, … xn}
var m = map[string]int{
	"a": 1,
	"b": 2,
	"c": 3,
	...
}

// 可以省略部分类型名称
[...]Point{{1.5, -3.5}, {0, 0}}     // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}          // same as [][]int{[]int{1, 2, 3}, []int{4, 5}}
[][]Point{{{0, 1}, {1, 2}}}         // same as [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}
map[string]Point{"orig": {0, 0}}    // same as map[string]Point{"orig": Point{0, 0}}
map[Point]string{{0, 0}: "orig"}    // same as map[Point]string{Point{0, 0}: "orig"}

type PPoint *Point
[2]*Point{{1.5, -3.5}, {}}          // same as [2]*Point{&Point{1.5, -3.5}, &Point{}}
[2]PPoint{{1.5, -3.5}, {}}          // same as [2]PPoint{PPoint(&Point{1.5, -3.5}), PPoint(&Point{})}
```

>---
#### 4.12. 命名类型

命名类型包括 *别名声明* 和 *类型定义*。类型别名与原类型等价，具有与原类型相同的方法集；类型定义定义新类型，它们的底层类型相同。

```go
type byte = uint8			// byte 是 uint8 的别名
type myString string		// myString 是新类型定义

var myStr myString = "Hello"
var b byte = myStr[0]

fmt.Printf("myStr is %T\n", myStr)		// myStr is main.myString
fmt.Printf("b is %T\n", b)				// b is uint8

type List[T any] struct {   // 定义泛型结构
	next  *List[T]
	value T
}

type IBlock interface {     // 定义接口类型
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}
```

>---
#### 4.13. 类型和值的属性

> **底层类型**

每个类型 `T` 都有一个底层类型：如果是布尔类型、数值类型或字符串类型、或是类型模板，`T` 的底层类型是其本身；否则 `T` 的底层类型是其声明中引用的底层类型。

```go
type (
	A1 = string     // string
	A2 = A1		    // string
	A3 []A1         // []A1
	A4 A3 			// []A1
)
func f[P any](x P) { … }     // P, interface{}
```

> **核心类型**

每个非接口类型 `T` 都有一个核心类型，该类型与底层类型 `T` 相同。核心类型不是命名类型、类型参数或接口类型。具有核心类型的接口示例：

```go
type Celsius float32
type Kelvin  float32
type myString string

interface{ int }                          // int
interface{ Celsius | Kelvin }             // float32
interface{ ~chan int }                    // chan int
interface{ ~chan int | ~chan<- int }      // chan<- int
interface{ ~[]*data; String() string }    // []*data
interface{ []byte | string }              // bytestring
interface{ ~[]byte | myString }           // bytestring

// 不带核心类型的接口示例：
interface{}                               // no single underlying type
interface{ Celsius | float64 }            // no single underlying type
interface{ chan int | chan<- string }     // channels have different element types
interface{ <-chan int | chan<- int }      // directional channels have different directions
```

>---
#### 4.14. 泛型声明

通过指定类型参数列表及其约束声明，构造泛型类型或泛型方法。

```go
// 泛型类型
type T[P *C] …
type T[P (C)] …
type T[P *C|Q] …
// 泛型方法
func foo[U T1 | T2](args)  
func foo[U T1, V T2 | ~string](args)  
```

泛型约束是定义所有允许的类型参数集的接口类型。形式为 `P E` 的泛型约束，实际上是 `P interface{E}`。

```go
[T []P]                      // 相当于 [T interface{[]P}]
[T ~int]                     // 相当于 [T interface{~int}]
[T int|string]               // 相当于 [T interface{int|string}]
```

类型参数可以显式提供，或根据上下文推断。泛型类型必须始终显式提供。

```go
// sum returns the sum (concatenation, for strings) of its arguments.
func sum[T ~int | ~float64 | ~string](x... T) T { … }

intSum := sum[int]             // intSum has type func(x... int) int
a := intSum(2, 3)              // a has value 5 of type int
b := sum[float64](2.0, 3)      // b has value 5.0 of type float64
c := sum(b, -1)                // c has value 4.0 of type float64

type sumFunc func(x... string) string
var f sumFunc = sum            // same as var f sumFunc = sum[string]
```


---
### 5. 表达式与运算符

> **运算符与优先级**

| **Category** | **Operators** |
| ------------ | ------------- |
|基本表达式| `x.y` `x->y` `f(x)` `a[x]` `<-ch`|
|一元| `+x` `-x` `!x` `^x` `T(v)` `&x` `*x`  |
|移位| `x << y` `x >> y`|
|乘法| `x * y` `x / y` `x % y`|
|加法| `x + y` `x - y`|
|关系与相等| `x < y` `x > y` `x <= y` `x >= y` `x == y` `x != y`|
|位清除 | `x &^ y`|
|按位 AND | `x & y`|
|按位 XOR|`x ^ y` |
|按位 OR| `x \| y` |
逻辑 AND | `x && y` |
逻辑 OR | `x \|\| y` |
|赋值| `x = y` `x += y` `x -= y` `x \|= y` `x ^= y` `x *= y` `x /= y` `x %= y` `x <<= y` `x >>= y` `x &= y` `x &^= y`|

整数商 `q = x / y` 和余数 `r = x % y` 满足关系 `x = q*y + r` 和 `|r| < |y|`。其中 `x / y` 向零截断（“截断除法”）：

```go
 x     y     x / y     x % y
 5     3       1         2
-5     3      -1        -2
 5    -3      -1         2
-5    -3       1        -2
```

关系运算符 `<`、`<=`、`>`、`>=` 适用于有序类型的操作数。相等运算符 `==` 和 `!=` 适用于可比类型的操作数。切片、映射和函数类型的变量不可比较，但支持与 `nil` 进行比较。

```go
var b1 = 3 < 4       		  // true
var b2 = "Hello" > "World"    // true    

if slice != nil {	  	
	use(slice)
}
```

>---
#### 5.5. 选择表达式

选择表达式 `x.f` 访问 `x` 的成员或提升成员（字段和方法）。以下规则适用于选择器：
- 对于非指针或非接口类型 `T` 或 `*T` 的值 `x`，`x.f` 表示在 `T` 中最浅层次的字段或方法。
- 对于接口类型 `I` 的值 `x`，`x.f` 表示具有动态值 `x` 的实际方法 `f`。
- 对于指针形式 `(*x).f` 是表示字段（但不是方法）的有效选择表达式，`x.f` 是 `(*x).f` 的简写。

```go
// 给定类型
type T0 struct { x int }
func (*T0) M0() { ... }

type T1 struct { y int } 
func (T1) M1() { ... }

type T2 struct {
	z int
	T1
	*T0
}
func (*T2) M2() {... }
type Q *T2

// 给定对象
var t T2     // with t.T0 != nil
var p *T2    // with p != nil and (*p).T0 != nil
var q Q = p
// 有效调用
t.z          // t.z
t.y          // t.T1.y
t.x          // (*t.T0).x
p.z          // (*p).z
p.y          // (*p).T1.y
p.x          // (*(*p).T0).x
q.x          // (*(*q).T0).x        (*q).x is a valid field selector
p.M0()       // ((*p).T0).M0()      M0 expects *T0 receiver
p.M1()       // ((*p).T1).M1()      M1 expects T1 receiver
p.M2()       // p.M2()              M2 expects *T2 receiver
t.M2()       // (&t).M2()           M2 expects *T2 receiver, see section on Calls
// 无效调用
q.M0()       // (*q).M0 is valid but not a field selector, Q 是类型定义，非 *T2 别名
// 若 type Q = *T2, 则 q.M0() 成立
```

>---
#### 5.6. 方法表达式

如果方法 `M` 在类型 `T` 的方法集中，则方法表达式 `T.M` 可作为常规函数调用，方法接收器 `T` 扩增为 `T.M` 的第一个参数，其余参数不变。

假设一个结构体 `T`，它有两个方法：`(T).Mv` 和 `(*T).Mp`。

```go
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver
```

方法表达式 `T.Mv` 生成一个等效 `func(tv T, a int) int`，以下调用是等效的：

```go
var t T

t.Mv(7)
T.Mv(t, 7)
(T).Mv(t, 7)
f := T.Mv; f1(t, 7)
```

方法表达式 `(*T).Mp` 生成等效 `func(tp *T, f float32) float32`。对于值接收器方法 `T.Mv`，可以导出指针接收器的函数 `(*T).Mv`，`(*T).Mv` 生成 `func(tv *T, a int) int`。

```go
(&t).Mp(7.1)
(*T).Mp(&t, 7)
(*T).Mv(&t, 7)
f := (*T).Mp; f(&T{1}, 1)
``` 														

>---
#### 6.9. 类型断言

对于接口值 `x`（非类型参数）和类型 `T`：
- 如果 `T` 不是接口类型，则 `x.(T)` 断言 `x` 的动态类型与类型 `T` 相同；
- 如果 `T` 是接口类型，则 `x.(T)` 断言 `x` 的动态类型实现了接口 `T`。
- `i, ok := x.(T)` 检查类型断言是否成功：若断言成立，则 `i` 的值是存储在 `x` 中的值，类型为 `T`；否则为 `T` 零值。

```go
var x interface{} = 7          // x has dynamic type int and value 7
i := x.(int)                   // i has type int and value 7

type I interface { m() }
func f(y I) {
	// s := y.(string)        // illegal: string does not implement I (missing method m)
	r := y.(io.Reader)        // r has type io.Reader and the dynamic type of y must implement both I and io.Reader
	if rt, ok := y.(IFace); ok {  // if ok == true, rt has dynamic type which implements IFace
		use(rt)
	}
}
```

>---
#### 5.7. 类型转换

类型转换 `T(expr)` 将表达式 `expr` 的类型更改为指定类型 `T`。

```go
*Point(p)        // same as *(Point(p))
(*Point)(p)      // p is converted to *Point
<-chan int(c)    // same as <-(chan int(c))
(<-chan int)(c)  // c is converted to <-chan int
func()(x)        // function signature func() x
(func())(x)      // x is converted to func()
(func() int)(x)  // x is converted to func() int
func() int(x)    // x is converted to func() int (unambiguous)
string([]byte{'a'})  // []byte{'h','e','l'} is converted to string
```

在以下任何情况下，非常量值 `x` 都可以转换为类型 `T`：
- `x` 可分配给 `T`。
- 忽略结构标记，`x` 和 `T` 不是类型参数，但具有相同的底层类型。
- `x` 和 `T` 都是整数或浮点类型。
- `x` 和 `T` 都是复数类型。
- `x` 是一个整数、字节切片、或字符切片，`T` 是一个字符串类型。
- `x` 是一个字符串，`T` 是 `[]byte` 或 `[]rune`。
- `x` 是一个切片，`T` 是切片元素类型的数组或数组指针。
- 没有语言机制可以在指针和整数之间进行转换。包 *`unsafe`* 在受限环境下实现此功能。

当为了转换的目的而比较结构类型的标识时，忽略结构标记：

```go
type Person struct {
	Name    string
	Address *struct {
		Street string
		City   string
	}
}
var data *struct {
	Name    string `json:"name"`
	Address *struct {
		Street string `json:"street"`
		City   string `json:"city"`
	} `json:"address"`
}
var person = (*Person)(data)  // ignoring tags, the underlying types are identical
```

---
### 6. 语句

#### 6.1. 递增递减语句：++, -- 


```go
IncDec statement    Assignment
----------------------------------
x++                 x += 1
x--                 x -= 1
```

>---
#### 6.2. 条件跳转语句：If, Switch

> **if-else**

```go
if [ SimpleStmt; ]? Condition { 
	statements 
} [ else if | else { statements } ]?
```
```go
if x > max {
	x = max
} else {
	x = 0
}

if x := f(); x < y {    // SimpleStmt
	return x
} else if x > z {
	return z
}
```

> **ExprSwitch**

```go
switch [ SimpleStmt; ]? ExprSwitchGuard? {  
	case state [, state...]?:   // nil 不能作为 case 的检查条件
		statements 
		[fallthrough]?          // 贯穿
	[case-clause]?
	[default block]?
} 
```
```go
switch tag {
	case 0, 1, 2, 3: 
		s1()
	case 4, 5, 6, 7: 
		s2()
		fallthrough	
	default: s3()
}

switch x := f(); { 
	case x < 0: return -x
	default: return x
}

switch {
	case x < y: f1()
	case x < z: f2()
	case x == 4: f3()
}
```

> **TypeSwitch**

```go
switch [ SimpleStmt; ]? TypeSwitchGuard.(type) {   // TypeSwitchGuard 必须是接口类型
	case TypeList | default :  // 每个分支的 Type 必须实现 TypeSwitchGuard 或是 nil
		 StatementList
}  
```
```go
switch i := x.(type) {
	case nil:
		printString("x is nil")                
	case int:
		printInt(i)                            
	case float64:
		printFloat64(i)                        
	case func(int) float64:
		printFunction(i)                       
	case bool, string:
		printString("type is bool or string")  
	default:
		printString("don't know the type")     
}
// 类型参数作为 Type
func f[P any](x any) int {
	switch x.(type) {
	case P: return 0
	case string: return 1
	case []P: return 2			
	case []byte: return 3
	default: return 4
	}
}

var v1 = f[string]("foo")   // v1 == 0
var v2 = f[byte]([]byte{})  // v2 == 2
```

>---
#### 6.3. 迭代语句：For

```go
for [ ConditionExpr | ForClause | RangeClause ]? {
	Block
} 
```

> **单条件控制**

```go
for ConditionExpr? { 
	Block
}
for {  // ConditionExpr = true
	Block
}
```

>  **ForClause**


```go
for [ InitStmt ]? ; [ Condition ]? ; [ PostStmt ]? {
	Block
} 

for i := 0; i < 10; i++ {
	foo(i)
}
```

> **RangeClause**

`for-range` 迭代数组、切片、映射键值对、字符串字符、通道上接收值、从零到指定上限的整数值。

```go
for [ IdentifierList ]? range RangeExpr  {
	Block
}

for [index, elem :=]? range array, slice,*parray
for [index, rune :=]? range string
for [key, value  :=]? range map
for [receive 	 :=]? range chan, <-chan  // until closed 
for [index 	     :=]? range integer   // 0 ~ integer-1
```
```go
for i, r := range "Hello, 世界" { 
	println(i, r)
}

for key, val := range map[string]int{"mon":0, "tue":1, "wed":2, "thu":3, "fri":4, "sat":5, "sun":6} {
	println(key, val)
}

var ch chan Work = producer()
for w := range ch {
	doWork(w)
}
for range ch {}	// empty a channel

for i := range 10 { // from 0 to 9
	do(i)  // call do(0), do(1), ... do(9)
}
```

>---
#### 6.4. 跳转语句：Goto, Continue, Break, Return

标签语句可以是 `goto`、`break` 或 `continue` 语句的目标。

```go
func foo(){
    // ...
Error:    // 标签
    log.Panic("error encountered")
    // ...
}
```

> **goto**

`goto` 跳转到同一函数体中声明的非内层块标签处。

```go
Block{
	// ...
	goto Error 
	// ...
Error: 
	statement?
}
```

> **break**

`break` 语句用于终止最内层或指定标签的外层 `for`、`switch` 或 `select` 语句的执行。

```go
break [ Label ]? 

OuterLoop:
	for i = 0; i < n; i++ {
	InterLoop:
		for j = 0; j < m; j++ {
			switch a[i][j] {
			case nil:
				state = Error
				break   // break switch
			case item:
				state = Found
				break OuterLoop  // break OuterLoop for
			}
		}
	}
```

> **continue**

`continue` 语句通过将控制推进最内层 `for` 迭代体的末尾来开始下一次迭代。或跳转至外层封闭的 `for` 语句的标签并开始下一次迭代。

```go
continue [ Label ]? 

RowLoop:
	for y, row := range rows {
		for x, data := range row {
			if data == endOfRow {
				continue RowLoop
			}
			row[x] = data + bias(x, y)
		}
	}
```

> **return**

`return` 语句终止函数执行，支持多值返回。任何 `defer` 延迟函数都会在函数返回前执行。

有三种方法可以从具有结果类型的函数返回值：
- 返回值在 “`return`” 语句中显式列出。

	```go
	func simpleF() int {
		return 2
	}
	func complexF1() (re float64, im float64) {
		return -7.0, -4.0
	}
	```

+ “`return`” 可以是对多值函数的单个调用。

	```go
	func complexF2() (re float64, im float64) {
		return complexF1()
	}
	```

- 函数提供了结果参数名称并在函数返回前赋值，则 `return` 可能为空。

	```go
	func complexF3() (re float64, im float64) {
		re = 7.0
		im = 4.0
		return
	}

	func (devnull) Write(p []byte) (n int, _ error) {
		n = len(p)
		return
	}
	```

>---
#### 6.5. 并发语句：Go

`go function` 开启一个独立并发线程或 *goroutine* 执行 `function` 调用，参数在调用方 *goroutine* 中计算，调用方例程不会等待并发是否调用完成。程序终止时，所有非 *main goroutine* 都会终止；任何返回值在并发例程完成时被丢弃。

```go
go Server()
go func(ch chan<- bool) { 
	for { 
		sleep(10)
		ch <- true 
	}
} (c)
```

>---
#### 6.6. 通道控制语句：Select

`select` 语句检查一组正在等待发送或接收的通道分支：
- 当某个通道未被阻塞时，`select` 执行该 `case chan` 或 `default`。多个通信进行时，则伪随机来选择。
- 未有通道进行时，选择 `default` 分支或阻塞 `select`，直到至少有一个通信可以继续。
- 仅有 `nil` 通道分支的 `select` 永远阻塞。

```go
select {
	[case ( SendStmt | RecvStmt )]* | default? : 
		StatementList
}
```
```go
var a []int
var c, c1, c2, c3, c4 chan int
var i1, i2 int
select {
	case i1 = <-c1:
		print("received ", i1, " from c1\n")
	case c2 <- i2:
		print("sent ", i2, " to c2\n")
	case i3, ok := (<-c3):  // same as: i3, ok := <-c3
		if ok {
			print("received ", i3, " from c3\n")
		} else {
			print("c3 is closed\n")
		}
	case a[f()] = <-c4:
		// same as
		// 	 case t := <-c4:
		//	 	a[f()] = t
	default:
		print("no communication\n")
}

for {  // send random sequence of bits to c
	select {
		case c <- 0:  // note: no statement, no fallthrough, no folding of cases
		case c <- 1:
	}
}

select {}  // block forever
```

>---
#### 6.7. 延迟语言：Defer

`defer` 语句挂起一个延迟函数，参数在挂起时计算。所有的延迟函数在当前函数返回前（设置任何结果参数之后）或 *panicking* 时按挂起逆序立即被调用。

```go
defer calling-function

func foo() {
	var l sync.Mutex
	l.Lock()
	defer l.Unlock() // unLock happens before surrounding function returns
	
	// prints 4 3 2 1 0 before surrounding function returns
	for i := 0; i < 5; i++ {
		defer fmt.Printf("%d ", i) // 4 3 2 1 0
	}
}

func(i, j int) {
	defer func(i, j int) {  
		println(i, j)
	}(i, j)   // i, j 参数在挂起时计算
	i++
	j++
}(1,2)   // print: 1 2
```

延迟函数可以通过闭包在返回结果参数之前访问或修改结果参数。

```go
func f() (result int) {
	defer func() {
		result *= 7   // f return 6*7
	}()
	return 6   // set result = 6
}
```

`defer` 常应用于解锁互斥锁或关闭文件流。

```go
// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
```

---
### 7. 内置函数

#### 7.1. append：切片扩展

```go
func append(slice []Type, elems ...Type) []Type 
func append(slice []byte, str ...byteString) []byte  // 字节切片拼接字符串
```

函数 `append` 在 `slice` 容量不足时自动扩容（一般为二倍扩容）。支持在两个重叠内存的切片之间操作。

```go
s0 := []int{0, 0}
s1 := append(s0, 2)                // []int{0, 0, 2}
s2 := append(s1, 3, 5, 7)          // []int{0, 0, 2, 3, 5, 7}
s3 := append(s2, s0...)            // []int{0, 0, 2, 3, 5, 7, 0, 0}
s4 := append(s3[3:6], s3[2:]...)   // []int{3, 5, 7, 2, 3, 5, 7, 0, 0}   允许重叠

var t []interface{}
t = append(t, 42, 3.1415, "foo")   //                             t is []interface{}{42, 3.1415, "foo"}

var b []byte
b = append(b, "bar"...)            // append string contents      b is []byte{'b', 'a', 'r' }
```

>---
#### 7.2. copy：切片复制

```go
func copy(dst, src []Type) int
func copy(dst []byte, src byteString) int   // 复制字符串到字节切片
```

函数 `copy` 将切片元素从源 `src` 复制到 `dst`，返回复制元素数。最多复制较短切片长度个数的元素。支持在两个重叠内存的切片之间操作。

```go
var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
var b = make([]byte, 5)
n1 := copy(s, a[0:])            // n1 == 6, s is []int{0, 1, 2, 3, 4, 5}
n2 := copy(s, s[2:])            // n2 == 4, s is []int{2, 3, 4, 5, 4, 5}
n3 := copy(b, "Hello, World!")  // n3 == 5, b is []byte("Hello")
```

>---
#### 7.3. clear：清零或删除元素

```go
func clear[T ~[]Type | ~map[Key]Value](t T)
```

函数 `clear` 清空切片或映射；`clear(nil)` 无任何操作。如果 `clear` 的参数类型是类型参数，则其类型集中的所有类型都必须是映射或切片。

>---
#### 7.4. close：关闭通道

```go
func close(c chan<- Type)
```

函数 `close` 关闭非 `nil` 通道 `c` 并停止通信。在已关闭的通道上发送或再次调用 `close` 将导致 *panicking*。在通道关闭之后，在接收任何先前已发送的通信之后，任何接收操作将返回通道类型的零值且不会阻塞。多值接收操作 `_, ok := <-ch` 可以检查通道是否关闭。

>---
#### 7.5. complex、real、imag：复数操作

```go
func complex(r, i FloatType) ComplexType
func real(c ComplexType) FloatType
func imag(c ComplexType) FloatType
```

函数 `complex` 构造一个复数值，`real` 和 `imag` 提取复数的实部和虚部。`float32` 对应 `complex64`，`float64` 对应 `complex128`。

```go
var a = complex(2, -2)             // complex128
const b = complex(1.0, -1.4)       // untyped complex constant 1 - 1.4i
x := float32(math.Cos(math.Pi/2))  
var c64 = complex(5, -x)           // complex64
var s int = complex(1, 0)          // untyped complex constant 1 + 0i can be converted to int
_ = complex(1, 2<<s)               // illegal: 2 assumes floating-point type, cannot shift
var rl = real(c64)                 // float32
var im = imag(a)                   // float64
const c = imag(b)                  // untyped constant -1.4
_ = imag(3 << s)                   // illegal: 3 assumes complex type, cannot shift
```

>--- 
#### 7.6. delete：删除映射元素

```go
func delete(m map[Key]Value, key Key)
```

函数 `delete` 从映射 `m` 中删除键 `key`。如果操作数 `m` 是类型参数，则该类型集中的所有类型都必须是映射，且它们必须具有相同的键类型。如果映射 `m` 是 `nil` 或 `key` 不存在，`delete` 无操作。

```go
var m = map[int]string{
	0: "zero",
	1: "one",
	2: "two",
	3: "three",
	4: "four",
}
delete(m, 0)
for _, v := range m {
	print(v + ",")  // maybe: one,two,three,four,
}
```

>---
#### 7.7. len、cap：长度与容量

```go
func len(v Type) int
func cap(v Type) int
```

函数 `len` 和 `cap` 接受数组、数组指针、切片、映射、字符串、通道类型的参数，并返回相应的长度或通道缓冲区大小。如果操作数是类型参数 `P`，则调用 `len` 或 `cap` 必须对 `P` 类型集中的所有类型有效。在任何时候，`0 <= len(s) <= cap(s)` 关系成立。`nil` 切片、映射或通道的长度为 0，`nil` 切片或通道的容量为 0。

```go
Call      Argument type      Result
  
len(s)    string type        string length in bytes
          [n]T, *[n]T        array length (== n)
          []T                slice length
          map[K]T            map length (number of defined keys)
          chan T             number of elements queued in channel buffer
  
cap(s)    [n]T, *[n]T        array length (== n)
          []T                slice capacity
          chan T             channel buffer capacity
```

>---
#### 7.8. new：分配

```go
func new(t Type) *Type
// 相当于
func new(t T) *T{
	var t Type
	return &t
}
```

函数 `new(T)` 为类型 `T` 分配零初始化值的存储空间并返回其地址，结果类型为 `*T`。切片、映射、接口类型零初始化为 `nil`。 
 
```go
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
```

>---
#### 7.9. make：分配

```go
func make(s Slice [, length uinteger] [, capacity uinteger]) Slice    // length <= capacity
func make(m Map [, capacity uinteger]) Map
func make(ch Chan [, bufsize uuinteger]) Chan
```

函数 `make` 接受类型切片、映射、通道并创建相应类型零初始化的值。

```go
s := make([]int, 10, 100)       // slice with len(s) = 10, cap(s) = 100
s := make([]int, 1e3)           // slice with len(s) = cap(s) = 1000
s := make([]int, 1<<63)         // illegal: len(s) is not representable by a value of type int
s := make([]int, 10, 0)         // illegal: len(s) > cap(s)
c := make(chan int, 10)         // channel with a buffer size of 10
m := make(map[string]int, 100)  // map with initial space for approximately 100 elements
```

以下说明了 `new` 和 `make` 之间的区别。

```go
var p *[]int = new([]int)       // allocates slice structure; *p = nil
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100, 100)
*p := &v
```

>---
#### 7.10. min、max：极值

```go
func min[T cmp.Ordered](x T, y ...T) T
func max[T cmp.Ordered](x T, y ...T) T
```

函数 `min` 和 `max` 分别计算有序参数列表中的最小值或最大值。如果所有参数都是常量，则结果也是常量。

```go
var x, y int
m := min(x)                 // m == x
m := min(x, y)              // m is the smaller of x and y
m := max(x, y, 10)          // m is the larger of x and y but at least 10
c := max(1, 2.0, 10)        // c == 10.0 (floating-point kind)
f := max(0, float32(x))     // type of f is float32
var s []string
_ = min(s...)               // invalid: slice arguments are not permitted
t := max("", "foo", "bar")  // t == "foo" (string kind)
```

对于浮点参数负零、NaN 和无穷大，以下规则适用：

```go
   x        y    min(x, y)    max(x, y)
------------------------------------------
  -0.0    0.0         -0.0          0.0   
  -Inf      y         -Inf            y   
  +Inf      y            y         +Inf   
   NaN      y          NaN          NaN   
```

>---
#### 7.11. panic、recover：异常处理

```go
func panic(v any)
func recover() any
```

函数 `panic` 和 `recover` 有助于报告和处理运行时异常和程序定义的错误条件。发生系统性异常或显式调用 `panic` 函数时， *panicking* 沿堆栈展开向上传递，直到终止程序运行或被 `recover` 捕获。程序终止时报告错误条件，并返回 `panic` 的参数值。

函数 `recover` 在 `defer` 延迟函数中执行异常处理。捕获一个 *panicking* 时，`recover` 返回调用 `panic` 传递的参数并停止 *panicking* 并恢复当前 *goroutine* 继续执行。未捕捉到 *panicking* 时返回 `nil`。

```go
func main() {
	protect(func() {
		var a, b int = 1, 0
		_ = a / b
	})
}
func protect(g func()) {
	defer func() {
		log.Println("done") 
		if x := recover(); x != nil {     // 异常处理
			log.Printf("run time panic: %v", x)
		}
	}()
	log.Println("start")
	g()
}
```

>---
#### 7.12. print、println：格式化输出

```go
func print(args ...Type)
func println(args ...Type)
```

函数 `print` 或 `println` 格式化参数并写入标准错误。函数 `println` 在参数之间插入空格，并附加尾换行符。

```go
m := map[int]int{1: 2, 3: 4, 5: 6}
s := []byte("Hello")
fmt.Println(1, 2, m, s) // 1 2 map[1:2 3:4 5:6] [72 101 108 108 111]
println(1, 2, m, s)     // 1 2 0xc000022180 [5/5]0xc00000a0d8
print(1, 2, m, s)       // 120xc000022180[5/5]0xc00000a0d8
```

---
### 8. Error 与 Run-time Panic

库例程必须经常向调用者返回某种错误指示。函数在返回结果值时可以同时返回某种详细的错误描述。例如，`os.Open` 在失败时不仅返回一个 `nil` 指针，它还返回一个描述错误的错误值。描述错误的接口类型为 `error`。

```go
type error interface {
	Error() string
}
```

预定义类型 `error` 表示错误条件的常规接口，返回 `nil` 值表示没有错误。例如可以定义一个从文件中读取数据的函数，在读取失败时返回 `0, err`：

```go
func Read(f* File, b []byte) (n int, err error)
```

在可行的情况下，错误字符串应该标识它们的来源，例如通过使用一个前缀来命名生成错误的操作或包。例如，在包 `image` 中，由于未知格式导致的解码错误的字符串表示是 “`image：unknown format`”。关心精确错误细节的调用方可以使用 *TypeSwitch* 或类型断言来查找特定错误并提取细节。

```go
for try := 0; try < 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
	// 类型断言
    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
```

执行错误（如试图将数组索引到边界之外）会触发一个运行时异常，相当于使用实现定义的接口类型 `runtime.Error` 的值调用函数 `panic`。该类型满足预先声明的接口类型 `error`。未指定表示不同运行时错误条件的确切错误值。

```go
package runtime

type Error interface{
	error
	// and perhaps other methods
}
```

函数通常在最后的返回值中返回错误信息。使用 `errors.New` 可返回一个错误信息：

```go
func Sqrt(f float64) (float64, error) {
    if f < 0 {
        return 0, errors.New("math: square root of negative number")
    }
    // ...
}
```

>---
#### 8.1. Panic

向调用方报告错误的常用方法是返回一个 `error` 作为额外的返回值。与之不同的是，调用函数 `panic` 会创建一个运行时错误，从而停止程序。该函数接受一个非 `nil` 任意类型的参数（通常是一个字符串）。

```go
// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
    z := x/3   // Arbitrary initial value
    for i := 0; i < 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // A million iterations has not converged; something is wrong.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
```

用户设计的库函数应该避免使用 `panic`。当加载一个库时无法满足一些条件或无法安全初始化时，那么 `panic` 可能是合理的。

```go
var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}
```

>---
#### 8.2. Recover

当 `panic` 被调用时，它会立即停止执行当前函数，同时展开当前 *goroutine* 调用堆栈，并运行当前函数的任何延迟函数。如果 *panicking* 序列到达了 *goroutine* 堆栈顶部，程序就会终止。但是，可以使用函数 `recover` 捕获 *panicking* 并恢复 *panicking goroutine* 的控制。对 `recover` 的调用会停堆栈展开并返回传递给 `panic` 的参数。在堆栈展开时可运行的唯一代码是在延迟函数中，所以 `recover` 只在延迟函数中有用。

在下面例子中，如果 `do(work)` 出现异常，结果将被记录，*goroutine* 将干净地退出，而不会干扰其他程序。在延迟闭包中不需要做任何其他事情；调用 `recover` 可以完全处理这种情况。
```go
func server(workChan <-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
```

未捕获异常的 `recover` 总是返回 `nil`。可以用这类操作简化复杂软件中的错误处理，例如一个理想化的 `regexp` 包，它通过使用本地 `Error` 类型调用 `panic` 来报告解析错误。下面是 `Error` 的定义、`error` 方法和 `Compile` 函数。

```go
// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}
```

>---
#### 8.3. 自定义 Error

可以在编码中通过实现 `error` 接口类型自定义实现错误处理程序。

```go
type errno struct {
	code    int
	message string
}

var (
	errFormat string = `
	Error code = %d
	Message >>>> %s
`
	GO_ERR_001 = errno{1, "TMP_GO_ERR_001"}
	GO_ERR_002 = errno{2, "TMP_GO_ERR_002"}
	GO_ERR_003 = errno{3, "TMP_GO_ERR_003"}
	GO_ERR_004 = errno{4, "TMP_GO_ERR_004"}
)
// 实现 error 接口
func (e errno) Error() string {   
	return fmt.Sprintf(errFormat, e.code, e.message)
}

func Test(b bool) (e error) {
	if !b {
		e = GO_ERR_001
	}
	return
}

func main() {
	err := Test(false)
	if err != nil {
		fmt.Print(err)
	}
/*
        Error code = 1
        Message >>>> TMP_GO_ERR_001
*/
}
```

---