## Go 规范摘要

---
### 1. Go 语言结构

Go 程序是通过将包链接在一起来构建的。
- `package` 包声明表示源文件所属包，一个包的所有源文件都位于同一个目录中。
- `import` 引入声明外部包，由包路径和可选的限定访问符组成。
- 大写开头标记程序元素为外部链接。

```go
package <myPackageName>		// 包声明

import . "fmt"				// 包导入声明
import   "lib/math"         // math.Sin  // 使用默认包名 math
import m "lib/math"         // m.Sin     // 限定为 m
import . "lib/math"         // Sin       // 全局引入
import _ "lib/math"			// 匿名导入，仅使用其包初始化副作用

func main() {		// main 入口函数
   Println("Hello, World!")
}

func Export(){}		// 函数，外部链接
int v				// 变量，内部链接

type S struct{		// 结构声明，外部链接
	Name int		// 结构成员，外部链接
	mess string		// 结构成员，内部链接
}
```

Go 声明将非空标识符绑定到常量、类型、类型参数、变量、函数、标签或包。空标识符（`_`）表示弃用，可以分配任意值。Go 的作用域层次结构分为 *universe*（全局） > *package*（包） > *file*（文件） > *function*（函数） > *block*（块）。

> *Go 示例：质数筛选*

```go
package main
import "fmt"

// Send the sequence 2, 3, 4, … to channel 'ch'.
func generate(ch chan<- int) {
	for i := 2; ; i++ {
		ch <- i  // Send 'i' to channel 'ch'.
	}
}
// Copy the values from channel 'src' to channel 'dst',
// removing those divisible by 'prime'.
func filter(src <-chan int, dst chan<- int, prime int) {
	for i := range src {  // Loop over values received from 'src'.
		if i%prime != 0 {
			dst <- i  // Send 'i' to channel 'dst'.
		}
	}
}
// The prime sieve: Daisy-chain filter processes together.
func sieve() {
	ch := make(chan int)  // Create a new channel.
	go generate(ch)       // Start generate() as a subprocess.
	for {
		prime := <-ch
		fmt.Print(prime, "\n")
		ch1 := make(chan int)
		go filter(ch, ch1, prime)
		ch = ch1
	}
}
func main() {
	sieve()
}
```

---
### 2. 程序初始化和执行

**程序初始化**：一个完整程序的包是逐步初始化的，首先初始化外部依赖包。每个包仅初始化一次，在单个 *goroutine* 中依次进行，每次一个包：包初始化 ➡ 变量初始化 ➡ 调用 `init` 函数。
- **零初始化**：无初始值设定的变量被零初始化：布尔类型为 `false`，数值类型为 `0`，字符串为 `""`，指针、函数、接口、 切片、通道和映射类型为 `nil`。
- **包初始化**：全局变量按声明顺序和依赖关系依次进行初始化。如果变量间存在其他隐藏的数据依赖关系，则未指定它们的顺序。


`init` 可以启动其他 *goroutine*，这些 *goroutine* 可以与初始化代码并发运行。初始化总是对 `init` 进行排序。每个源文件可以声明任意数目的初始化函数 `init`，按声明顺序调用，最后执行 `main` 包的入口函数 `main()`。

```go
// 首先初始化 V，其次按序调用 init，最后执行 main
var V int = Init(10)    

func main() {
	println("Enter main")
}
func init() { fmt.Println("Enter init A") }
func init() { fmt.Println("Enter init B") }
func Init[T any](t T) (rt T) {
	rt = t
	fmt.Println("Init >>> ", rt)
	return
}
/* 
	Init >>>  10
	Enter init A
	Enter init B
	Enter main
*/
```

一个完整的程序是通过将一个主包（`package main`，非导入包）与所有依赖包递归链接起来创建的。当 `main` 返回时程序退出，它不会等待其他非 *main goroutine* 完成。

```go
package main
import "fmt"
func main(){  // 程序入口
	fmt.Println("Hello World!")
}
```

---
### 3. 词汇元素

> **标准 Go 关键字**

```go
package     	// 包声明                                          
import      	// 依赖包导入                                          
const       	// 常量声明                                        
type        	// 类型定义或别名声明，TypeSwitch 中的类型推断 identifier.(type) 
var         	// 变量声明，支持类型推断                                        

chan        	// 通道类型声明                  
interface   	// 接口类型声明                                    
func        	// 函数声明关键字                                    
map         	// 映射类型声明                                    
struct      	// 结构体声明            

if          	// if 条件语句                                   
else        	// if 语句的否定分支                             
switch      	// switch 条件语句                               
select      	// 选择语句                                        
case        	// switch、select 语句的 case 分支           
default     	// switch、select 语句的 default 分支        
fallthrough 	// switch 语句直落语句                           

for         	// for 迭代语句                                  
range       	// for 语句范围表达式                            
      	  
break       	// 跳出当前循环或分支                              
continue    	// 跳转至当前循环体末尾                            
return      	// 函数返回语句                                    
goto        	// 无条件跳转语句   

defer       	// 延时函数调用                                    
go          	// 开启一个并发线程或 goroutine                      
```

> **预声明内置类型标识符**

```go
any        		// 空接口 interface{} 的别名，它代表所有（非接口）类型的集合 
bool       		// 布尔类型                                                    
byte       		// bytestring 的单个字节                                                    
comparable 		// 定义严格可比较接口                                                  
complex64  		// float32 复数类型                                          
complex128 		// float64 复数类型                                          
error      		// 接口，包含一个 Error 函数                                                    
float32    		// 32 位浮点类型                                              
float64    		// 64 位浮点类型                                              
int        		// 32 或 64 位有符号整数                                       
int8       		// 8 位有符号整数                                              
int16      		// 16 位有符号整数                                             
int32      		// 32 位有符号整数                                             
int64      		// 64 位有符号整数                                             
rune       		// UTF-8 编码的 Unicode 码位的数值表示                         
string     		// 字符串类型                                                  
uint       		// 32 或 64 位无符号整数                                       
uint8      		// 8 位无符号整数                                              
uint16     		// 16 位无符号整数                                             
uint32     		// 32 位无符号整数                                             
uint64     		// 64 位无符号整数                                             
uintptr    		// 足以存储指针值的无符号整数类型                              
true       		// 布尔值真                                                    
false      		// 布尔值假                                                    
iota       		// 特殊常量值，连续的无类型整数常量，只能用于常量赋值          
nil        		// 空值                                                        
```

> **预声明内置函数**

```go
append			// slice 扩展
cap				// 获取 slice, array, *array, chan 容量
len				// 获取 slice, array, *array 元素个数, string 长度, chan 排队元素个数
clear			// 清空 slice, map
close			// 关闭 chan
complex			// 构造复数类型
copy			// 复制 slice
delete			// 删除 map 元素
imag			// 读取复数虚部
real			// 读取复数实部
make			// 构造 slice, map, chan
max				// 一组 cmp.Ordered 中的最大值
min				// 一组 cmp.Ordered 中的最小值
new				// 返回类型零值指针
panic			// 异常抛出
print			// 格式化输出到标准错误
println			// 格式化输出行到标准错误
recover			// 恢复发生 panicking 例程的执行
```

> **运算符与标点符号**

```go
+    -    *	   /    %	 ++   --
+= 	 -=   *=   /=   %=   =    :=
<    >    >=   <=   ==   !=
|    &    ^    &^	<<   >>   ~	   !	
|=   &=   ^=   &^=  <<=  >>=  ||   &&
[    ]    (    )    {    }
<-   ,    ;
```

---
### 4. 字面值文本

> **整数文本**

```go
42, 4_2    					// 数字分隔符
0b1010, 0B_0101				// 二进制前缀: 0b,0B 
0600, 0_600, 0o600, 0O600   // 八进制前缀: 0,0o,0O
0xBadFace, 0xBad_Face,      // 十六进制前缀: 0x,0X
```

> **浮点文本**

浮点文本支持 *E* 或 *P* 指数表示法。

```go
// decimal
0., 72.40, 072.40, 2.71828
1.e+0, 6.67428e-11, 1E6				// e, E 指数表示法
.25, .12345E+5, 1_5., 0.15e+0_2
// hexadecimal: p, P 指数表示法 
0x1p-2       // == 0.25
0x2.p10      // == 2048.0
0x1.Fp+0     // == 1.9375
0X.8p-0      // == 0.5
0X_1FFFP-16  // == 0.1249847412109375
```

> **虚数文本**

仅以前导 0 开头的数字序列被视为十进制数字。

```go
0i, 0123i, 0.i, 6.67428e-11i, 0x1p-2i
0o123i        // == 0o123 * 1i == 83i
0xabci        // == 0xabc * 1i == 2748i
```

> **字符文本**

Go 使用 UTF-8 编码的 Unicode 字符，支持多字节。有四种方式表示：`\x hh`、`\u hhhh`、`\U hhhhhhhh`、`\ nnn`（*h* 表示十六进制数字，*n* 表示八进制数字）。

```go
'\'','a', 'ä', '本', '\t', 
'\xff', 
'\000', '\007', '\377', '\x07',
'\u12e4', 
'\U00101234'

// 转义字符
'\a'   // U+0007 响铃
'\b'   // U+0008 退格
'\f'   // U+000C 换页
'\n'   // U+000A 换行
'\r'   // U+000D 回车
'\t'   // U+0009 水平制表
'\v'   // U+000B 垂直制表
'\\'   // U+005C \
'\''   // U+0027 single quote  (valid escape only within rune literals)
'\"'   // U+0022 double quote  (valid escape only within string literals)
```
 
> **字符串文本**

字符串有两种形式：原始字符串（除反引号 `` ` ``）和解释字符串。

```go
// 原始字符串
`abc`                // same as "abc"
`\n
\n`                  // same as "\\n\n\\n"

// 解释字符串
"\""                 // same as `"`
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
```

---
### 5. 常量与变量

> **常量**

常量有布尔常量、数值常量（字符常量、整数常量、浮点常量、复数常量）和字符串常量，数值常量值可以是任意精度且不会溢出。没有常量可以表示 IEEE-754 负零、无穷大和 *NaN*。常量可以是类型化或非类型化的。非类型化常量的默认类型分别是 `bool`、`rune`、`int`、`float64`、`complex128` 或 `string`，可以隐式转换为表达式结果的目标类型。

```go
const Pi float64 = 3.14159265358979323846
const zero = 0.0         // untyped floating-point constant: float64
const (
	size int64 = 1024	 // typed
	eof        = -1      // untyped
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo"
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
```

Go 是静态类型语言，不允许混合数值类型的操作，数值类型之间不存在隐式转换。不同类型之间必须强制类型转换（例如 `int(f64) + i` 或 `f64 + float64(i)`）。

```go
type myString string
const untypedStr = "World"      // const untyped string
const typedStr string = "World" // const string

var s1 myString = typedStr           // error
var s2 myString = myString(typedStr) // 强制转换
var s3 myString = untypedStr         // 隐式转换
```

> **iota**

标识符 `iota` 在一组 `const` 常量声明中表示从零开始的连续整数常量，可以借助 `iota` 构建枚举常量。

```go
const x = iota  // x == 0
const y = iota  // y == 0

const (
	a  = 1 << iota //  1 << 0 (iota = 0)
	a1 = 2         //  (iota == 1, unused)
	b  = 2 * iota  //  2 * 2  (iota = 2)
	b1             //  2 * 3  (iota = 3)
	b2             //  2 * 4  (iota = 4)
	b3             //  2 * 5  (iota = 5)
	c  = 1 + iota  //  1 + 6  (iota = 6)
	c1             //  1 + 7  (iota = 7)
	c2             //  1 + 8  (iota = 8)
)
```

> **变量**

变量保存值的存储位置和数据，允许的值集由变量类型决定。
- 使用内置函数 `new` 或取址复合文本值会在运行时为变量分配堆存储。
- 数组、切片和结构具有可单独寻址的元素和字段。
- 接口在运行时可以具有不同的动态（非接口）类型。

```go
var x interface{}  // x is nil and has static type interface{}
var v *T           // v has value nil, static type *T
x = 42             // x has value 42 and dynamic type int
x = v              // x has value (*T)(nil) and dynamic type *T

// 多变量声明
var U, V, W int
var x, y float32 = -1, -2
var (
	i       int
	u, v, s = 2.0, 3.0, "bar"
	j = nil   // error
)
var re, im = complexSqrt(-1)
```

块范围可以使用短变量声明方式：`idenList := exprList`。*短变量重声明* 要求左侧至少有一个新声明非空变量。`_` 表示弃用。

```go
i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w, _ := os.Pipe()  // os.Pipe() returns a connected pair of Files and an error, if any
_, y, _ := coord(p)   // coord() returns three values; only interested in y coordinate

// 短变量重声明
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // redeclare offset, field2 is new
x, y, x := 1, 2, 3                        // illegal: x repeated on left side of :=
```

---
### 6. 类型

#### 6.1. 基本内置类型

布尔类型（`bool`）表示常量 `true` 和 `false` 表示的布尔值集。

```go
var f bool = false
t := true 
```

数值类型包含整数、浮点数、复数和字符类型。

```go
uint8, uint16, uint32, uint64  // unsigned integers    
int8, int16, int32, int64      // signed integers 
float32, float64      		   // IEEE754 floating-points
complex64, complex128		   // complex

uint        // either 32 or 64 bits
int         // same size as uint
uintptr     // an unsigned integer large enough to store the uninterpreted bits of a pointer value      

byte        // alias for uint8
rune        // alias for int32
```

不同的数值类型之间需要显式转换。

```go
var x, y = 1, 1.0      // int,float64
sum := float64(x) + y  // 不同数值类型之间需要显式转换
```

>---
#### 6.2. String

字符串类型（`string`）表示字符串值的集合，不可变且不可寻址，内置函数 `len` 获取字符串的长度。字符串字节（`byte`）可索引，字符串字节不代表单个字符。遍历字符使用字符类型（`rune`）。

```go
var str string = "Hello World"
var last byte = str[len(str)-1]    

// 遍历字符
for i,r := range str {
	// do ...
}
```

> **字符串拼接**

字符串可以使用 `+` 操作符或 `+=` 赋值操作符拼接创建一个新字符串。

```go
s := "hi" + string(c)
s += " and good bye"
```


>---
#### 6.3. Array

数组是单一类型元素的编号序列，具有值属性，元素可寻址，不可自包含。内置函数 `len` 来获取数组的长度。数组始终是一维的，可以组合成多维数组。

```go
var arr [10]int= [10]int{1,2,3}    // 指定长度
var arr2 = [...]int{0,2,4,8,10}    // 长度静态推断为 [5]int
// 多维数组
[3][5]int		  // [3]([5]int)
[2][2][2]float64  // [2]([2]([2]float64))
```

Go 数组若要类似 C 的行为或效率，可以传递一个指向数组的指针。

```go
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // Note the explicit address-of operator
```

>---
#### 6.4. Slice

切片是提供其底层数组某个连续段的描述符。切片由一个指向数组的指针、段的长度及切片容量组成，与底层数组共享内存空间。内置函数 `len` 获取切片的长度，切片长度可变。内置函数 `cap(s)` 来获取切片的容量。`nil` 切片的长度和容量为 0

```go
a := [100]int{}
s := a[10:50]   // 截取数组索引为 10 到 49 的元素
// cap(s) == len(a) - 10  >>> 90
```

内置函数 `make` 为类型 `T` 创建一个新的、长度为 `length` 和可选容量大小为 `capacity`、零值初始化的切片，并关联一个长度为 `capacity` 的底层隐藏数组。

```go
s := make([]T, length [, capacity]?)
// 相当于
a := [capacity]T{}
s := a[0:length]
```

切片通过指定一个半开放范围构造，表达式 `a[1:4]` 创建关联数组 `a` 索引 1~3 的切片。

```go
a := [...]byte{'g', 'o', 'l', 'a', 'n', 'g'}   // array
b := a[1:4]  // []byte{'o', 'l', 'a'}          //  sharing the same storage as a
```

函数对于切片的副作用对于调用方是可见的。切片按值传递给函数参数。

```go
func modifyBySlice(s []int) {
	for i, v := range s {
		s[i] = v * 2
	}
}

var arr = [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
modifyBySlice(arr[0:len(a)])  // 副作用
fmt.Println(arr)  // [0 2 4 6 8 10 12 14 16 18]
```



> **切片表达式**

切片表达式从数组、指向数组的指针、切片中构造切片，或从字符串中构造子字符串。

```go
a[low : high]        
a[low : high : max]  // 除字符串外

a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]
a[2:]  // same as a[2 : len(a)]
a[:3]  // same as a[0 : 3]
a[:]   // same as a[0 : len(a)]

a := [100]int{}
s1 := a[20:50:100]   // len = 30, cap = 100-20 = 80
s2 := a[30:50:60]	 // len = 20, cap = 60-30 = 30 
s3 := a[30:50]	     // len = 20, cap = len(a)-30 = 70 
```

> **切片复制**

内置函数 `copy` 将数据从源切片复制到目标切片，返回复制元素数。`copy` 支持在不同长度的切片之间进行复制（它只复制最多较短切片长度数目的元素）。`copy` 可以处理共享相同底层数组的源和目标切片，并正确处理重叠切片。

```go
t := make([]byte, len(s), (cap(s)+1)*2)
copy(t, s)
s = t

// 一个常见的操作是将数据附加到切片的末尾
func AppendByte(slice []byte, data ...byte) []byte {
    m := len(slice)
    n := m + len(data)
    if n > cap(slice) { // if necessary, reallocate
        // allocate double what's needed, for future growth.
        newSlice := make([]byte, (n+1)*2)
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:n]
    copy(slice[m:n], data)
    return slice
}

p := []byte{2, 3, 5}
p = AppendByte(p, 7, 11, 13)
// p == []byte{2, 3, 5, 7, 11, 13}
```

> **切片增长**

内置的 `append` 函数将元素 `x` 附加到切片 `s` 的末尾，并且如果需要更大的容量则增大切片（重新创建一个新的足够容纳切片元素的底层数组）。

```go
a := []string{"John", "Paul"}
b := []string{"George", "Ringo", "Pete"}
a = append(a, b...) // equivalent to "append(a, b[0], b[1], b[2])"
// a == []string{"John", "Paul", "George", "Ringo", "Pete"}
```

> **多维切片**

切片始终是一维的，可以组合成多维切片。对于数组的数组，内部数组在构造上始终是相同的长度；但对于切片的切片（或切片阵列），内部长度可能会动态变化。内部切片必须单独初始化。要创建二维数组或切片的等价物，需要定义一个数组的数组或切片的切片：

```go
type Transform [3][3]float64  // A 3x3 array, really an array of arrays.
type LinesOfText [][]byte     // A slice of byte slices.
```

因为切片是可变长度的，所以可以使每个内部切片具有不同的长度。

```go
text := LinesOfText{
    []byte("Now is the time"),
    []byte("for all good gophers"),
    []byte("to bring some fun to the party."),
}
```

有时需要分配一个二维切片，例如，在处理像素扫描线时可能会出现这种情况。有两种方法可以做到这一点。一种是独立地分配每个切片；另一种是分配一个数组并将各个切片指向其中：

- 一是 *一次一行*：

	```go
	// Allocate the top-level slice.
	picture := make([][]uint8, YSize) // One row per unit of y.
	// Loop over the rows, allocating the slice for each row.
	for i := range picture {
	    picture[i] = make([]uint8, XSize)
	}
	```

- 二是 *先分配再切成行*：

	```go
	// Allocate the top-level slice, the same as before.
	picture := make([][]uint8, YSize) // One row per unit of y.
	// Allocate one large slice to hold all the pixels.
	pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.
	// Loop over the rows, slicing each row from the front of the remaining pixels slice.
	for i := range picture {
	    picture[i], pixels = pixels[:XSize], pixels[XSize:]
	}
	```

>---
#### 6.5. Struct

结构包含一系列的命名元素字段，字段名称唯一，结构不能自包含。字段可以显式指定（*IdentifierList*）或嵌入指定（*EmbeddedField*）。`_` 充当填充字节。

```go
// An empty struct.
struct {}

// A struct with 6 fields.
struct {
	x, y int
	u float32
	_ float32  // padding
	A *[]int
	F func()
}
```

结构的 ***嵌入字段***（*EmbeddedField*）必须指定为类型 `T` 或指向非接口类型 `*T` 的指针，并且 `T` 其本身可能不是指针类型。`T` 的非限定类型名称充当字段名称。

```go
// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4
struct {
	T1        // field name is T1
	*T2       // field name is T2
	P.T3      // field name is T3
	*P.T4     // field name is T4
	x, y int  // field names are x and y
}

// 以下声明是非法的，因为字段名称在结构类型中必须是唯一的：
struct {
	T     // conflicts with embedded field *T and *P.T
	*T    // conflicts with embedded field T and *P.T
	*P.T  // conflicts with embedded field T and *T
}
```

如果 `x.f` 是表示该字段 `f` 或方法 `f` 的合法选择器（*selector*），则结构体 `x` 中嵌入字段的字段 `f` 或方法 `f` 被称为提升（*promoted*）。提升字段无法作为初始化结构时复合文本中的字段名称。相同的名称不能出现在相同的嵌套级别，更浅层次的名称将覆盖更深层次的相同名称成员。

```go
type Point2D struct {
	X, Y int
}
type Point3D struct {
	Point2D
	Z int
}

var Origin3D = Point3D{Point2D: Point2D{0, 0}, Z: 0}
var p = Origin3D
p.X += 1 // 提升字段 X, 等效于 p.Point2D.X
p.Y += 1 // 提升字段 Y
```

给定结构类型 `S` 和命名类型 `T`，*提升方法* 包含在结构的方法集中：
- 如果 `S` 包含嵌入字段 `T`，则 `S` 和 `*S` 的方法集都包含带有接收器 `T` 的提升方法。`*S` 的方法集还包括带有接收器 `*T` 的提升方法。
- 如果 `S` 包含嵌入字段 `*T`，则 `S` 和 `*S` 的方法集都包含带有接收器的 `*T` 或 `T` 的提升方法。

```go
type Embed struct{}
type Sample struct {
	Embed
}
func (Embed) Func() {}

func test() {
	s := Sample{}
	s.Func() // 提升方法
}
```

字段后面可以跟一个可选的字符串标记，作为属性。这些标记通过反射接口可见。

```go
struct {
	x, y float64 ""  // an empty tag string is like an absent tag
	name string  "any string is permitted as a tag"
	_    [4]byte "ceci n'est pas un champ de structure"
}

// A struct corresponding to a TimeStamp protocol buffer.
// The tag strings define the protocol buffer field numbers;
// they follow the convention outlined by the reflect package.
struct {
	microsec  uint64 `protobuf:"1"`  // key:value
	serverIP6 uint64 `protobuf:"2"`
}
```

>---
#### 6.6. Function

函数类型表示具有相同参数和结果类型的所有函数的集合。未初始化的函数值为 `nil`。

```go
type VoidFunc func()
type SumFunc func(a int, b int) int
type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)   // 多值返回

var split SplitFunc  // nil
```

函数声明在参数或结果列表中，标识符名称必须全部存在或全部不存在。可变参数 `...` 位于参数列表的最后一个。

```go
func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
```

与 C 家族的所有语言一样，Go 中的所有内容都是通过值传递的。也就是说，一个函数总是得到一个传递对象的副本。与 C 不同的是，Go 可以返回局部变量或按值传递的函数参数的地址；与变量相关的存储在函数返回后可以存在。可以对复合文本进行地址运算：

```go
return &File{fd, name, nil, 0}
```

> **函数声明**

函数声明将标识符（函数名）绑定到函数。如果函数的签名声明了结果参数，则函数体的语句列表必须以 *终止语句* 结束。

```go
func IndexRune(s string, r rune) int {
	for i, c := range s {
		if c == r {
			return i
		}
	}
	// invalid: missing return statement
}
```

如果函数声明指定了类型参数，则函数表示为泛型函数。

```go
type MInt int
func min[T ~int | ~float64](x, y T) T {
	if x < y {
		return x
	}
	return y
}
rt := min[MInt](10, 20)
```

没有类型参数的函数声明可以省略函数体，这样的声明为在 Go 之外实现的函数提供了签名，例如汇编例程。

```go
func flushICache(begin, end uintptr)  // implemented externally
```

> **可变参数**

可变参函数 `func f(arg T1, p ...T)` 包含可变参数 `p ...T`，`p` 的类型等价于类型 `[]T`。未传递可变参数实参时，`p` 值为 `nil`。

```go
func Greeting(prefix string, who ...string)
Greeting("nobody")   // who == nil
Greeting("hello:", "Joe", "Anna", "Eileen")  // who = []string{"Joe", "Anna", "Eileen"}
```

可变参数 `p ...T` 可以赋值 `[]T...`，它作为 `p` 的实参进行传递。在这种情况下，不会创建新切片。

```go
s := []string{"James", "Jasmine"}
Greeting("goodbye:", s...)   // who = s
```

> **函数文本**

函数文本可以表示匿名函数，或作为值赋值给变量或直接调用。函数文本不能声明类型参数。

```go
// 赋值变量
f := func(x, y int) int { return x + y }
rt = f(x, y)

// 直接调用
func(ch chan int) { ch <- ACK }(replyChan)   
```

函数闭包：它们可以引用其包围函数中定义的局部变量。

```go
func main() {
	done := make(chan bool)

	values := []string{"a", "b", "c"}
	for _, v := range values {
		go func() {
			fmt.Println(v)
			done <- true
		}()
	}

	// wait for all goroutines to complete before exiting
	for range values {
		<-done
	}
}
// before go1.22  output is c, c, c
// since go1.22   output is a, b, c
// 注：在 GO 1.22 之前，由于每次迭代在闭包中都使用一个变量 v 的同一实例，因此最终的输出可能是 `c, c, c`。
//     也就是说自 goroutine 启动时，闭包变量已经发生了改变。这种语言的行为被认为是一个错误，并且在
//     Go 1.22 中得到了解决，它为每次迭代创建了一个新变量，并消除了这个问题。
```

>---

#### 6.7. Interface

接口类型定义类型集。接口变量可以存储其关联类型集中任何类型的值，这样的类型被称为实现接口。未初始化的接口值为 `nil`。接口元素可以是方法、嵌入接口、类型约束（类型约束可以是一个或多个类型项的联合，类型项可以是单个类型，也可以是单个底层类型）。接口类型 `T` 不能直接或间接地嵌入、包含于、或是 `T` 的元素。

> **基接口**

基接口完全由方法列表（可以为空）组成定义，不包含嵌入接口和类型约束。此类接口定义的类型集是实现所有这些方法的类型集。

```go
// A simple File interface.
type File interface {
	Read([]byte) (int, error)
	Write([]byte) (int, error)
	Close() error
}
```

可以有多个类型实现一个接口。如果两个类型 `S1` 和 `S2` 包含了该方法集，`T` 可以代表为 `S1` 或 `S2`，`File` 接口由 `S1` 和 `S2` 同时实现：

```go
func (p T) Read(p []byte) (n int, err error)
func (p T) Write(p []byte) (n int, err error)
func (p T) Close() error
```

所有定义类型都实现了空接口 `interface {}`，它代表所有（非接口）类型的集合，预声明 `any` 是空接口的别名：

```go
interface {}   // 空接口
type any = interface{}
```

> **嵌入接口**

接口 `T` 可以使用接口 `E` （可能是限定的）作为嵌入的接口元素。`T` 的类型集是实现 `T` 及 `E` 所有方法的类型集合。嵌入接口时，具有相同名称的方法必须具有相同的签名。
  
```go
type Reader interface {
	Read(p []byte) (n int, err error)
	Close() error
}

type Writer interface {
	Write(p []byte) (n int, err error)
	Close() error
}

// ReadWriter's methods are Read, Write, and Close.
type ReadWriter interface {
	Reader  // includes methods of Reader in ReadWriter's method set
	Writer  // includes methods of Writer in ReadWriter's method set
}
```

> **泛型接口**

泛型接口元素可以是任意类型项 `T`、或是指定底层类型 `T` 的 `~T` 形式的项、或是类型项的联合 `t1 | t2 | … | tn`。
- 空接口的类型集是所有非接口类型的集合，等效于 `any`。
- 非空接口的类型集是其接口元素的类型集的交集。
- 方法规范的类型集是其方法集包含该方法的所有非接口类型的集合。
- 非接口类型项的类型集是仅由该类型组成的集合。
- 形式为 `~T` 项的类型集是底层类型为 `T` 的所有类型的集合。
- 项 `t1 | t2 | … | tn` 联合的类型集是项类型集的联合。

根据构造，接口的类型集从不包含接口类型。

```go
// An interface representing only the type int.
interface {
	int
}

// An interface representing all types with underlying type int.
interface {
	~int
}

// An interface representing all types with underlying type int that implement the String method.
interface {
	~int
	String() string
}

// An interface representing an empty type set: there is no type that is both an int and a string.
interface {
	int
	string
}
```

在形式的 `~T` 项中，底层 `T` 类型必须是自身，而 `T` 不能是接口。

```go
type MyInt int

interface {
	~[]byte  // the underlying type of []byte is itself
	~MyInt   // illegal: the underlying type of MyInt is not MyInt
	~error   // illegal: error is an interface
}
```

联合元素表示类型集的联合：

```go
// The Float interface represents all floating-point types
// (including any named types whose underlying types are
// either float32 or float64).
type Float interface {
	~float32 | ~float64
}
```

形式 `T` or `~T` 的项中的类型 `T` 不能是类型参数，并且所有非接口项的类型集必须两两不相交（类型集的两两相交必须为空）。给定一个类型参数 `P`：

```go
type I[P string] interface {
	P               // illegal: P is a type parameter
	int | ~P        // illegal: P is a type parameter
	~int | MyInt    // illegal: the type sets for ~int and MyInt are not disjoint (~int includes MyInt)
	float32 | Float // overlapping type sets but Float is an interface
}
```

联合类型约束列表中不能包含预声明的 `comparable` 或嵌入 `comparable` 的指定方法（或包含该特定方法的接口）。`comparable` 是一个由所有可比较类型（布尔值，数字，字符串，指针，通道，可比较类型的数组，字段都是可比较类型的结构）实现的接口。`comparable` 只能用作类型参数约束。

非基接口只能用作类型约束，或用作约束其他接口的元素。它们不能是值或变量的类型，也不能是其他非接口类型的组件。

```go
var x Float                     // illegal: Float is not a basic interface
var x interface{} = Float(nil)  // illegal

type Floatish struct {
	f Float                     // illegal
}
```

> 实现接口

如果满足以下条件，则类型 `T` 实现接口 `I`：
- `T` 不是接口，是 `I` 类型集合的一个元素；或
- `T` 是一个接口，`T` 的类型集是 `I` 类型集的一个子集。

如果 `T` 实现了接口或它的方法集中包含接口的方法，则类型 `T` 的值实现了接口。

```go
type (
	ISample interface {
		~int | ~float32 | ~float64
		Foo()
	}
	MInt int
)
func (MInt) Foo() { ... } // MInt 实现了泛型接口 ISample[int]

func Foo[I ISample](i I) {
	i.Foo()
}
func main() {
	Foo[MInt](10)
}
```

>---
#### 6.8. Map

Go 提供了一个内置类型 `map` 来实现哈希表。映射是一种由键值对组成的无序组，未初始化值为 `nil`。映射包含对底层数据结构的引用。映射的键可以是任何 `comparable` 类型，如布尔、整数、浮点数和复数、字符串、指针、接口（只要动态类型支持相等）、通道、结构和数组；元素类型可以是任何类型。

映射、切片、函数不能用作映射的键类型，因为没有在这些类型上实现定义 `==` 运算（只定义了与 `nil` 的相等运算）。

```go
var m map[string]int                 	// nil
var m2 map[*T]struct{ x, y float64 } 	// nil
var m3 map[string]interface{}    		// nil
```

`nil` 映射在读取时的行为类似于空映射，但无法添加任何元素，尝试写入 `nil` 映射将导致 *panicking*。使用内置函数 `make(map [,capacity])` 构造一个空的初始映射值，或使用复合文本构造映射。初始容量不受其大小限制：映射会随着存储项的数量而增长，但 `nil` 映射除外。使用内置函数 `len` 获取映射的长度，它可能在执行过程中更改。

```c
make(map[string]int)
make(map[string]int, 100)

var timeZone = map[string]int{
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
offset := timeZone["EST"]  // 读取映射
```

获取不存在键的值，映射返回零值。多重赋值可以检查映射是否包含该键。

```go
if rt, ok := timeZone[tz]; ok{
	 // read successful
	 // and use rt ... 
}
```

可以使用赋值在执行过程中添加元素；可以通过内置函数 `delete` 和 `clear` 删除映射元素。如果指定的键不存在，`delete` 不会做任何操作。

```go
var s_map map[string]bool = make(map[string]bool)
// 等效于 var s_map = map[string]bool{}

// 添加元素
s_map["a"] = true
s_map["b"] = true
s_map["c"] = true
s_map["d"] = true
s_map["e"] = true
s_map["f"] = true

// 删除或清空
delete(s_map, "a")
clear(s_map)
```

使用 `for ... range` 迭代映射：

```go
for key, value := range m {
    fmt.Println("Key:", key, "Value:", value)
}
```

> **并发中的映射**

并发中使用映射并不安全：它没有定义当多个例程同时读写它们时会发生什么。如果需要从并发执行的 *goroutine* 中读取和写入一个映射，那么访问必须通过某种同步机制来协调。保护映射的一种常见方法是使用 `sync.RWMutex`。

下面声明了一个 `counter` 变量，该变量是一个包含 `map` 和嵌入的 `sync.RWMutex` 的匿名结构。

```go
var counter = struct{
    sync.RWMutex
    m map[string]int
}{m: make(map[string]int)}
```

若要从 `counter` 读取，使用读锁：

```go
counter.RLock()
n := counter.m["some_key"]
counter.RUnlock()
fmt.Println("some_key:", n)
```

要写入 `counter`，使用写锁：

```go
counter.Lock()
counter.m["some_key"]++
counter.Unlock()
```

>---
#### 6.9. Channel

通道提供了一种机制，用于在并发中进行数据通信。未初始化值为 `nil`。可选 `<-` 运算符指定通道方向，通道被限制为仅发送（`<-chan`）、仅接收（`chan<-`）或双通道（`chan`）。通道充当先进先出队列。如果一个 *goroutine* 在通道上发送值，而另一个 *goroutine* 接收这些值，则将按发送顺序接收这些值。

```go
var ch  chan T          // can be used to send and receive values of type T
var ch1 chan<- float64  // can only be used to send float64s
var ch2 <-chan int      // can only be used to receive ints
```

`<-` 运算符尽可能与最左边的 `chan` 相关联：

```go
chan<- chan int    // same as chan<- (chan int)
chan<- <-chan int  // same as chan<- (<-chan int)
<-chan <-chan int  // same as <-chan (<-chan int)
chan (<-chan int)
```

使用内置函数 `make(chan [, capacity])` 构造通道。容量设置通道缓冲区的大小。容量为零表示为无缓冲通道，即仅当发送方和接收方都准备就绪时，通信才会成功。否则，如果缓冲区未满（发送）或未空（接收）时，通道将缓冲，并且通信成功而不会阻塞。 `nil` 通道永远无法进行通信。

```go
make(chan int, 100)
```

使用内置函数 `close` 关闭通道。*接收运算符* 的多值分配报告是否在通道关闭之前发送了接收值。

```go
if _, ok := <-ch; ok {
	close(ch)
} 
```

>---
#### 6.10. Pointer

指针类型表示指向给定类型变量的所有指针的集合，未初始化值为 `nil`。内置函数 `new` 返回指向给定类型零初始化后的对象的指针。

```go
var p *Point = &Point{0, 0}
var pa *[4]int    // nil

pm := new(map[int]bool)   // *pm = nil
p := new(Point2D)         // *Point2D
p.X = 10                  // (*p).X = 10

var pa = new([10]int)
pa[0] = 10                // (*p)[0] = 10
print(unsafe.Sizeof(*pa)) // 80
```

`&` 地址运算符用于获取变量的地址，不能直接从函数标识符或函数文本直接获取函数地址。

```go
type Func func()
func f() {}

func F(*Func) {}

F(&f)  // illegal

var p Func = f
F(&p)  // ok, 函数变量
```

可以直接获取堆栈变量和复合文本值的地址。

```go
type Point2D struct {
	X float64
	Y float64
}

func NewPoint2D() *Point2D {
	return &Point2D{}
	// or 
	p := Point2D{}
	return &p
}
```

---
### 7. 命名类型

类型声明将标识符（类型名称）绑定到类型。类型声明有两种形式：别名声明和类型定义。它们被称为命名类型。`type` 用以创建类型别名或声明类型定义。类型别名与原类型等价；类型定义则定义一种新类型，它们的底层类型相同。

```go
type byte = uint8			// byte 是 uint8 的别名
type myString string		// myString 是新类型定义

var myStr myString = "Hello"
var b byte = myStr[0]

fmt.Printf("myStr is %T\n", myStr)		// myStr is main.myString
fmt.Printf("b is %T\n", b)				// b is uint8
```

>---
#### 7.1. 别名声明

*别名声明* 将标识符绑定到给定类型。可以通过别名访问绑定类型的方法集。

```go
type (
	nodeList = []*Node  // nodeList and []*Node are identical types
	Polar    = polar    // Polar and polar denote identical types
)
```

>---
#### 7.2. 类型定义

*类型定义* 创建一个具有与给定类型相同的底层类型但操作不同的新类型，并将标识符（命名类型）绑定到该类型。新类型称为定义类型。它不同于任何其他类型，包括创建它的类型。

```go
type (
	Point struct{ x, y float64 }  // Point and struct{ x, y float64 } are different types
	polar Point                   // polar and Point denote different types
)

type TreeNode struct {
	left, right *TreeNode
	value any
}

type IBlock interface {
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}
```

定义的类型可以有与之关联的方法。它不继承任何绑定到给定类型的方法，但接口类型或复合类型的嵌入元素的方法集（提升）保持不变：

```go
// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock implementation */ }
func (m *Mutex) Unlock()  { /* Unlock implementation */ }

// NewMutex has the same composition as Mutex but its method set is empty.
type NewMutex Mutex

// The method set of PtrMutex's underlying type *Mutex remains unchanged,
// but the method set of PtrMutex is empty.
type PtrMutex *Mutex

// The method set of *PrintableMutex contains the methods
// Lock and Unlock bound to its embedded field Mutex.
type PrintableMutex struct {
	Mutex
}

// MyBlock is an interface type that has the same method set as Block.
type MyBlock Block
```

如果类型定义指定了类型参数，则命名类型表示泛型类型。泛型类型在使用时必须实例化。在类型定义中，给定的类型不能是类型参数。

```go
type List[T any] struct {
	next  *List[T]
	value T
}

type T[P any] P    // illegal: P is a type parameter

func f[T any]() {
	type L T   // illegal: T is a type parameter declared by the enclosing function
}
```

一个泛型类型也可以有与之关联的方法。在这种情况下，方法接收器必须声明与泛型类型定义中相同数量的类型参数。

```go
// The method Len returns the number of elements in the linked list l.
func (l *List[T]) Len() int  { … }
```

>---
### 8. 类型和值的属性

#### 8.1. 底层类型

每个类型 `T` 都有一个底层类型：如果是布尔类型、数值类型或字符串类型之一，或者是类型文本，则 `T` 相应的底层类型就是 `T` 其本身；否则 `T` 的底层类型是其声明中 `T` 引用类型的底层类型。对于类型参数，底层类型其类型约束（始终为接口）的底层类型。

```go
type (
	A1 = string
	A2 = A1
)

type (
	B1 string
	B2 B1
	B3 []B1
	B4 B3
)

func f[P any](x P) { … }
```

`string`、`A1`、`A2`、`B1`、`B2` 的底层类型均为 `string`，`[]B1`、`B3`、`B4` 的底层类型为 `[]B1`。`P` 的底层类型是 `interface {}`。

>---
#### 8.2. 核心类型

每个非接口类型 `T` 都有一个核心类型（*core type*），该类型与底层类型 `T` 相同。如果满足以下条件之一，则接口 `T` 具有核心类型：
- 有一个单一类型 `U`，它是 `T` 类型集合中所有类型的底层类型；或
- `T` 的类型集只包含具有相同元素类型 `E` 的通道类型，且所有具有方向的通道方向相同。

没有其他接口具有核心类型。根据满足的条件，接口的核心类型是：
- 类型 `U`；
- 如果 `T` 只包含双向通道，或者是取决于存在的定向通道的方向的类型 `chan<- E` 或 `<-chan E`，则核心类型是通道 `chan E`。

根据定义，核心类型从来都不是定义的类型、类型参数或接口类型。具有核心类型的接口示例：

```go
type Celsius float32
type Kelvin  float32

interface{ int }                          // int
interface{ Celsius|Kelvin }               // float32
interface{ ~chan int }                    // chan int
interface{ ~chan int|~chan<- int }        // chan<- int
interface{ ~[]*data; String() string }    // []*data
```

不带核心类型的接口示例：

```go
interface{}                               // no single underlying type
interface{ Celsius | float64 }            // no single underlying type
interface{ chan int | chan<- string }     // channels have different element types
interface{ <-chan int | chan<- int }      // directional channels have different directions
```

一些操作（例如切片表达式，切片拼接或复制）依赖于接受字节切片和字符串切片的稍微宽松的内核类型形式。具体来说，如果有恰好两种类型 `[]byte` 和 `string`，它们是接口 `T` 类型集中所有类型的底层类型，`T` 的核心类型称为 `bytestring`。

`bytestring` 不是一个真实的类型；它不能用于声明变量或组合其他类型的类型。它的存在只是为了描述从字节序列（可能是字节切片或字符串）读取的某些操作的行为。具有 `bytestring` 核心类型的接口示例：

```go
interface{ int }                          // int (same as ordinary core type)
interface{ []byte | string }              // bytestring
interface{ ~[]byte | myString }           // bytestring
```

>---

#### 8.3. 类型等价性

两种类型要么相同，要么不同。

命名类型始终不同于任何其他类型。否则，如果两个类型的底层类型文本在结构上等效，则它们相同；也就是说，它们具有相同的文本结构，相应的组件具有相同的类型。具体如下：
- 如果两种数组类型具有相同的元素类型和相同的数组长度，则它们相同。
- 如果两个切片类型具有相同的元素类型，则它们相同。
- 如果两个结构类型具有相同的字段序列，并且相应的字段具有相同的名称、相同的类型和相同的标记，则它们相同。来自不同包的非导出字段名称始终不同。
- 如果两个指针类型具有相同的基类型，则它们是相同的。
- 如果两个函数类型具有相同数量的参数和结果值，则它们相同，相应的参数和结果类型相同，并且两个函数都是可变的，或者都不是。参数和结果名称不需要匹配。
- 如果两个接口类型定义相同的类型集，则它们相同。
- 如果两种映射类型具有相同的键和元素类型，则它们相同。
- 如果两种通道类型具有相同的元素类型和相同的方向，则它们相同。
- 如果两个实例化类型的定义类型和所有类型参数相同，则它们相同。

```go
// 声明
type (
	A0 = []string
	A1 = A0
	A2 = struct{ a, b int }
	A3 = int
	A4 = func(A3, float64) *A0
	A5 = func(x int, _ float64) *[]string

	B0 A0
	B1 []string
	B2 struct{ a, b int }
	B3 struct{ a, c int }
	B4 func(int, float64) *B0
	B5 func(x int, y float64) *A1

	C0 = B0
	D0[P1, P2 any] struct{ x P1; y P2 }
	E0 = D0[int, string]
)

/* 其中以下类型是相同的
A0, A1, []string
A2, struct{ a, b int }
A3, int
A4, func(int, float64) *[]string, A5

B0, C0
D0[int, string], E0
func(x int, y float64) *[]string, func(int, float64) (result *[]string), A5
*/
```

`B0` 和 `B1` 是不同的，因为它们是由不同的类型定义创建的新类型；`func(int, float64) *B0` 和 `func(x int, y float64) *[]string` 不同，因为 `B0` 不同于 `[]string`；`P1` 和 `P2` 是不同的，因为它们是不同的类型参数。`D0[int, string]` 和 `struct{ x int; y string }` 是不同的，因为前者是实例化的已定义类型，而后者是类型文本（但它们仍然具有可分配性）。

>---

#### 8.4. 可赋值规则 

类型 `V` 的值 `x` 如果满足以下条件之一时，值 `x` 可分配给类型 `T` 的变量（“ `x` 可赋值给 `T` ”）：
- `V` 和 `T` 是相同的。
- `V` 和 `T` 具有相同的底层类型，但不是类型参数，并且 `V` 或 `T` 中至少有一个不是命名类型。
- `V` 和 `T` 是具有相同元素类型的通道类型，`V` 是双向通道，并且 `V` 或 `T` 中至少有一个不是命名类型。
- `T` 是接口类型，但不是类型参数，`x` 实现了 `T`。
- `x` 是预先声明的标识符 `nil`，`T` 是指针、函数、切片、映射、通道或接口类型，但不是类型参数。
- `x` 是一个无类型的常量，可以用类型 `T` 的值表示。

此外，如果 `x` 的类型 `V` 或 `T` 是类型参数，则如果以下条件之一适用，则 `x` 可分配给类型 `T` 的变量：
- `x` 是预先声明的标识符 `nil`，`T` 是类型参数，`x` 可分配给 `T` 的类型集中的每个类型。
- `V` 不是命名类型，`T` 是类型参数，`x` 可分配给 `T` 的类型集中的每个类型。
- `V` 是类型参数，`T` 不是命名类型，`V` 的类型集中的每个类型的值都可以分配给 `T`。

>---

#### 8.5. 值可表示性

如果以下条件之一适用。常量 `x` 可由类型 `T` 的值表示，其中 `T` 不是类型参数：
- `x` 在由 `T` 确定的值集合中。
- `T` 是浮点类型，`x` 可以舍入到 `T` 的精度而不会溢出。舍入使用 IEEE 754 舍入到偶数规则，但将 IEEE 负零进一步简化为无符号零。常量值永远不会导致 IEEE 负零、NaN 或无穷大。
- `T` 是一个复数类型，`x` 的组件 `real(x)` 和 `imag(x)` 可以由 `T` 的组件类型（`float32` 或 `float64`）的值表示。

如果 `T` 是一个类型参数，那么如果 `x` 可以由 `T` 的类型集中的每个类型的值表示，那么 `x` 可以由类型 `T` 的值表示。

```go
x                   T           // x is representable by a value of T because
------------------------------------------------------------------------------------------------------------------
'a'                 byte        // 97 is in the set of byte values
97                  rune        // rune is an alias for int32, and 97 is in the set of 32-bit integers
"foo"               string      // "foo" is in the set of string values
1024                int16       // 1024 is in the set of 16-bit integers
42.0                byte        // 42 is in the set of unsigned 8-bit integers
1e10                uint64      // 10000000000 is in the set of unsigned 64-bit integers
2.718281828459045   float32     // 2.718281828459045 rounds to 2.7182817 which is in the set of float32 values
-1e-1000            float64     // -1e-1000 rounds to IEEE -0.0 which is further simplified to 0.0
0i                  int         // 0 is an integer value
(42 + 0i)           float32     // 42.0 (with zero imaginary part) is in the set of float32 values
```
```go
x                   T           // x is not representable by a value of T because
------------------------------------------------------------------------------------------------------------------
0                   bool        // 0 is not in the set of boolean values
'a'                 string      // 'a' is a rune, it is not in the set of string values
1024                byte        // 1024 is not in the set of unsigned 8-bit integers
-1                  uint16      // -1 is not in the set of unsigned 16-bit integers
1.1                 int         // 1.1 is not an integer value
42i                 float32     // (0 + 42i) is not in the set of float32 values
1e1000              float64     // 1e1000 overflows to IEEE +Inf after rounding
```

---
### 9. 复合文本

复合文本的每次求值，都会构造一个新的复合值。每个元素前面可以有一个相应的键。复合文本的核心类型 `T` 必须是 `struct`、`array`、`slice` 或 `map` 类型（或该类型的命名类型）。元素和键的类型必须可分配给类型 `T` 的成员；没有额外的转换。

复合文本的字段按顺序列出，并且必须全部存在；或声明为 *field : value* 对列出，*field : value* 可以以任何顺序出现，缺失设定项的成员零初始化。对于不同类型的复合文本，*field* 解释为结构文本的字段名称、数组和切片文本的索引、映射文本的键。

```go
type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }
// 结构复合文本
origin := Point3D{}                            // zero value for Point3D
line := Line{origin, Point3D{y: -4, z: 12.3}}  // zero value for line.q.x
line2 := Line{p:origin}                        // zero value for line.q

// 数组、切片和映射文本
var arr = [5]int{0, 1: 0, 3: 3, 4}   // arr[2] == 0
s := []T{x1, x2, … xn}
var m = map[string]int{
	"a": 1,
	"b": 2,
	"c": 3,
	...
}
```

取址复合文本值会生成一个指针，并为该值创建堆存储。

```go
var pointer *Point3D = &Point3D{y: 1000}
```

切片或映射的零值与已初始化但为空的值不同。取址空切片或映射复合文本与使用 `new` 的效果不同。

```go
p1 := &[]int{}    // p1 points to an initialized, empty slice with value []int{} and length 0
p2 := new([]int)  // p2 points to an uninitialized slice with value nil and length 0
```

数组文本的长度是文本类型中指定的长度，缺失元素零初始化。`...` 自动推断数组的长度。

```go
buffer := [10]string{}             // len(buffer) == 10
intSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6
days := [...]string{"Sat", "Sun"}  // len(days) == 2
```

在数组、切片或映射类型 `T` 的复合文本中，若文本与 `T` 的元素或键类型相同，本身又是复合文本的元素或映射键时，可以省略相应的文本类型。类似地，当元素或键类型为 `*T` 时，作为复合文本地址的元素或键可以省略 `&T`。

```go
[...]Point{{1.5, -3.5}, {0, 0}}     // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}          // same as [][]int{[]int{1, 2, 3}, []int{4, 5}}
[][]Point{{{0, 1}, {1, 2}}}         // same as [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}
map[string]Point{"orig": {0, 0}}    // same as map[string]Point{"orig": Point{0, 0}}
map[Point]string{{0, 0}: "orig"}    // same as map[Point]string{Point{0, 0}: "orig"}

type PPoint *Point
[2]*Point{{1.5, -3.5}, {}}          // same as [2]*Point{&Point{1.5, -3.5}, &Point{}}
[2]PPoint{{1.5, -3.5}, {}}          // same as [2]PPoint{PPoint(&Point{1.5, -3.5}), PPoint(&Point{})}
```

---
### 10. 选择表达式

对于主表达式 `x`，选择表达式 `x.f` 表示值 `x` 的字段或方法 `f`（或 `*x`，`x.f` 是 `(*x).f` 的简写）。标识符 `f` 被称为（字段或方法）选择器。选择表达式的类型是 `f` 的类型。如果 `x` 是一个包名，则 `f` 是该包的导出限定标识符，例如 `math.Sin`。

选择器 `f` 可以表示类型 `T` 的字段或方法 `f`，或表示类型 `T` 嵌入字段的提升字段或提升方法 `f`。在 `T` 中声明的字段或方法 `f` 的深度为零。在 `T` 中的嵌入字段 `A` 中声明的字段或方法 `f` 的深度是 `A` 中的 `f` 的深度加 1。

以下规则适用于选择器：
- 对于类型 `T` 或 `*T` 的值 `x`，其中 `T` 不是指针或接口类型，`x.f` 表示在 `T` 中最浅深度的字段或方法。
- 对于接口类型 `I` 的值 `x`，`x.f` 表示具有动态值 `x` 的实际方法 `f`。
- 作为例外，如果 `x` 的类型是定义的指针类型，而 `(*x).f` 是表示字段（但不是方法）的有效选择表达式，则 `x.f` 是 `(*x).f` 的简写。
- 在所有其他情况下，`x.f` 都是非法的。
- 如果 `x` 是指针类型，并且具有值 `nil`，而 `x.f` 表示结构字段，则分配或求值 `x.f` 会导致 *panicking*。
- 如果 `x` 是接口类型并且值为 `nil`，则调用或求值方法 `x.f` 会导致 *panicking*。

```go
// 给定声明
type T0 struct {
	x int
}
func (*T0) M0()

type T1 struct {
	y int
}
func (T1) M1()
type T2 struct {
	z int
	T1
	*T0
}
func (*T2) M2()
type Q *T2

var t T2     // with t.T0 != nil
var p *T2    // with p != nil and (*p).T0 != nil
var q Q = p
```
```go
// 如下调用
t.z          // t.z
t.y          // t.T1.y
t.x          // (*t.T0).x

p.z          // (*p).z
p.y          // (*p).T1.y
p.x          // (*(*p).T0).x

q.x          // (*(*q).T0).x        (*q).x is a valid field selector

p.M0()       // ((*p).T0).M0()      M0 expects *T0 receiver
p.M1()       // ((*p).T1).M1()      M1 expects T1 receiver
p.M2()       // p.M2()              M2 expects *T2 receiver
t.M2()       // (&t).M2()           M2 expects *T2 receiver, see section on Calls

// 无效调用
q.M0()       // (*q).M0 is valid but not a field selector, Q 是类型定义，非 *T2 别名
// 若 type Q = *T2, 则 q.M0() 成立
```

---
### 11. 方法与接收器

#### 11.1. 方法声明

方法是一个带有接收器的函数，接收器的参数标识符可省略。方法声明将方法关联到接收方的基类型。可以为任何命名类型（除了指针或接口）定义方法。接收器的类型是已定义类型 `T` 或 `*T`，可能后随一个类型参数列表 `[P1, P2, …]`。`T` 被称为接收器基类型。接收器基类型本身不能是指针或接口类型。方法绑定到其接收器基类型 `T`，并且仅在 `T` 或 `*T` 的选择器中可见。


```go
func (t T) Method(argsList) { body }		
func (pt *T) Method(argsList) { body }		

func (p Point) Length() float64 {				// receiver is Point
	return math.Sqrt(p.x * p.x + p.y * p.y)
}
func (p *Point) Scale(factor float64) {    	    // receiver is *Point
	p.x *= factor
	p.y *= factor
}

func (Receiver) Foo(int)			// 省略接收器和参数的标识符
```

类型方法集的名称必须唯一。如果基类型是结构类型，则方法名称和字段名称必须是不同的。

```go
type S struct {
	F int
}
func (s S) F() {}   // invalid，名称唯一性
```

如果接收器基类型是泛型类型，则接收器规范必须声明要使用的方法的相应类型参数。

```go
type Pair[A, B any] struct {
	a A
	b B
}
func (p Pair[A, B]) Swap() Pair[B, A]  { … }  // receiver declares A, B
func (p Pair[First, _]) First() First  { … }  // receiver declares First, corresponds to A in Pair
```


>---
#### 11.2. 方法集

类型的方法集关联了对该类型的操作（方法集可能是空的）：
- 类型 `T` 的方法集由所有使用接收器类型 `T` 声明的方法组成。
- 指向类型 `T` 的指针的方法集是使用接收器 `*T` 或 `T` 声明的所有方法的集合。
- 接口类型的方法集是接口类型集中每个类型的方法集的交集（结果方法集通常只是接口中声明的方法集）。
- 在方法集中，每个方法必须有唯一的非空方法名。

进一步的规则适用于包含嵌入字段的结构或结构指针。任何其他类型都有一个空的方法集。若嵌入成员的方法集提升为结构的方法集，则该结构同样实现了嵌入成员的接口。

```go
type IFace interface {
	Func()
}
type Embed struct{}
func (Embed) Func() {
	fmt.Print("Hello World")
}

type S struct {
	Embed	
}
func foo(f IFace) {
	f.Func()
}
func main() {
	foo(S{})
}
```

>---
#### 11.3. 方法表达式

如果方法 `M` 在类型 `T` 的方法集中，则方法表达式 `T.M` 是一个可作为常规函数调用的函数，并将方法接收器 `T` 的值作为 `T.M` 的第一个参数。例如一个类型为 `T` 的结构体，它有两个方法：`Mv`，其接收器类型为 `T`；`Mp`，其接收器类型为 `*T`。

```go
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver
```

方法表达式 `T.Mv` 生成一个与 `Mv` 等效的函数，但它的第一个参数是显式传递的接收器变量值；`T.Mv` 具有签名 `func(tv T, a int) int`，以下五个调用是等效的：

```go
var t T

t.Mv(7)
T.Mv(t, 7)
(T).Mv(t, 7)
f1 := T.Mv; f1(t, 7)
f2 := (T).Mv; f2(t, 7)
```

方法表达式 `(*T).Mp` 也生成一个函数值，表示带有签名的 `Mp`：`func(tp *T, f float32) float32`。对于具有值接收器的方法 `T.Mv`，可以导出具有显式指针接收器的函数 `(*T).Mv`，即生成 `func(tv *T, a int) int`。这样的函数通过接收器间接创建一个值，并作为接收器传递给底层方法；该方法不会覆盖在函数调用中传递的地址的值。

```go
f := (*T).Mv; f(&T{1}, 1)
```

指针接收器方法的值接收器函数（`(T).Mp`）是非法的，因为指针接收器方法不在值类型的方法集中。从方法派生的函数值是用函数调用语法调用的；接收器作为调用的第一个参数提供。给定 `f := T.Mv`，`f` 被调用为 `f(t, 7)` 而不是 `t.f(7)`。若要构造绑定接收方的函数，请使用函数文本（匿名函数）或方法值（例如 `T.Mv`）。

```go
f1 := T.Mp       // illegal
f2 := (*T).Mp    // legal, func(tp *T, a float32) float32
f3 := (*T).Mv	 // 间接传递给 func(tv *T, a int) int
```

从接口类型的方法派生函数值是合法的。结果函数接受该接口类型的显式接收器。

>---
#### 11.4. 方法值

如果表达式 `x` 具有静态类型 `T`，并且 `M` 在类型 `T` 的方法集中，则 `x.M` 被称为方法值。方法值 `x.M` 是一个函数值，可以使用与 `x.M` 的方法调用相同的参数进行调用。表达式 `x` 在方法值的计算过程中被计算和保存；保存的副本可以在任何调用中用作接收器，这些调用可能在以后执行。

```go
type S struct { *T }
type T int
func (t T) M() { print(t) }

t := new(T)
s := S{T: t}
f := t.M                    // receiver *t is evaluated and stored in f
g := s.M                    // receiver *(s.T) is evaluated and stored in g
*t = 42                     // does not affect stored receivers in f and g
```

类型 `T` 可以是接口或非接口类型。考虑一个结构类型 `T`，它有两个方法：`Mv`，其接收器是类型 `T`；`Mp`，其接收器是类型 `*T`。

```go
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver

var t T
var pt *T
func makeT() T
```

表达式 `t.Mv` 生成类型为 `func(int) int` 的函数值，`t.Mv(7)` 和 `f := t.Mv; f(7)` 这两个调用是等效的。表达式 `pt.Mp` 生成类型为 `func(float32) float32` 的函数值。

与选择器一样，使用指针引用具有值接收器的非接口方法将自动取引用该指针：`pt.Mv` 等效于 `(*pt).Mv`。与方法调用一样，对具有指针接收器的非接口方法的引用使用可寻址值将自动获取该值的地址：`t.Mp` 等效于 `(&t).Mp`。

```go
f := t.Mv; f(7)   // like t.Mv(7)
f := pt.Mp; f(7)  // like pt.Mp(7)
f := pt.Mv; f(7)  // like (*pt).Mv(7)
f := t.Mp; f(7)   // like (&t).Mp(7)
f := makeT().Mp   // invalid: result of makeT() is not addressable
```

从接口类型的值创建方法值实质是其关联的动态类型的方法值。

```go
var i interface { M(int) } = myVal
f := i.M; f(7)  // like i.M(7)
```

---
### 12. 泛型声明

#### 12.1. 类型参数声明

类型参数列表声明泛型函数或类型声明的类型参数。在 Go 中，泛型类型的反射信息包括完整的编译时类型信息。当泛型类型的类型参数列表声明了一个带有约束 `C` 的单个类型参数 `P`，使得文本 `P C` 形成一个有效表达式时，就会出现解析二义性：

```go
type T[P *C] …
type T[P (C)] …
type T[P *C|Q] …
…
```

在这些罕见的情况下，类型参数列表与表达式无法区分，并且类型声明被解析为数组类型声明。若要解决歧义，需要将约束嵌入接口中或使用尾随逗号：

```go
type T[P interface{*C}] …
type T[P *C,] …
```

在泛型类型 `T` 的类型参数列表内，类型约束不能（直接地或通过另一泛型类型的类型参数列表间接地）引用 `T`。

```go
type T1[P T1[P]] …                    // illegal: T1 refers to itself
type T2[P interface{ T2[int] }] …     // illegal: T2 refers to itself
type T3[P interface{ m(T3[int])}] …   // illegal: T3 refers to itself
type T4[P T5[P]] …                    // illegal: T4 refers to T5 and
type T5[P T4[P]] …                    //          T5 refers to T4

type T6[P int] struct{ f *T6[P] }     // ok: reference to T6 is not in type parameter list
```

>---

#### 12.2. 类型约束

Go 约束是定义所有允许的类型参数集的接口类型，并控制该类型参数的值所允许的操作。如果约束是一个形式为 `interface{E}` 的接口文本，其中 `E` 为非嵌入方法。在类型参数列表中，可以省略封闭的 `interface`：

```go
[T []P]                      // 相当于 [T interface{[]P}]
[T ~int]                     // 相当于 [T interface{~int}]
[T int|string]               // 相当于 [T interface{int|string}]
type Constraint ~int         // illegal: ~int is not in a type parameter list
```

预声明接口类型 `comparable` 表示所有严格可比较的非接口类型的集合。尽管不是类型参数的接口是可比较的，但它们不是严格可比较的，因为它们不能实现 `comparable`，但它们满足 `comparable` 约束。

```go
int                          // implements comparable (int is strictly comparable)
[]byte                       // does not implement comparable (slices cannot be compared)
interface{}                  // does not implement comparable (see above)
interface{ ~int | ~string }  // type parameter only: implements comparable (int, string types are strictly comparable)
interface{ comparable }      // type parameter only: implements comparable (comparable implements itself)
interface{ ~int | ~[]byte }  // type parameter only: does not implement comparable (slices are not comparable)
interface{ ~struct{ any } }  // type parameter only: does not implement comparable (field any is not strictly comparable)
```

>---

#### 12.3. 满足类型约束

如果类型参数 `T` 是由类型约束 `C` 类型集合的元素，则类型参数 `T` 满足类型约束 `C`；即 `T` 实现了 `C`。作为一个例外，一个严格可比较的类型约束也可以由一个可比较的（不一定是严格可比较的）类型参数来满足。更准确地说：
- `T` 实现 `C`；或
- `C` 可以写成 `interface{ comparable; E }` 的形式，其中 `E` 是一个基接口，`T` 是可比较的，实现了 `E`。

```go
type argument      type constraint                // constraint satisfaction
----------------------------------------------------------------------------------------------------------------
int                interface{ ~int }              // satisfied: int implements interface{ ~int }
string             comparable                     // satisfied: string implements comparable (string is strictly comparable)
[]byte             comparable                     // not satisfied: slices are not comparable
any                interface{ comparable; int }   // not satisfied: any does not implement interface{ int }
any                comparable                     // satisfied: any is comparable and implements the basic interface any
struct{f any}      comparable                     // satisfied: struct{f any} is comparable and implements the basic interface any
any                interface{ comparable; m() }   // not satisfied: any does not implement the basic interface interface{ m() }
interface{ m() }   interface{ comparable; m() }   // satisfied: interface{ m() } is comparable and implements the basic interface interface{ m() }
```

由于约束满足规则中的异常，比较类型参数类型的操作数可能在运行时异常（即使可比较的类型参数总是严格可比较的）。

>---
#### 12.4. 类型参数实例化

泛型函数实例化分为两个步骤：
  1. 在泛型声明中，每个类型参数都替换为其对应的类型实参。
  2. 在替换之后，每个类型实参必须满足相应类型参数的约束（必要时实例化）。否则实例化失败。

实例化类型会产生一个新的非泛型命名类型；实例化函数会产生一个新的非泛型函数。

```go
type parameter list    type arguments    after substitution
-----------------------------------------------------------------
[P any]                int               // int satisfies any
[S ~[]E, E any]        []int, int        // []int satisfies ~[]int, int satisfies any
[P io.Writer]          string            // illegal: string doesn't satisfy io.Writer
[P comparable]         any               // any satisfies (but does not implement) comparable
```

当使用泛型函数时，类型参数可以显式提供，或者它们可以部分或完全从使用该函数的上下文推断。对于泛型类型，必须始终显式提供所有类型参数。

```go
// sum returns the sum (concatenation, for strings) of its arguments.
func sum[T ~int | ~float64 | ~string](x... T) T { … }

x := sum                       // illegal: the type of x is unknown
intSum := sum[int]             // intSum has type func(x... int) int
a := intSum(2, 3)              // a has value 5 of type int
b := sum[float64](2.0, 3)      // b has value 5.0 of type float64
c := sum(b, -1)                // c has value 4.0 of type float64

type sumFunc func(x... string) string
var f sumFunc = sum            // same as var f sumFunc = sum[string]
f = sum                        // same as f = sum[string]
```

部分类型参数列表不能为空；至少第一个参数必须存在。该列表是类型参数完整列表的前缀，其余参数将由推断得出。

```go
unc apply[S ~[]E, E any](s S, f func(E) E) S { … }

f0 := apply[]                  // illegal: type argument list cannot be empty
f1 := apply[[]int]             // type argument for S explicitly provided, type argument for E inferred
f2 := apply[[]string, string]  // both type arguments explicitly provided

var bytes []byte
r := apply(bytes, func(byte) byte { … })  // both type arguments inferred from the function arguments
```

---
### 13. 内置函数

内置函数是预先声明的。它们可以像其他函数一样被调用，但其中一些函数接受类型而不是表达式作为第一个参数。内置函数没有标准的 Go 类型，因此它们只能出现在调用表达式中，并且不能用作函数值。

>--- 
#### 13.1. append：切片扩展

```go
func append(slice []Type, elems ...Type) []Type // core type of slice is []Type
```

可变参数函数 `append` 将零个或多个值 `elems` 附加到切片 `slice`，并返回与 `slice` 相同类型的结果切片。`slice` 的核心类型必须是 `[]Type` 类型的切片。值 `elems` 被传递给类型 `...Type` 的参数，并且应用相应的参数传递规则。作为特殊情况，如果 `slice` 的核心类型是 `[]byte`，则 `append` 也接受核心类型为 `bytestring` 后跟 `...` 的第二个参数。这种形式追加字节切片或字符串的字节。结果与参数引用的内存是否重叠无关。

```go
func append(slice []Byte, str ...string) []Byte
```

如果 `slice` 的容量不足以容纳额外的值，`append` 会分配一个新的、足够大的底层数组（长度为原切片最大容量的二倍），以容纳现有的切片元素和额外的值。否则，在切片有效容量内，`append` 会重用底层数组，扩容切片也可能会修改底层数组的元素值。

```go
s0 := []int{0, 0}
s1 := append(s0, 2)                // append a single element     s1 is []int{0, 0, 2}
s2 := append(s1, 3, 5, 7)          // append multiple elements    s2 is []int{0, 0, 2, 3, 5, 7}
s3 := append(s2, s0...)            // append a slice              s3 is []int{0, 0, 2, 3, 5, 7, 0, 0}
s4 := append(s3[3:6], s3[2:]...)   // append overlapping slice    s4 is []int{3, 5, 7, 2, 3, 5, 7, 0, 0}

var t []interface{}
t = append(t, 42, 3.1415, "foo")   //                             t is []interface{}{42, 3.1415, "foo"}

var b []byte
b = append(b, "bar"...)            // append string contents      b is []byte{'b', 'a', 'r' }
```

>---
#### 13.2. copy：切片复制

```go
func copy(dst, src []Type) int
```

函数 `copy` 将切片元素从源 `src` 复制到 `dst`，并返回所复制的元素的数目。两个参数的核心类型必须是具有相同元素类型的切片。复制的元素数为 `len(src)` 和 `len(dst)` 的最小值。作为特殊情况，如果目标的核心类型是 `[]byte`，则 `copy` 也接受核心类型为 `bytestring` 的源参数。这种形式将字节从字节切片或字符串复制到字节切片中。结果与参数引用的内存是否重叠无关。

```go
copy(dst []byte, src string) int
```
```go
var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
var b = make([]byte, 5)
n1 := copy(s, a[0:])            // n1 == 6, s is []int{0, 1, 2, 3, 4, 5}
n2 := copy(s, s[2:])            // n2 == 4, s is []int{2, 3, 4, 5, 4, 5}
n3 := copy(b, "Hello, World!")  // n3 == 5, b is []byte("Hello")
```

>---
#### 13.3. clear：清零或删除元素

```go
func clear[T ~[]Type | ~map[Type]Type1](t T)
```

内置函数 `clear` 接受 `map`、`slice` 或 `type parameter` 类型的参数，并删除或清零所有元素。如果 `map` 或 `slice` 为 `nil`，则 `clear` 为无操作。

```go
Call        Argument type     Result
------------------------------------------------
clear(m)    map[K]T           deletes all entries, resulting in an empty map (len(m) == 0)
clear(s)    []T               sets all elements up to the length of s to the zero value of T
clear(t)    type parameter    see below
```

如果 `clear` 的参数类型是类型参数，则其类型集中的所有类型都必须是映射或切片，而 `clear` 执行与实际类型参数对应的操作。

>---
#### 13.4. close：关闭通道

```go
func close(c chan<- Type)
```

对于核心类型为通道的参数 `ch`，内置函数 `close` 记录不会在通道上发送更多值。如果 `ch` 是仅接收通道，则发生错误。发送或关闭已关闭的通道会导致 *panicking*。关闭 `nil` 通道也会导致 *panicking*。

在调用 `close` 之后，并且在接收到任何先前发送的值之后，接收操作将返回通道类型的零值且不会阻塞。多值接收操作（`_, ok := <-ch`）返回接收值以及通道是否关闭的指示。

>---
#### 13.5. complex、real、imag：复数操作

```go
func complex(r, i FloatType) ComplexType
func real(c ComplexType) FloatType
func imag(c ComplexType) FloatType
```

内置函数 `complex` 从浮点实部和虚部构造一个复数值，而 `real` 和 `imag` 提取复数值的实部和虚部。对于 `complex`，两个参数必须是具有相同浮点类型，且返回类型也是具有相应浮点类型的复数类型：`float32` 类型的参数对应 `complex64` 的返回类型，`float64` 类型的参数对应于 `complex128` 的返回类型。

如果其中一个参数的计算结果是无类型常量，则首先将其隐式转换为另一个参数的类型。若两个参数都是无类型常量，则它们必须是非复数，或者它们的虚部必须为零，并且函数的返回值是无类型的复常量。

对于 `real` 和 `imag`，参数必须是复数类型，并且返回类型是对应的浮点类型：对于 `complex64` 参数，返回类型是 `float32`，对于 `complex128` 参数，返回类型是 `float64`。如果参数计算为无类型常数，则它必须是数字，并且函数的返回值是无类型浮点常数。对于复数类型 `Z` 的值 `z`，相当于 `Z(complex(real(z), imag(z)))`。

如果这些函数的操作数都是常量，则返回值是常量。

```go
var a = complex(2, -2)             // complex128
const b = complex(1.0, -1.4)       // untyped complex constant 1 - 1.4i
x := float32(math.Cos(math.Pi/2))  // float32
var c64 = complex(5, -x)           // complex64
var s int = complex(1, 0)          // untyped complex constant 1 + 0i can be converted to int
_ = complex(1, 2<<s)               // illegal: 2 assumes floating-point type, cannot shift
var rl = real(c64)                 // float32
var im = imag(a)                   // float64
const c = imag(b)                  // untyped constant -1.4
_ = imag(3 << s)                   // illegal: 3 assumes complex type, cannot shift
```

>--- 
#### 13.6. delete：删除映射元素

```go
func delete(m map[Type]Type1, key Type)
```

内置函数 `delete` 从映射 `m` 中删除键为 `key` 的元素。如果操作数 `m` 是类型参数，则该类型集中的所有类型都必须是映射，并且它们必须具有相同的键类型。如果映射 `m` 是 `nil` 或键不存在，则 `delete` 是空操作。

```go
var m = map[int]string{
	0: "zero",
	1: "one",
	2: "two",
	3: "three",
	4: "four",
}
delete(m, 0)
for _, v := range m {
	print(v + ",")  // one,two,three,four,
}
```

>---
#### 13.7. len、cap：长度与容量

```go
func len(v Type) int
func cap(v Type) int
```

内置函数 `len` 和 `cap` 接受数组、指向数组的指针、切片、映射、字符串、通道类型的参数，并返回类型为 `int` 的结果。

```go
Call      Argument type    Result

len(s)    string type      string length in bytes
          [n]T, *[n]T      array length (== n)
          []T              slice length
          map[K]T          map length (number of defined keys)
          chan T           number of elements queued in channel buffer
          type parameter   see below

cap(s)    [n]T, *[n]T      array length (== n)
          []T              slice capacity
          chan T           channel buffer capacity
          type parameter   see below
```

如果操作数是类型参数 `P`，则调用 `len(e)`（或 `cap(e)`）必须对 `P` 的类型集中的每个类型有效。结果是参数的长度（或容量），其类型对应于实例化 `P` 的类型参数。

切片的容量是底层数组中为其分配空间的元素的数量。在任何时候，`0 <= len(s) <= cap(s)` 关系成立。`nil` 切片、映射或通道的长度为 0。`nil` 切片或通道的容量为 0。

如果 `s` 是字符串常量，则表达式 `len(s)` 是常量。如果表达式 `s` 的类型是数组或指向数组的指针，并且表达式 `s` 不包含通道接收或（非常量）函数调用，则表达式 `len(s)` 和 `cap(s)` 是常量；在这种情况下，不计算 `s`。否则，对 `len` 和 `cap` 的调用不是常量，而 `s` 被求值。

```go
const (
	c1 = imag(2i)                    // imag(2i) = 2.0 is a constant
	c2 = len([10]float64{2})         // [10]float64{2} contains no function calls
	c3 = len([10]float64{c1})        // [10]float64{c1} contains no function calls
	c4 = len([10]float64{imag(2i)})  // imag(2i) is a constant and no function call is issued
	c5 = len([10]float64{imag(z)})   // invalid: imag(z) is a (non-constant) function call
)
var z complex128
```

>---
#### 13.8. make：分配

```go
func make(t Type, size ...IntegerType) Type
```

内置函数 `make` 接受类型 `Type`，可选地后跟特定类型的表达式列表。`Type` 的核心类型必须是切片、应映射、通道。它的返回类型为 `Type`（不是 `Type *`）。结果取决于参数的类型。

```go
Call             Core type    Result
----------------------------------------------------------------------------------------------
make(T, n)       slice        // slice of type T with length n and capacity n
make(T, n, m)    slice        // slice of type T with length n and capacity m

make(T)          map          // map of type T
make(T, n)       map          // map of type T with initial space for approximately n elements

make(T)          channel      // unbuffered channel of type T
make(T, n)       channel      // buffered channel of type T, buffer size n
```

每个大小参数 `n` 和 `m` 必须是整数类型，或是具有仅包含整数类型的类型集，或者是无类型的常量。常量大小参数必须是非负的，并且可以用类型 `int` 的值表示；如果它是一个无类型的常量，则给出类型 `int`。如果 `n` 和 `m` 都被提供并且是常量，则 `n` 必须不大于 `m`。对于切片和通道，如果运行时 `n` 为负或大于 `m`，则会发生运行时异常。

```go
s := make([]int, 10, 100)       // slice with len(s) == 10, cap(s) == 100
s := make([]int, 1e3)           // slice with len(s) == cap(s) == 1000
s := make([]int, 1<<63)         // illegal: len(s) is not representable by a value of type int
s := make([]int, 10, 0)         // illegal: len(s) > cap(s)
c := make(chan int, 10)         // channel with a buffer size of 10
m := make(map[string]int, 100)  // map with initial space for approximately 100 elements
```

使用 `map` 类型和 `size` 作为参数调用 `make` 将创建一个带有初始内存空间的映射，以容纳 `size` 个映射元素。`make([]int, 10, 100)` 分配一个容纳 100 个 `int` 的数组，然后创建一个长度为 10、容量为 100 的切片结构，指向数组的前 10 个元素。`make` 构造切片时，容量可以省略；相反，`new([]int)` 返回一个指向新分配的零切片结构的指针，即指向 `nil` 切片值的指针。

以下说明了 `new` 和 `make` 之间的区别。

```go
var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
```

>---
#### 13.9. min、max：最大值和最小值

```go
func min[T cmp.Ordered](x T, y ...T) T
func max[T cmp.Ordered](x T, y ...T) T
```

内置函数 `min` 和 `max` 分别计算固定数量的有序类型参数的最小值或最大值。必须至少有一个参数。与运算符相同的类型规则适用于：对于有序参数 `x` 和 `y`，如果 `x + y` 有效，则 `min(x, y)` 有效，并且 `min(x, y)` 的类型是 `x + y` 的类型（对于 `max` 也是如此）。如果所有参数都是常量，则结果也是常量。

```go
var x, y int
m := min(x)                 // m == x
m := min(x, y)              // m is the smaller of x and y
m := max(x, y, 10)          // m is the larger of x and y but at least 10
c := max(1, 2.0, 10)        // c == 10.0 (floating-point kind)
f := max(0, float32(x))     // type of f is float32
var s []string
_ = min(s...)               // invalid: slice arguments are not permitted
t := max("", "foo", "bar")  // t == "foo" (string kind)
```

对于数值类型参数，假设所有的 NaN 相等，则 `min` 和 `max` 是可交换且可结合的：

```go
min(x, y)    == min(y, x)
min(x, y, z) == min(min(x, y), z) == min(x, min(y, z))
```

对于浮点参数负零、NaN 和无穷大，以下规则适用：

```go
   x        y    min(x, y)    max(x, y)
---------------------------------------------------------------------------------------------------
  -0.0    0.0         -0.0          0.0    // negative zero is smaller than (non-negative) zero
  -Inf      y         -Inf            y    // negative infinity is smaller than any other number
  +Inf      y            y         +Inf    // positive infinity is larger than any other number
   NaN      y          NaN          NaN    // if any argument is a NaN, the result is a NaN
```

对于字符串参数，`min` 的结果是第一个具有最小值的参数（或 `max`，最大值），按字节进行词法比较：

```go
min(x, y)    == if x <= y then x else y
min(x, y, z) == min(min(x, y), z)
```

>---
#### 13.10. new：分配

```go
func new(Type) *Type
```

内置函数 `new(T)` 为类型 `T` 分配零值的存储空间并返回其地址，结果为 `*T` 的值。

```go
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
```

为类型 `SyncedBuffer` 的变量分配存储空间，并返回一个指向新分配零值位置的地址 `*SyncedBuffer` 的值。类型 `SyncedBuffer` 的值也可以在分配或声明时立即使用。例如，`p` 和 `v` 都将正确工作，无需进一步操作。

```go
p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
```

>---
#### 13.11. panic、recover：异常处理

```go
func panic(v any)
func recover() any
```

内置函数 `panic` 和 `recover` 有助于报告和处理运行时异常和程序定义的错误条件。

在执行函数 `F` 时，调用 `panic` 或运行时 *panicking* 会终止 `F` 的执行。任何被 `F` 延迟（`defer`）的函数都会照常执行。然后由 `F` 返回它的调用方。对于调用方 `G`，调用 F 的行为就像调用 `panic`，终止 G 的执行并运行任何延迟的函数。依此类推，直到执行至 *goroutine* 中的顶级函数延迟函数执行。此时程序终止并报告错误条件，并返回 `panic` 的参数值。

```go
panic(42)
panic("unreachable")
panic(Error("cannot parse"))
```

`recover` 函数允许程序管理一个 *panicking* *goroutine* 的行为。假设一个函数 `G` 推迟了一个调用 `recover` 的函数 `D`，并且在 `D` 执行的同一个 *goroutine* 上的一个函数中发生了一个 *panicking*。当延迟函数的运行到达 `D` 时，`D` 调用 `recover` 的返回值是调用 `panic` 的参数。如果 `D` 正常返回，而没有启动新的 `panic`，则 *panicking* 序列停止。在这种情况下，在 `G` 和调用 `panic` 之间调用的函数的状态被丢弃，并且恢复正常执行。然后运行任何在 `D` 之前被 `G` 延迟的函数，并且 `G` 的执行将通过返回到其调用者而终止。

当 *goroutine* 没有出现 *panicking* 或者 `recover` 没有被延迟函数直接调用时，`recover` 的返回值是 `nil`。`panic` 的参数不能是 `nil` 值。下面示例中的 `protect` 函数调用函数参数 `g`，并保护调用方免受 `g` 引发的运行时异常。

```go
func main() {
	protect(func() {
		var a, b int = 1, 0
		_ = a / b
	})
}
func protect(g func()) {
	defer func() {
		log.Println("done") // Println executes normally even if there is a panic
		if x := recover(); x != nil {
			log.Printf("run time panic: %v", x)
		}
	}()
	log.Println("start")
	g()
}
```

>---
#### 13.12. print、println：格式化输出

```go
func print(args ...Type)
func println(args ...Type)
```

当前的实现提供了几个在引导过程有用的内置函数。这些函数是为了完整性而记录的，但不能保证保持在语言中。它们不返回结果。

```go
Function   Behavior
-------------------------------------------------------------------------------------
print      prints all arguments; formatting of arguments is implementation-specific
println    like print but prints spaces between arguments and a newline at the end
```

`print` 内置函数以特定于实现的方式格式化其参数，并将结果写入标准错误。`print` 对于引导和调试很有用；它不能保证留在语言中。`println` 内置函数以特定于实现的方式格式化其参数并将结果写入标准错误，参数之间总是添加空格，并附加换行符。`println` 对于引导和调试很有用；它不能保证留在语言中。

---
### 14. 表达式与运算符
<!-- #### 14.2. 运算符

运算符将操作数组合成表达式。

除了比较运算符，对于其他的二元运算符，操作数的类型必须相同，除非运算涉及移位或无类型常量。除移位运算外，如果一个操作数是无类型常量而另一个操作数不是，则该常量将隐式转换为另一个操作数的类型。

移位表达式中的右操作数必须是整数类型或可由类型 `uint` 的值表示的无类型常量。如果非常量移位表达式的左操作数是无类型常量，则首先将其隐式转换为移位表达式仅被其左操作数替换时所假定的类型。

```go
var a [1024]byte
var s uint = 33

// The results of the following examples are given for 64-bit ints.
var i = 1<<s                   // 1 has type int
var j int32 = 1<<s             // 1 has type int32; j == 0
var k = uint64(1<<s)           // 1 has type uint64; k == 1<<33
var m int = 1.0<<s             // 1.0 has type int; m == 1<<33
var n = 1.0<<s == j            // 1.0 has type int32; n == true
var o = 1<<s == 2<<s           // 1 and 2 have type int; o == false
var p = 1<<s == 1<<33          // 1 has type int; p == true
var u = 1.0<<s                 // illegal: 1.0 has type float64, cannot shift
var u1 = 1.0<<s != 0           // illegal: 1.0 has type float64, cannot shift
var u2 = 1<<s != 1.0           // illegal: 1 has type float64, cannot shift
var v1 float32 = 1<<s          // illegal: 1 has type float32, cannot shift
var v2 = string(1<<s)          // illegal: 1 is converted to a string, cannot shift
var w int64 = 1.0<<33          // 1.0<<33 is a constant shift expression; w == 1<<33
var x = a[1.0<<s]              // panics: 1.0 has type int, but 1<<33 overflows array bounds
var b = make([]byte, 1.0<<s)   // 1.0 has type int; len(b) == 1<<33

// The results of the following examples are given for 32-bit ints,
// which means the shifts will overflow.
var mm int = 1.0<<s            // 1.0 has type int; mm == 0
var oo = 1<<s == 2<<s          // 1 and 2 have type int; oo == true
var pp = 1<<s == 1<<33         // illegal: 1 has type int, but 1<<33 overflows int
var xx = a[1.0<<s]             // 1.0 has type int; xx == a[0]
var bb = make([]byte, 1.0<<s)  // 1.0 has type int; len(bb) == 0
``` -->

>---
#### 14.1. 运算符优先级

一元运算符具有最高的优先级。由于 `++` 和 `--` 运算符形成语句，因此它们不属于运算符层次结构。因此，语句 `*p++` 与 `(*p)++` 相同。二元运算符有五个优先级，依次是乘法运算符、加法运算符、比较运算符、 逻辑 AND、逻辑 OR：

```go
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||
```

>---
#### 14.2. 算数运算符

算术运算符应用于数值并产生与第一个操作数相同类型的结果。标准算术运算符（`+`、`-`、`*`、`/`）适用于整数、浮点和复数类；`+` 也适用于字符串拼接。按位逻辑运算符和移位运算符仅适用于整数。

```go
+    sum                    integers, floats, complex values, strings
-    difference             integers, floats, complex values
*    product                integers, floats, complex values
/    quotient               integers, floats, complex values
%    remainder              integers


&    bitwise AND            integers
|    bitwise OR             integers
^    bitwise XOR            integers
&^   bit clear (AND NOT)    integers

<<   left shift             integer << integer >= 0
>>   right shift            integer >> integer >= 0
```

如果操作数类型是类型参数，则运算符必须能够应用于该类型集中的每个类型。根据下面 `dotProduct` 的类型参数 `F`，分别以 `float32` 或 `float64` 精度计算乘积 `x * y` 和加法 `s += x * y`。

```go
func dotProduct[F ~float32|~float64](v1, v2 []F) F {
	var s F
	for i, x := range v1 {
		y := v2[i]
		s += x * y
	}
	return s
}
```

> **整数运算**

对于两个整数值 `x` 和 `y`，整数商 `q = x / y` 和余数 `r = x % y` 满足关系 `x = q*y + r` 和 `|r| < |y|`。其中 `x / y` 向零截断（“截断除法”）：

```go
 x     y     x / y     x % y
 5     3       1         2
-5     3      -1        -2
 5    -3      -1         2
-5    -3       1        -2
```

此规则的一个例外是，如果被除数 `x` 是整数类型 `x` 的最大负值，则商 `q = x / -1` 等于 `x` （和 `r = 0` ），这是由于二进制补码整数溢出：

```go
                         x, q
int8                     -128
int16                  -32768
int32             -2147483648
int64    -9223372036854775808
```

对于整数操作数，一元运算符 `+`、`-` 和 `^` 定义如下：

```go
+x                          is 0 + x
-x    negation              is 0 - x
^x    bitwise complement    is m ^ x  with m = "all bits set to 1" for unsigned x
                                      and  m = -1 for signed x
```

> **整数溢出**

对于无符号整数值，运算 `+`、`-`、`*` 和 `<<` 是以模 $2^n$ 计算的，其中 $n$ 是无符号整数类型的位宽。不严格地说，这些无符号整数操作在溢出时丢弃高位，程序可能依赖于 “回绕”。

对于有符号整数，操作 `+`、`-`、`*`、`/` 和 `<<` 可以合法地溢出，并且结果值存在并且由有符号整数表示、操作及其操作数确定性地定义。溢出不会导致运行时异常。编译器可能不会在不发生溢出的假设下优化代码。例如，它可以不假设 `x < x + 1` 总是为真。

> 浮点运算

对于浮点数和复数，`+x` 与 `x` 相同，而 `-x` 是 `x` 的负数。除了 IEEE-754 标准之外，没有指定浮点数或复数除以零的结果；是否发生运行时异常是特定于实现的。

浮点运算的实现可以将多个浮点操作合并成单个融合操作（可能跨语句），并且产生与通过单独执行并舍入指令所获得的值不同的结果。显式浮点类型转换将舍入到目标类型的精度，从而防止丢弃该舍入的融合。例如，一些架构提供 “融合乘加”（FMA）指令，其计算 `x*y + z` 而不舍入中间结果 `x*y`。这些例子展示了 Go 语言实现何时可以使用该指令：

```go
// FMA allowed for computing r, because x*y is not explicitly rounded:
r  = x*y + z
r  = z;   r += x*y
t  = x*y; r = t + z
*p = x*y; r = *p + z
r  = x*y + float64(z)

// FMA disallowed for computing r, because it would omit rounding of x*y:
r  = float64(x*y) + z
r  = z; r += float64(x*y)
t  = float64(x*y); r = t + z
```

>---
#### 14.3. 比较运算符

比较运算符比较两个操作数并产生一个无类型的布尔值。

```go
==    equal
!=    not equal
<     less
<=    less or equal
>     greater
>=    greater or equal
```

在任何比较中，第一个操作数必须可分配给第二个操作数的类型，反之亦然。相等运算符 `==` 和 `!=` 适用于可比类型的操作数。排序运算符 `<`、`<=`、`>` 和 `>=` 适用于有序类型的操作数。这些项和比较结果定义如下：
- 布尔类型是可比较的。如果两个布尔值都是 `true` 或都是 `false`，则它们相等。
- 整数类型是可比较和有序的。以通常的方式进行比较。
- 浮点类型是可比较和有序的。按照 IEEE-754 标准的定义比较两个浮点值。
- 复数类型是可比较的。如果 `real(u) == real(v)` 和 `imag(u) == imag(v)`，则两个复数值 `u` 和 `v` 相等。
- 字符串类型是可比较和有序的。两个字符串值按字节进行词法比较。
- 指针类型具有可比性。如果两个指针指向同一个变量，或者两个指针都有值 `nil`，则它们相等。指向不同的零大小变量的指针可能相等，也可能不相等。
- 通道类型具有可比性。如果两个通道值是由同一个 `make` 的调用创建的，或者两个通道值都具有值 `nil`，则它们相等。
- 不是类型参数的接口类型是可比较的。如果两个接口值具有相同的动态类型和相同的动态值，或者两者都具有值 `nil`，则它们相等。
- 如果类型 `X` 是可比较的并且 `X` 实现 `T`，则可以比较非接口类型 `X` 的值 `x` 和接口类型 `T` 的值 `t`。如果 `t` 的动态类型与 `X` 相同，并且 `t` 的动态值等于 `x`，则它们相等。
- 如果结构类型的所有字段类型都是可比较的，则结构类型是可比较的。如果两个结构值对应的非空字段值相等，则它们相等。字段按源顺序进行比较，一旦两个字段值不同（或所有字段都已比较），比较就会停止。
- 如果数组元素类型是可比较的，则数组类型是可比较的。如果它们对应的元素值相等，两个数组值相等。元素按索引升序进行比较，一旦两个元素值不同（或所有元素都已比较），比较就会停止。
- 如果类型参数是 *strictly comparable* 的，则它们是可比较的。

比较具有相同动态类型的两个接口值时，如果该类型不可比较，则会导致运行时异常。此行为不仅适用于直接接口值比较，而且适用于比较带有接口值字段的接口值数组或结构体。

切片、映射和函数类型不可比较的。作为特殊情况，可以将它们的值与 `nil` 进行比较。也允许将指针、通道和接口值与 `nil` 进行比较。

```go
const c = 3 < 4            // c is the untyped boolean constant true

type MyBool bool
var x, y int
var (
	// The result of a comparison is an untyped boolean.
	// The usual assignment rules apply.
	b3        = x == y // b3 has type bool
	b4 bool   = x == y // b4 has type bool
	b5 MyBool = x == y // b5 has type MyBool
)
```

一个类型如果它是可比较的，并且不是接口类型，也不是由接口类型组成的，则它是严格可比较（*strictly comparable*）的。具体而言：
- 布尔、数值、字符串、指针和通道等类型是严格可比的。
- 如果结构类型的所有字段类型都是严格可比的，则结构类型是严格可比的。
- 如果数组元素类型是严格可比较的，则数组类型是严格可比较的。
- 如果类型参数的类型集中的所有类型都是严格可比较的，则类型参数是严格可比较的。

>---
#### 14.4. 逻辑运算符

逻辑运算符应用于布尔值，并产生与操作数相同类型的结果。遵从短路原则：

```go
&&    conditional AND    p && q  is  "if p then q else false"
||    conditional OR     p || q  is  "if p then true else q"
!     NOT                !p      is  "not p"
```

>---
#### 14.5. 地址运算符

对于类型 `T` 的操作数 `x`，地址操作 `&x` 生成指向 `x` 的 `*T` 类型指针。操作数必须是可寻址的，作为一个例外，`x` 也可以是复合文本。如果对 `x` 的求值会导致运行时异常，那么对 `&x` 的求值也会。对于指针类型 `*T` 的操作数 `x`，指针间接寻址 `*x` 表示由 `x` 指向的类型 `T` 的变量。如果 `x` 是 `nil`，则尝试计算 `*x` 将导致运行时异常。

```go
&x
&a[f(2)]
&Point{2, 3}
*p
*pf(x)

var x *int = nil
*x   // causes a run-time panic
&*x  // causes a run-time panic
```

>---
#### 14.6. 接收运算符

对于核心类型是通道的操作数 `ch`，接收操作 `<-ch` 的值是从通道 `ch` 接收的值。通道方向必须允许接收操作，并且接收操作的类型是通道的元素类型。表达式将一直阻塞，直到有可用的值。从 `nil` 通道接收永远阻塞。封闭通道上的接收操作总是可以立即进行，在接收到任何先前发送的值之后，生成元素类型的零值。

```go
v1 := <-ch
v2 = <-ch
f(<-ch)
<-strobe  // wait until clock pulse and discard received value
```

接收表达式产生一个额外的布尔值，报告通信是否成功。如果接收到的值是通过成功的发送操作传递到通道的，则 `ok` 的值为 `true`；如果它是由于通道关闭且为空而生成的零值，则为 `false`。在赋值语句或特殊形式的初始化中使用的接收表达式：

```go
x, ok = <-ch
x, ok := <-ch
var x, ok = <-ch
var x, ok T = <-ch
```

>---
#### 14.7. 常量表达式

常量表达式可以只包含常量操作数，并在编译时计算。常量比较总是产生非类型化的布尔常量。如果常量移位表达式的左操作数是无类型常量，则结果是整数常量；否则它是与左操作数类型相同类型的常量。

对无类型常量的任何其他操作都将产生同一类型的无类型常量，即布尔常量、整数常量、浮点常量、复数常量或字符串常量。如果一个二元操作（除了移位）的无类型操作数是不同的类型，则结果是后面列表中出现的操作数的类型：整数、字符、浮点、复数。例如，一个无类型的整数常量除以一个无类型的复常量，得到一个无类型的复常量。

```go
const a = 2 + 3.0          // a == 5.0   (untyped floating-point constant)
const b = 15 / 4           // b == 3     (untyped integer constant)
const c = 15 / 4.0         // c == 3.75  (untyped floating-point constant)
const Θ float64 = 3/2      // Θ == 1.0   (type float64, 3/2 is integer division)
const Π float64 = 3/2.     // Π == 1.5   (type float64, 3/2. is float division)
const d = 1 << 3.0         // d == 8     (untyped integer constant)
const e = 1.0 << 3         // e == 8     (untyped integer constant)
const f = int32(1) << 33   // illegal    (constant 8589934592 overflows int32)
const g = float64(2) >> 1  // illegal    (float64(2) is a typed floating-point constant)
const h = "foo" > "bar"    // h == true  (untyped boolean constant)
const j = true             // j == true  (untyped boolean constant)
const k = 'w' + 1          // k == 'x'   (untyped rune constant)
const l = "hi"             // l == "hi"  (untyped string constant)
const m = string(k)        // m == "x"   (type string)
const Σ = 1 - 0.707i       //            (untyped complex constant)
const Δ = Σ + 2.0e-4       //            (untyped complex constant)
const Φ = iota*1i - 1/1i   //            (untyped complex constant)
```

将内置函数 `complex` 应用于无类型的整数、字符或浮点常量会生成无类型的复常量。

```go
const ic = complex(0, c)   // ic == 3.75i  (untyped complex constant)
const iΘ = complex(0, Θ)   // iΘ == 1i     (type complex128)
```

常量表达式总是精确计算；中间值和常量本身可能需要的精度远远大于语言中任何预先声明的类型所支持的精度。以下是合法的声明：

```go
const Huge = 1 << 100         // Huge == 1267650600228229401496703205376  (untyped integer constant)
const Four int8 = Huge >> 98  // Four == 4                                (type int8)
```

常量除法或余数运算的除数不能为零：

```go
3.14 / 0.0   // illegal: division by zero
```

类型化常量的值必须始终可以由常量类型的值准确表示。以下常量表达式是非法的：

```go
uint(-1)     // -1 cannot be represented as a uint
int(3.14)    // 3.14 cannot be represented as an int
int64(Huge)  // 1267650600228229401496703205376 cannot be represented as an int64
Four * 300   // operand 300 cannot be represented as an int8 (type of Four)
Four * 100   // product 400 cannot be represented as an int8 (type of Four)
```

一元按位求补运算符 `^` 使用的掩码与非常量规则匹配：对于无符号常量，掩码全为 1；对于有符号和无类型常量，掩码全为 -1。

```go
^1         // untyped integer constant, equal to -2
uint8(^1)  // illegal: same as uint8(-2), -2 cannot be represented as a uint8
^uint8(1)  // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)
int8(^1)   // same as int8(-2)
^int8(1)   // same as -1 ^ int8(1) = -2
```

>---
#### 14.8. 类型断言

对于接口类型的表达式 `x`（但不是类型参数）和类型 `T`，类型断言 `x.(T)` 断言 `x` 不是 `nil` 且存储在接口 `x` 中的值为类型 `T`。如果 `T` 不是接口类型，则 `x.(T)` 断言 `x` 的动态类型与类型 `T` 相同（`T` 必须实现 `x` 的（接口）类型）。如果 `T` 是接口类型，则 `x.(T)` 断言 `x` 的动态类型实现了接口 `T`。

表达式 `i := x.(int)` 断言成立，则 `i` 的值是存储在 `x` 中的值，类型为 `T`。如果类型断言为 `false` 则会 *panicking*。

```go
var x interface{} = 7          // x has dynamic type int and value 7
i := x.(int)                   // i has type int and value 7

type I interface { m() }

func f(y I) {
	s := y.(string)        // illegal: string does not implement I (missing method m)
	r := y.(io.Reader)     // r has type io.Reader and the dynamic type of y must implement both I and io.Reader
	…
}
```

类型断言会产生一个额外的无类型布尔值。如果断言成立，则 `ok` 为 `true`。否则，它是 `false`，而 `v` 的值是类型 `T` 的零值。在这种情况下不会发生运行时异常。在赋值语句或特殊形式的初始化中使用的类型断言：

```go
v, ok = x.(T)
v, ok := x.(T)
var v, ok = x.(T)
var v, ok interface{} = x.(T) // dynamic types of v and ok are T and bool
```

>---
#### 14.9. 类型转换

转换将表达式的类型更改为转换指定的类型。显式转换是一个形式为 `T(x)` 的表达式，其中 `T` 是一个类型，`x` 是一个可以转换为类型 `T` 的表达式。必要时需要使用括号以避免歧义：

```go
*Point(p)        // same as *(Point(p))
(*Point)(p)      // p is converted to *Point
<-chan int(c)    // same as <-(chan int(c))
(<-chan int)(c)  // c is converted to <-chan int
func()(x)        // function signature func() x
(func())(x)      // x is converted to func()
(func() int)(x)  // x is converted to func() int
func() int(x)    // x is converted to func() int (unambiguous)
```

如果 `x` 可以用值 `T` 表示，则常量值 `x` 可以被转换为类型 `T`。作为特殊情况，整数常量 `x` 可以使用与非常量 `x` 相同的规则显式转换为字符串类型。将常量转换为非类型参数的类型将产生类型化常量。

```go
uint(iota)               // iota value of type uint
float32(2.718281828)     // 2.718281828 of type float32
complex128(1)            // 1.0 + 0.0i of type complex128
float32(0.49999999)      // 0.5 of type float32
float64(-1e-1000)        // 0.0 of type float64
string('x')              // "x" of type string
string(0x266c)           // "♬" of type string
myString("foo" + "bar")  // "foobar" of type myString
string([]byte{'a'})      // not a constant: []byte{'a'} is not a constant
(*int)(nil)              // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type

int(1.2)                 // illegal: 1.2 cannot be represented as an int
string(65.0)             // illegal: 65.0 is not an integer constant
```

将常量转换为类型参数会产生该类型的非常量值，该值表示为实例化类型参数所用的类型参数的值。例如，转换 `P(1.1)` 导致类型 `P` 的非常量值，并且值 `1.1` 根据 `f` 的类型参数被表示为 `float32` 或 `float64`。

```go
func f[P ~float32|~float64]() {
	… P(1.1) …
}
```

在以下任何情况下，非常量值 `x` 都可以转换为类型 `T`：
- `x` 可分配给 `T`。
- 忽略 `struct` 标记，`x` 的类型和 `T` 不是类型参数，但具有相同的底层类型。
- 忽略 `struct` 标记，`x` 的类型和 `T` 是指针类型，它们不是命名类型，它们的指针基类型不是类型参数，但具有相同的基础类型。
- `x` 的类型和 `T` 都是整数或浮点类型。
- `x` 的类型和 `T` 都是复数类型。
- `x` 是一个整数，或字节切片，或字符，`T` 是一个字符串类型。
- `x` 是一个字符串，`T` 是字节切片或字符。
- `x` 是一个切片，`T` 是一个数组或指向数组的指针，切片和数组类型具有相同的元素类型。

此外，如果 `T` 或 `x` 的类型 `V` 是类型参数，如果满足以下条件之一，`x` 可以转换为类型 `T`：
- `V` 和 `T` 都是类型参数，并且 `V` 的类型集中的每个类型的值可以被转换为 `T` 的类型集中的每个类型。
- 只有 `V` 是类型参数，并且 `V` 的类型集中的每个类型的值可以被转换为 `T`。
- 只有 `T` 是类型参数，而 `x` 可以转换为 `T` 的类型集中的每个类型。

当为了转换的目的而比较结构类型的标识时，忽略结构标记：

```go
type Person struct {
	Name    string
	Address *struct {
		Street string
		City   string
	}
}

var data *struct {
	Name    string `json:"name"`
	Address *struct {
		Street string `json:"street"`
		City   string `json:"city"`
	} `json:"address"`
}

var person = (*Person)(data)  // ignoring tags, the underlying types are identical
```

特定的规则适用于数值类型之间或与字符串类型之间的（非常量）转换。这些转换可能会改变 `x` 的表示，并产生运行时成本。所有其他转换只改变类型，而不是 `x` 的表示。没有语言机制可以在指针和整数之间进行转换。包 *`unsafe`* 在受限环境下实现此功能。

> **数值类型之间的转换**

对于非常量数值的转换，以下规则适用：
- 在整数类型之间转换时，如果值是有符号整数，则将其符号扩展为隐式无限精度；否则将其零扩展。然后将其截断以适合结果类型的大小。例如，如果 `v := uint16(0x10F0)`，则 `uint32(int8(v)) == 0xFFFFFFF0`。转换总是产生一个有效的值；没有溢出的迹象。
- 当将浮点数转换为整数时，小数将被丢弃（向零截断）。
- 将整数或浮点数转换为浮点类型，或将复数转换为另一个复数类型时，结果值将舍入到目标类型指定的精度。例如，类型 `float32` 的变量 `x` 的值可以使用超过 IEEE-754 32 位数的精度的附加精度来存储，但是 `float32(x)` 表示将 `x` 的值舍入到 32 位精度的结果。类似地，`x + 0.1` 可以使用超过 32 位的精度，但是 `float32(x + 0.1)` 不使用。

在所有涉及浮点或复数值的非常量转换中，如果结果类型不能表示值，则转换成功，但结果值依赖于实现。

> **与字符串之间的转换**

将字节切片转换为字符串类型会产生一个字符串，其连续字节是该切片的元素。

```go
string([]byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'})   // "hellø"
string([]byte{})                                     // ""
string([]byte(nil))                                  // ""

type bytes []byte
string(bytes{'h', 'e', 'l', 'l', '\xc3', '\xb8'})    // "hellø"

type myByte byte
string([]myByte{'w', 'o', 'r', 'l', 'd', '!'})       // "world!"
myString([]myByte{'\xf0', '\x9f', '\x8c', '\x8d'})   // "🌍"
```

将字符切片转换为字符串类型将生成一个字符串，该字符串是转换为字符串的各个字符值的拼接。

```go
string([]rune{0x767d, 0x9d6c, 0x7fd4})   // "\u767d\u9d6c\u7fd4" == "白鵬翔"
string([]rune{})                         // ""
string([]rune(nil))                      // ""

type runes []rune
string(runes{0x767d, 0x9d6c, 0x7fd4})    // "\u767d\u9d6c\u7fd4" == "白鵬翔"

type myRune rune
string([]myRune{0x266b, 0x266c})         // "\u266b\u266c" == "♫♬"
myString([]myRune{0x1f30e})              // "\U0001f30e" == "🌎"
```

将字符串类型的值转换为字节类型的切片会产生一个非空切片，其连续元素是字符串的字节。

```go
[]byte("hellø")             // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
[]byte("")                  // []byte{}

bytes("hellø")              // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}

[]myByte("world!")          // []myByte{'w', 'o', 'r', 'l', 'd', '!'}
[]myByte(myString("🌏"))    // []myByte{'\xf0', '\x9f', '\x8c', '\x8f'}
```

将字符串类型的值转换为字符类型的切片会生成包含字符串的各个 Unicode 码位的切片。

```go
[]rune(myString("白鵬翔"))   // []rune{0x767d, 0x9d6c, 0x7fd4}
[]rune("")                   // []rune{}

runes("白鵬翔")              // []rune{0x767d, 0x9d6c, 0x7fd4}

[]myRune("♫♬")              // []myRune{0x266b, 0x266c}
[]myRune(myString("🌐"))    // []myRune{0x1f310}
```

由于历史原因，整数值可能会转换为字符串类型。这种形式的转换生成一个字符串，其中包含 Unicode 码位的 UTF-8 表示（可能是多字节）和给定的整数值。有效 Unicode 码位范围之外的值将转换为 "`\uFFFD`"。这种形式的转换最终可能会从语言中删除。go *vet* 工具将某些整数到字符串的转换标记为潜在错误。应该使用诸如 `utf8.AppendRune` 或 `utf8.EncodeRune` 之类的库函数。

```go
string('a')          // "a"
string(65)           // "A"
string('\xf8')       // "\u00f8" == "ø" == "\xc3\xb8"
string(-1)           // "\ufffd" == "\xef\xbf\xbd"

type myString string
myString('\u65e5')   // "\u65e5" == "日" == "\xe6\x97\xa5"
```


> **从切片到数组或数组指针的转换**

将切片转换为数组会产生一个数组，其中包含切片的基础数组的元素。类似地，将切片转换为数组指针会产生指向切片的底层数组的指针。在这两种情况下，如果切片的长度小于数组的长度，则会发生运行异常。

```go
s := make([]byte, 2, 4)

a0 := [0]byte(s)
a1 := [1]byte(s[1:])     // a1[0] == s[1]
a2 := [2]byte(s)         // a2[0] == s[0]
a4 := [4]byte(s)         // panics: len([4]byte) > len(s)

s0 := (*[0]byte)(s)      // s0 != nil
s1 := (*[1]byte)(s[1:])  // &s1[0] == &s[1]
s2 := (*[2]byte)(s)      // &s2[0] == &s[0]
s4 := (*[4]byte)(s)      // panics: len([4]byte) > len(s)

var t []string
t0 := [0]string(t)       // ok for nil slice t
t1 := (*[0]string)(t)    // t1 == nil
t2 := (*[1]string)(t)    // panics: len([1]string) > len(t)

u := make([]byte, 0)
u0 := (*[0]byte)(u)      // u0 != nil
```

>---
#### 14.10. 求值顺序

在包级别，初始化依赖项确定变量声明中各个初始化表达式的计算顺序。否则，在计算表达式、赋值或返回语句的操作数时，所有函数调用、方法调用、接收操作和二元逻辑操作都将按词法从左到右的顺序进行计算。例如，在（function-local）赋值中

```go
y[f()], ok = g(z || h(), i()+x[j()], <-c), k()
```

函数调用和通信按顺序 `f()`、`h()`（如果 `z` 计算为 `false`）、`i()`、`j()`、`<-c`、`g()` 和 `k()` 发生。然而，与 `x` 的求值和索引以及 `y` 和 `z` 的求值相比，这些事件的顺序没有被指定，除非在词汇上需要。例如，在计算其参数之前，不能调用 `g`。

```go
a := 1
f := func() int { a++; return a }
x := []int{a, f()}            // x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified
m := map[int]int{a: 1, a: 2}  // m may be {2: 1} or {2: 2}: evaluation order between the two map assignments is not specified
n := map[int]int{a: f()}      // n may be {2: 3} or {3: 3}: evaluation order between the key and the value is not specified
```

在包级别，初始化依赖项会覆盖各个初始化表达式的从左到右规则，但不会覆盖每个表达式中的操作数。函数调用的顺序是 `u()`、`sqr()`、`v()`、`f()`、`v()` 和 `g()`。

```go
var a, b, c = f() + v(), g(), sqr(u()) + v()

func f() int        { return c }
func g() int        { return a }
func sqr(x int) int { return x*x }

// functions u and v are independent of all other variables and functions
```


单个表达式中的浮点运算根据运算符的结合性进行计算。显式括号通过覆盖默认关联性来影响计算。在表达式 `x + (y + z)` 中，在添加 `x` 之前执行添加 `y + z`。

---
### 15. 语句
#### 15.1. 空语句

```go
for{
}
```

>---
#### 15.2. 标签语句

带标签语句可以是 `goto`、`break` 或 `continue` 语句的目标。

```go
func foo(){
    // ...
Error:    // 标签
    log.Panic("error encountered")
    // ...
}
```

>---
#### 15.3. 发送语句

*send* (`<-`) 语句在通道上发送一个值。

```go
var ch = make(chan<- int)
ch <- 3 // send value 3 to channel ch
```

>---
#### 15.4. IncDec 语句

```go
IncDec statement    Assignment
----------------------------------
x++                 x += 1
x--                 x -= 1
```

>--- 
#### 15.5. 赋值语句


```GO
assign_op  	   =
add_assign_op  +=  -=  |=  ^= 
mul_assign_op  *=  /=  %=  <<= >>=  &=  &^= 
-----------------------------------------------
x = 1
*p = f()
a[i] = 23
(k) = <-ch 
_ = g()      // 弃用
```

多值赋值将表达式结果的各个元素赋值给变量列表。分配是按从左到右的顺序进行的。

```go
x, y = f()
a, b = b, a  // exchange a and b

x := []int{1, 2, 3}
i := 0
i, x[i] = 1, 2  // set i = 1, x[0] = 2

i = 0
x[i], i = 2, 1  // set x[0] = 2, i = 1

type Point struct { x, y int }
var p *Point
x[2], p.x = 6, 7  // set x[2] = 6, then panic setting p.x = 7
```

>---
#### 15.6. If 语句

```go
if [ SimpleStmt; ]? Expression { 
	Block 
} [ else ( IfStmt | Block ) ]?
```
```go
if x > max {
	x = max
}

if x := f(); x < y {
	return x
} else if x > z {
	return z
} else {
	return y
}
```

>---
#### 15.7. Switch 语句
 
`Switch` 语句提供多路执行，`case` 不会贯穿，`default` 表示默认支路，分支块末尾的 `fallthrough`（可选）表示贯穿以指示控制贯穿流向下一个分支块的第一个语句。有两种形式：*ExprSwitch* 和 *TypeSwitch*。

> **Expression switch**

在 *ExprSwitch* 中，求值 `switch` 表达式。`nil` 不能作为 `case` 的检查条件。若缺失 `ExprSwitchGuard` 则默认为 `true`。

```go
switch [ SimpleStmt; ]? ExprSwitchGuard? {
	case Expr | default :
		StatementList 
} 
```
```go
switch tag {
	case 0, 1, 2, 3: s1()
	case 4, 5, 6, 7: 
		s2()
		fallthrough	
	default: s3()
}

switch x := f(); {  // missing switch expression means "true"
	case x < 0: return -x
	default: return x
}

switch {
	case x < y: f1()
	case x < z: f2()
	case x == 4: f3()
}
```

> **Type** **switch**

*TypeSwitch* 比较类型。它由一个特殊的 `switch` 表达式标记，该表达式具有使用关键字 `type` 而不是实际类型的类型断言的形式 `x.(type)`。`case T` 将实际类型 `T` 与表达式 `x` 的动态类型进行匹配。`x` 必须是接口类型，并且每个分支的 `T` 必须实现 `x` 或是 `nil`。

```go
switch [ SimpleStmt; ]? TypeSwitchGuard.(type) { 
	case TypeList | default : 
		 StatementList
}  
```

给定类型为 `interface{}` 的表达式 `x`，以下 *TypeSwitch*：

```go
switch i := x.(type) {
	case nil:
		printString("x is nil")                // type of i is type of x (interface{})
	case int:
		printInt(i)                            // type of i is int
	case float64:
		printFloat64(i)                        // type of i is float64
	case func(int) float64:
		printFunction(i)                       // type of i is func(int) float64
	case bool, string:
		printString("type is bool or string")  // type of i is type of x (interface{})
	default:
		printString("don't know the type")     // type of i is type of x (interface{})
}
```

类型参数或泛型类型可以用作 `case` 中的类型。泛型实例化后存在重复 `case` 分支时以首次匹配，该类型与 `switch` 中的另一个项重复，则选择第一个匹配的 `case`。*TypeSwitch* 中不支持 “`fallthrough`”。

```go
func f[P any](x any) int {
	switch x.(type) {
	case P:
		return 0
	case string:
		return 1
	case []P:		// 首次匹配
		return 2			
	case []byte:
		return 3
	default:
		return 4
	}
}

var v1 = f[string]("foo")   // v1 == 0
var v2 = f[byte]([]byte{})  // v2 == 2
```


>---
#### 15.8. For 语句

迭代 “`for`” 语句有三种形式：迭代可以由单条件、“`for`” 子句或 “`range`” 子句控制。

```go
for [ ConditionExpr | ForClause | RangeClause ]? {
	Block
} 
```

> **单条件控制**

```go
for ConditionExpr? { 
	Block
}
for {  // ConditionExpr = true
	Block
}
```

>  **For 子句控制**


```go
ForClause = [ InitStmt ]? ; [ Condition ]? ; [ PostStmt ]? 
for [ InitStmt ]? ; [ Condition ]? ; [ PostStmt ]? {
	Block
} 

for i := 0; i < 10; i++ {
	foo(i)
}
```

> Range 子句控制

“`for-range`” 迭代数组、切片、映射、字符串逐字符、通道上接收值、或从零到上限的整数值。

```go
RangeClause = [ ExpressionList "=" | IdentifierList ":=" ]? range RangeExpr
for [ ExpressionList "=" | IdentifierList ":=" ]? range RangeExpr  {
	Block
}
```

*RangeExpr* 的核心类型必须是数组、数组指针、切片、字符串、映射、接收通道、整数。左边的操作数（可选）必须是左值，它们表示迭代变量。如果范围表达式是通道或整数，最多允许一个迭代变量，否则最多可以有两个。对于每次迭代，它将迭代值分配给相应的迭代变量（如果存在），然后执行 *Block*。

```go
for [index, elem :=]? range array,slice,*parray
for [index, rune :=]? range string
for [key, value  :=]? range map
for [elem 	     :=]? range chan, <-chan
for [i 			 :=]? range integer
```

- 对于数组、数组指针或切片 `a`，索引从索引从 `0` 到 `len(a)-1` 顺次返回 `elem`。对于 `nil` 切片，迭代次数为 0。
- 对于字符串 `s`，“`range`” 子句从索引 `0` 开始顺次返回完整 Unicode 码位字符 `rune`。无效码位则返回 0xFFFD。
- 映射的迭代顺序没有指定，不能保证每次迭代都能产生相同的结果。如果在迭代中删除了尚未到达的映射项，则不会产生相应的迭代值；如果映射项是在迭代期间创建的，则该项可以在迭代期间产生或者被跳过。如果映射为 `nil`，则迭代次数为 0。
- 对于通道，产生的迭代值是在通道上接收的连续值，直到通道关闭。如果通道为 `nil`，则 `range` 将永远阻塞。
- 对于整数值 n ，迭代值 `0` 到 `n-1` 按递增顺序产生。`n <= 0` 不迭代。

```go
var testdata *struct {
	a *[7]int
}
for i, _ := range testdata.a {
	// testdata.a is never evaluated; len(testdata.a) is constant
	// i ranges from 0 to 6
	f(i)
}

var a [10]string
for i, s := range a { 
	g(i, s)
}

m := map[string]int{"mon":0, "tue":1, "wed":2, "thu":3, "fri":4, "sat":5, "sun":6}
for key, val := range m {
	h(key, val)
}

var ch chan Work = producer()
for w := range ch {
	doWork(w)
}

for range ch {}	// empty a channel

for i := range 10 {
	// call f(0), f(1), ... f(9)
	f(i)
}
```

>---
#### 15.9. Go 语句

“`go Expr`” 开启一个独立的并发控制线程或 *goroutine* 以执行函数调用。表达式 `Expr` 必须是函数或方法调用。函数值和参数在当前 *goroutine* 中进行计算，且不会等待被调用函数完成。相反，被调用函数在一个新的 *goroutine* 中独立执行；当函数终止时，它的执行 *goroutine* 也终止；函数的任何返回值在函数完成时被丢弃。

```go
go Server()
go func(ch chan<- bool) { 
	for { 
		sleep(10)
		ch <- true 
	}
} (c)
```

>--- 
#### 15.10. Select 语句

`select` 语句检查一组正在等待发送或接收中的某个 `case` 通道分支：
- 当某个通道未被阻塞时，`select` 执行该 `case chan` 或 `default`。
- 如果一个或多个通信可以进行，则经由统一的伪随机选择来选择可以进行的单个通信。
- 否则，如果存在 `default`，则选择该分支。如果没有 `default`，则 `select` 语句阻塞，直到至少有一个通信可以继续。、
- 由于 `nil` 通道上的通信永远无法继续，因此仅有 `case nilchan` 分支且没有 `default` 的 `select` 将永远阻塞。

```go
select {
	[case ( SendStmt | RecvStmt )]* | default? : 
		StatementList
}
// RecvStmt 的通道接收操作结果可以分配给一或两个变量。
case v1, ok := (<-ch)
```
```go
var a []int
var c, c1, c2, c3, c4 chan int
var i1, i2 int
select {
	case i1 = <-c1:
		print("received ", i1, " from c1\n")
	case c2 <- i2:
		print("sent ", i2, " to c2\n")
	case i3, ok := (<-c3):  // same as: i3, ok := <-c3
		if ok {
			print("received ", i3, " from c3\n")
		} else {
			print("c3 is closed\n")
		}
	case a[f()] = <-c4:
		// same as
		// 	 case t := <-c4:
		//	 	a[f()] = t
	default:
		print("no communication\n")
}

for {  // send random sequence of bits to c
	select {
		case c <- 0:  // note: no statement, no fallthrough, no folding of cases
		case c <- 1:
	}
}

select {}  // block forever
```

>--- 
#### 15.11. Return 语句

`return`” 语句终止函数或方法的执行，并根据函数返回类型可选地提供一个或多个结果值。任何延迟函数都会在函数返回前执行。

```go
return [ ExpressionList ]?
```

有三种方法可以从具有结果类型的函数返回值：
1. 返回值在 “`return`” 语句中显式列出。

	```go
	func simpleF() int {
		return 2
	}

	func complexF1() (re float64, im float64) {
		return -7.0, -4.0
	}
	```

2. “`return`” 可以是对多值函数的单个调用。

	```go
	func complexF2() (re float64, im float64) {
		return complexF1()
	}
	```

3. 函数提供了结果参数名称并在函数返回前赋值，则 `return` 可能为空。

	```go
	func complexF3() (re float64, im float64) {
		re = 7.0
		im = 4.0
		return
	}

	func (devnull) Write(p []byte) (n int, _ error) {
		n = len(p)
		return
	}
	```

不管它们是如何声明的，所有的结果值在进入函数时都被初始化为它们的类型的零值。指定结果 “`return`” 在执行任何延迟函数之前设置结果参数。

```go
func Foo() int {
	var i = 10
	defer func() {
		i++
	}()
	return i  
}
rt = Foo()    // 10
```

>---
#### 15.12. Break 语句

“`break`” 语句用于终止最内层或指定标签的外层 “`for`”、“`switch`” 或 “`select`” 语句的执行。

```go
break [ Label ]? 

OuterLoop:
	for i = 0; i < n; i++ {
	InterLoop:
		for j = 0; j < m; j++ {
			switch a[i][j] {
			case nil:
				state = Error
				break   // break switch
			case item:
				state = Found
				break OuterLoop  // break OuterLoop for
			}
		}
	}
```

>---
#### 15.13. Continue 语句

“`continue`” 语句通过将控制推进最内层 `for Block` 的末尾来开始下一次迭代。如果有标签，它必须是一个封闭的 “`for`” 语句的标签。

```go
continue [ Label ]? 

RowLoop:
	for y, row := range rows {
		for x, data := range row {
			if data == endOfRow {
				continue RowLoop
			}
			row[x] = data + bias(x, y)
		}
	}
```

>---
#### 15.14. Goto 语句

“`goto`” 语句将控制转移到同一函数体中声明的非内层块标签处。

```go
{
	// ...
	goto Error 
	// ...
Error: 
	statement?
}
```

>---
#### 15.15. Defer 延迟语句

“`defer`” 语句调用一个函数。延迟函数的参数在触发延迟时进行计算，而不是在调用时计算。所有的延迟函数在包围函数返回之前或包围函数异常时立即被调用，与它们延迟的顺序相反。

```go
defer Expression 

lock(l)
defer unlock(l)  // unlocking happens before surrounding function returns

// prints 4 3 2 1 0 before surrounding function returns
for i := 0; i < 5; i++ {
	defer fmt.Printf("%d ", i)  // 4 3 2 1 0 
}
```

如果包围函数通过 `return` 返回，则延迟函数将在该 `return` 语句设置任何结果参数之后，在函数返回前执行。如果一个延迟的函数值计算为 `nil`，则在调用函数时执行会发生异常，而不是在执行 `defer` 语句时。

```go
func(i, j int) {
	defer func(i, j int) {
		println(i, j)
	}(i, j)
	i++
	j++
}(1,2)   // print: 1 2
```

如果延迟函数是函数文本，且包围函数具有结果参数，则延迟函数可以在返回结果参数之前访问和修改结果参数。

```go
// f returns 42
func f() (result int) {
	defer func() {
		// result is accessed after it was set to 6 by the return statement
		result *= 7
	}()
	return 6
}
```

`defer` 应用的典型例子是解锁互斥锁或关闭文件。

```go
// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
```

---
### 16. Error 与 Run-time Panic

库例程必须经常向调用者返回某种错误指示。函数在返回结果值时可以同时返回某种详细的错误描述。例如，`os.Open` 在失败时不仅返回一个 `nil` 指针，它还返回一个描述错误的错误值。描述错误的接口类型为 `error`。

```go
type error interface {
	Error() string
}
```

预定义类型 `error` 表示错误条件的常规接口，返回 `nil` 值表示没有错误。例如可以定义一个从文件中读取数据的函数：

```go
func Read(f* File, b []byte) (n int, err error)
```

在可行的情况下，错误字符串应该标识它们的来源，例如通过使用一个前缀来命名生成错误的操作或包。例如，在包 `image` 中，由于未知格式导致的解码错误的字符串表示是 “`image：unknown format`”。关心精确错误细节的调用方可以使用 *TypeSwitch* 或类型断言来查找特定错误并提取细节。

```go
for try := 0; try < 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
	// 类型断言
    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
```

执行错误（如试图将数组索引到边界之外）会触发一个运行时异常，相当于使用实现定义的接口类型 `runtime.Error` 的值调用内置函数 `panic`。该类型满足预先声明的接口类型 `error`。未指定表示不同运行时错误条件的确切错误值。

```go
package runtime

type Error interface{
	error
	// and perhaps other methods
}
```

函数通常在最后的返回值中返回错误信息。使用 `errors.New` 可返回一个错误信息：

```go
func Sqrt(f float64) (float64, error) {
    if f < 0 {
        return 0, errors.New("math: square root of negative number")
    }
    // ...
}
```

调用 `Sqrt` 的时候传递的一个负数，然后就得到了 `non-nil` 的 `error` 对象，将此对象与 `nil` 比较，结果为 `true`，`fmt.Println` 函数在处理 `error` 时会调用 `Error` 方法，以输出错误信息：

```go
result, err:= Sqrt(-1)
if err != nil {
   fmt.Println(err)  // math: square root of negative number
}
```

>---
#### 16.1. Panic

向调用方报告错误的常用方法是返回一个 `error` 作为额外的返回值。与之不同的是，内置函数 `panic`，会创建一个运行时错误，从而停止程序。该函数接受一个任意类型的参数（通常是一个字符串），并在程序结束时打印出来。

```go
// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
    z := x/3   // Arbitrary initial value
    for i := 0; i < 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // A million iterations has not converged; something is wrong.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
```

实际的库函数应该避免 `panic`。一个可能的反例是在初始化过程中：如果库真的无法设置自己，那么 `panic` 是合理的。

```go
var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}
```

>---
#### 16.2. Recover

当 `panic` 被调用时，包括隐式的运行时错误，比如索引一个切片越界或类型断言失败，它会立即停止执行当前函数，并开始展开 *goroutine* 的堆栈，同时运行任何延迟的函数。如果展开到达了 *goroutine* 堆栈的顶部，程序就会终止。但是，可以使用内置函数 `recover` 重新获得对 *goroutine* 的控制并恢复正常执行。

对 `recover` 的调用会停堆栈展开并返回传递给 `panic` 的参数。在堆栈展开时可运行的唯一代码是在延迟函数中，所以 `recover` 只在延迟函数中有用。在下面例子中，如果 `do(work)` 出现异常，结果将被记录，*goroutine* 将干净地退出，而不会干扰其他程序。在延迟闭包中不需要做任何其他事情；调用 `recover` 可以完全处理这种情况。
```go
func server(workChan <-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
```

除非从延迟函数直接调用，否则 `recover` 总是返回 `nil`。有了 `recover` 模式，`do` 函数（以及它调用的任何东西）都可以通过调用 `panic` 来干净地摆脱任何糟糕的情况。可以用这个想法来简化复杂软件中的错误处理，例如一个理想化的 `regexp` 包，它通过使用本地 `Error` 类型调用 `panic` 来报告解析错误。下面是 `Error` 的定义、`error` 方法和 `Compile` 函数。

```go
// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}
```

>---
#### 16.3. 自定义 Error

可以在编码中通过实现 `error` 接口类型自定义实现错误处理程序。

```go
type errno struct {
	code    int
	message string
}

var (
	errFormat string = `
	Error code = %d
	Message >>>> %s
`
	GO_ERR_001 = errno{1, "TMP_GO_ERR_001"}
	GO_ERR_002 = errno{2, "TMP_GO_ERR_002"}
	GO_ERR_003 = errno{3, "TMP_GO_ERR_003"}
	GO_ERR_004 = errno{4, "TMP_GO_ERR_004"}
)
// 实现 error 接口
func (e errno) Error() string {   
	return fmt.Sprintf(errFormat, e.code, e.message)
}

func Test(b bool) (e error) {
	if !b {
		e = GO_ERR_001
	}
	return
}

func main() {
	err := Test(false)
	if err != nil {
		fmt.Print(err)
	}
/*
        Error code = 1
        Message >>>> TMP_GO_ERR_001
*/
}
```

---