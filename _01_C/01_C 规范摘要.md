## C 语法规范摘要

### 1. 基本概念

#### 1.1. 程序结构

范围（作用域）分为 全局范围、文件范围、函数范围、块范围。存储期（生存期）分为静态、线程、自动或动态存储期。链接描述可见性，`extern` 声明外部链接、`static` 声明内部链接。

```c
// 文件范围
#include <stdio.h>
static char* Hi = "Hello C!";   // 静态存储，内部链接
int main(void)  // 函数范围
{
	char* start = Hi;  // 自动存储期
	while (*start)
	{  // 块范围
		printf("%c", *start);
		start++;
	}
	return 0;
}
```

> 程序入口函数 *main*：

```c
int/void main(void);
int/void main(int argc, char *argv[] <, char *envp[]>?);
int/void wmain(int argc, wchar_t *argv[], wchar_t *envp[]);   // 宽字符版本
/*
argc 命令行实参数量，至少为 1；
argv 包含 argc+1 个指针，argv[0] 是程序名称
return 隐式调用 exit(int rtCode)
*/ 
```

>---
#### 1.2. 词法元素

> **标准关键字**

| token                                        | description              |
| :------------------------------------------- | :----------------------- |
| `auto`                                       | 类型推断                 |
| `typedef`                                    | 别名声明                 |
| `const`,`volatile`                           | CV 限定                  |
| `_Atomic`,`register`,`thread_local`,`static` | 存储类说明符             |
| `extern`,`static`                            | 链接声明                 |
| `restrict`                                   | 指针约束声明             |
| `inline`                                     | 内联函数声明             |
| `signed`,`unsigned`                          | 整数符号限定             |
| `bool`,`false`,`true`                        | 布尔类型                 |
| `nullptr`                                    | 空指针常量               |
| `char`,`short`,`int`,`long`,`float`,`double` | 数值类型声明             |
| `void`                                       | 无类型                   |
| `enum`,`struct`,`union`                      | 复合类型                 |
| `if`,`else`,`switch`,`case`,`default`        | 条件语句                 |
| `do`,`while`,`for`                           | 迭代语句                 |
| `break`,`continue`,`return`,`goto`           | 跳转语句                 |
| `constexpr`                                  | 常量表达式               |
| `alignas`,`alignof`                          | 类型对齐                 |
| `sizeof`                                     | 计算类型或变量所占字节数 |
| `typeof`,`typeof_unqual`                     | 反射                     |
| `static_assert`                              | 静态断言                 |
| `_Generic`                                   | 泛型宏                   |
| `_Imaginary`,`_Complex`                      | 复数                     |
| `_BitInt`                                    | 位精确整数               |
| `_Decimal32`,`_Decimal64`,`_Decimal128`      | 十进制浮点数             |

> **运算符**

```c
[    ]    (    )    {    }    .    ->
++   --   &    *    +    -    ~    !
/    %    <<   >>   <    >    <=   =>   ==   !=   ^    |    &&   ||
?    :    ::   ;    ...
=    *=   /=   %=   +=   -=   <<=  >>=  &=   ^=   |=
,    #    ##
```

---
### 2. 类型和声明

#### 2.1. 基本类型

| 类型                                              | 描述                             |
| :------------------------------------------------ | :------------------------------- |
| `void`                                            | 无类型                           |
| `bool`                                            | 布尔，`true` 和 `false`          |
| `nullptr_t`                                       | 空指针常量类型，具有值 `nullptr` |
| `char`,`wchar_t`                                  | 字符                             |
| `[signed]/unsigned char/short/int/long/long long` | 整数                             |
| `[signed]/unsigned _BitInt(N)`                    | 定宽整数                         |
| `float`,`double`,`long double`                    | IEEE-784 浮点数                  |
| `_Decimal32`,`_Decimal64`,`Decimal128`            | 十进制浮点数                     |
| `_Complex`,`_Imaginary`                           | 复数                             |

> **字符字面值**

字符值可以是单或多字节序列。多字节无法表示宽字符。

```c
// 字面值
char c = 'A';      
int mc = '123';         // 多字节
wchar_t wc = L'A';      // 宽字符
char8_t c8 = u8'A';     // UTF-8
char16_t c16 = u'A';    // UTF-16
char32_t c32 = U'A';    // UTF-32
// 转义字符
char oct = '\64';       // \ oo     八进制，最大 \377
char hex = '\xff';      // \x hh    十六进制转义序列
char uni = '\u00f4';    // \u hhhh  
char Uni = '\U000000F4' // \U HHHHHHHH
'\'' '\"' '\?' '\\' '\a' '\b' '\f' '\n' '\r' '\t' '\v'
```

> **整数字面值**

```c
// 后缀
0u,0U    		// 无符号整数
0l,0L    		// long      
0ll,0LL  		// long long 
0wb,0WB  		// _BitInt(N), 宽度 N 是大于 1 的可以容纳值和符号位的最小值 |
// 不同进制表示
0b1010'0101            // 二进制
076543210              // 八进制
0xabcdef               // 十六进制 
0XABCDEF'01234'56789   // 十六进制 
```

> **浮点数字面值**

```c
// 后缀
0.0f,0.0F       // float
0.0l,0.0L  		// long double
0.0df,0.0DF		// _Decimal32
0.0dd,0.0DD		// _Decimal64  
0.0dl,0.0DL		// _Decimal128
// 计数法
0x1.ap-132;    // P 十六进制计数法, double
3.14e15F;      // E 十进制计数法, float
```

> IEEE-784 浮点数定义

一个浮点数由以下模型定义，ISO/IEC 60559 格式：


- $x = sb^e \sum_{k =1}^p f_k b^{-k}$，$e_{min} \leq e \leq e_{max}$
  - $s$：符号位（$\pm 1$）
  - $b$：指数表示的基数（大于 1 的整数）
  - $e$：指数（介于最小 $e_{min}$ 和 $e_{max}$ 之间的整数）
  - $p$：精度（以 $b$ 为基数的有效位数）
  - $f_k$：小于 $b$ 的非负整数（有效位数）



>---
#### 2.2. Enum 枚举

枚举由一组命名整数常量构成，支持自增自减。

```c
enum DAY {     // : int
    saturday, // 0
    sunday = 0,
    monday,  // 1
    tuesday, // 2
    wednesday,
    thursday,
    friday
} workday = monday;
// 指定类型的枚举：
enum Month : unsigned char {
    Jan = 1, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec
}
```

>---
#### 2.4. Struct 结构

结构描述一个组织布局，可以嵌套结构或联合。

```c
struct book {
	const char* Name;
	int price;
	struct inner {  // 嵌套结构
		int cost;
	};
};
struct book mBook1 = { "C Language", 20, 99 };
struct book mBook2 = { .Name = "C Language", .cost = 20, .price = 99 };

struct {    // 匿名结构
	const char* Name;
	int cost;
} mBook3 = { .Name = "C Language", .cost = 20, };
```

> **结构成员的填充与对齐**

结构成员按其声明顺序从低到高存储。
- 结构体的对齐步骤：结构体各成员对齐 -> 结构体总体对齐。
- 结构体对齐规则：首成员位于结构偏移量 0 的地址。其他成员对齐为 *min { 自身对齐，对齐系数 }* 的最小整数倍的地址处。总体对齐时，结构体字节大小为 *min { 成员最大自身对齐，对齐系数 }* 的整数倍。
- 对齐系数：宏 `#pragma pack(N)` 指定的值，N 是 2 的幂次方，1、2、4 等。0 表示本机默认对齐。

```c
// 64 位 Linux，默认系数为 8
struct {
	char a;	 // 1
	short b; // 2
	int c;	 // 4
} s1;
printf("%zd\n", sizeof(s1)); // size = 8

struct {
	char a;	 // 地址位 0
	int c;	 // 地址位 4
	short b; // 地址位 8
} s2;
printf("%zd\n", sizeof(s2)); // size = 12
```

`#pragma pack(N)` 设置对齐，`#pragma unpack()` 取消对齐。

```c
#pragma pack(1)    // 对齐遵循始终寻址为 1 的倍数的地址
struct {
 	char    a;     // 地址位 0
	int     c;     // 地址位 1
	short   b;     // 地址位 5
} s3;      // 根据对齐规则，总体的结构体大小为 7
printf("%zd\n", sizeof(s3)); // 7
#pragma unpack()   // 恢复系统默认的对齐特性
```

>---
#### 2.5. Union 联合

联合的所有成员共享单个存储空间，大小与最大成员相同。

```c
union sign
{
    int svar;
    unsigned uvar;
};	// size = 4
union sign digit = {99}; 	    // 初始化首元
union sign val = {.uvar = 100};	// 指定成员

// 具有位域的联合
union{ 		
	unsigned int a:1;
	unsigned int b:4;
	int value;
} BitUnion;	// size = 4

// 联合常嵌套在一个结构中
struct x
{
    int type_tag;
    union
    {
      int x;
      float y;
    };
};
```

>---
#### 2.6. Bit Domain 位域

结构或联合可包含位域，位字段基础类型是 `bool`、`int`、`char`、`short`，位字段不能越界。匿名字段表示填充，0 值匿名字段强制下一个位字段与下一个整数边界对齐。

```c
struct {				  // offset
	unsigned int f0;  		// 0
	unsigned int f1 : 8 ;	// 8 
	unsigned int : 2 ;      // 2 位的填充
	unsigned int f2 : 4 ;   // 10
	unsigned int : 0 ;      // 迫使下一个位字段与 int 边界对齐
	unsigned int f3 : 2 ;   // 16
} Bits;
printf("%zd", sizeof(Bits));  // 12
```

>---
#### 2.7. Pointer 指针

可以为任何基本类型、结构或联合类型、函数、数组和其他指针对象创建关联指针（除位域、寄存器变量）。`void*` 表示无类型指针。

```c
struct book{
	int cost;
} bp;
struct book * pbook = &bp;
pbook->cost = 99;		// -> 访问结构成员
pbook->cost = (*pbook).cost = bp.cost
```

数组标识被视为指向数组首元的指针，`arr = &arr[0]`，`arr[n] = *(arr+n)`，`&arr[n+1] = &arr[n]+1`。

```c
int arr[10] = {99};
int *pArr = arr;  // 等价于 &arr[0];

// 指向多维数组的指针
int marr[2][3] = {		// 二维数组
	{1,2,3},
	{2,3,4}
};
int(*p1)[3] = marr;   			 // p1 指向二维数组
int* p2[2] = { arr, marr[1] };	 // p2 是一个包含两个指针元素的数组

for (size_t i = 0; i < 2; i++) {
	printf("%p\n", pr1[i]);
	printf("%p\n", pr2[i]);
}
```

>---
#### 2.3. Array 数组

数组被视为指向数组首元的指针。无零长数组，试探性声明视为具有一个数值为 0 的数组。

```c
int arr[]  = {1, 2, 3};              
int arr[5] = {0,1,2,3,4};           // 初始化器
int arr[5] = {[2] = 2};             // 指定初始化器，其他元素零初始化
int arr[5] = {};                    // 零初始化器
char Str[] = "This is a String";    // Str[17]
int *parr = arr;

// 多维数组
int mArr[3][3][3][3];
int mArr[4][4] = {
	{1,2,3,4},
    {10,20,30,40},
    {100,200,300,400},
    {0,0,0,0}
}
int mArr[2][3] = {[1][2] = 1};  
int mArr[2][3] = {};     
int mArr[2][3] = {1,2,3,4,5,6};  // 顺序初始化

// 试探性声明
int[] a;  // 暂认为是 a[] = {0}
```

函数参数 `T arr[static len]` 要求传入数组的长度至少为 `len`：

```c
int fun1(int a, int arr[static a]);
int fun2(int arr[restrict const static 5]);   // 传入的数组长度至少为 5
```

> **可变长度数组**

可以在函数域内声明或 `typedef` 定义可变长度数组（VLA），这类对象称为可变修改对象（VM）。VLA 无法限定为 `thread_local`、`static`、`extern`。指向 VLA 数组的指针声明可以是 `static`。

```c
int B[100];      // 固定长度               
void fvla(int m, int C[m][m])   // 参数 VLA
{
    typedef int VLA[m][m];      // VLA 定义
    int D[m];                   // auto VLA
    int(*s)[m];                 // pointer to VLA
    static int(*q)[m] = &B;     // static block pointer to VLA
}
```

> **灵活数组成员**

灵活数组成员可作为结构的最后一个成员，由分配函数分配数组所需的额外空间。

```c
struct flex {
	int count;
	double average;	   // 至少一个非灵活数组成员
	double scores[];   // 灵活数组
}
// 设置灵活数组长度为 5
struct flex * pf = (struct flex*)malloc(sizeof(struct flex) + 5 * sizeof(double));  
auto sz = sizeof(*pf);     // sizeof(int) + sizeof(double)
//...
free(pf);
```

>---
#### 2.8. String 字符串

窄 (宽) 字符串实际是具有 `char` (`wchar_t`) 的类型数组，`'\0'` (`L'\0'`) 自动追加到字符串末尾。编译器优化策略会将具有相同字符串值的单个副本置于可执行文件中。

```c
char *str1 = "Hello";
int main(void)
{
	char *str2 = "Hello";
	char str3[] = "Hello";
	printf("pStr1: %p\n", str1);
	printf("pStr2: %p\n", str2);
	printf("pStr3: %p\n", str3);

	char *hi = "Hello" " World"; // 拼接
}
/*
pStr1: 00007ff6ccc17000
pStr2: 00007ff6ccc17000
pStr3: 0000003c099ff8ea
*/
```

可以使用字符串文本初始化字符数组。指定数组长度小于字符串长度，则忽略多余字符。

```c
char s1[] = "abc";    // 等同于
char s1[]  = {'a', 'b', 'c', '\0'};

char s2[3] = "abcd";  // 等同于
char s2[3] = {'a', 'b', 'c'};
```


其他编码的字符串类型：

```c
char* s = "Hello";		   // C style string
wchar_t * ws = L"Hello";   // 宽字符串
char8_t* s8 = u8"Hello";   // UTF-8
char16_t * s16 = u"Hello"; // UTF-16
char32_t * s32 = U"Hello"; // UTF-32

// 多行   
char* mul = "Long strings can be bro\
ken into two or more pieces."   

// 不同编码类型的字符串拼接，要求前缀一致或无前缀
"a""b"L"c", "a"L"b""c", L"a""b"L"c", L"a"L"b"L"c" == L"abc"
```

>---
#### 2.9. 复杂声明解释

抽象声明符是指没有标识符的声明符，由一个或多个指针、数组或函数修饰符组成。

```c
int             // 整型
int *           // 指针
int *[3]        // 指向 int 的 3 个指针组成的数组
int (*)[5]      // 指向 5 个 int 类型数组的指针
int (*)[*]      // 指向未指定数目的 int 类型的可变长度数组的指针
int *()         // 一个不带参数的函数，返回一个指向 int 的指针
int (*)(void)   // 指向不带参数并返回 int 的函数的指针
int (*const []) (unsigned int, ...)  
// 指向函数的未指定数目的常量指针的数组，每个函数都有一个参数，其类型是 unsigned int 以及未指定数目的其他参数，并返回一个 int
```

复杂声明符是由多个数组、指针或函数修饰符限定的标识，可以将数组、指针和函数修饰符的各种组合应用于单个标识符。通常利用 `typedef` 来简化声明。在解释复杂声明时，方括号和圆括号（标识符右侧的修饰符）优先于星号（标识符左侧的修饰符）。方括号和圆括号具有相同的优先级并且都是从左到右关联。

解释复杂声明符的一般步骤：
1. 从标识符开始并直接查找方括号或圆括号（如果有）的右侧。
2. 解释这些方括号或圆括号，然后查找星号的左侧。
3. 如果在任何阶段遇到一个右圆括号，请返回并将规则 1 和 2 应用于圆括号内的所有内容。
4. 应用类型说明符。

```C
char *( *(*var)() )[10];
 ^   ^  ^ ^ ^   ^    ^
 7   6  4 2 1   3    5

/*
  1. 标识符 var 声明为
  2. 指向 (以下内容) 的指针
  3. 返回 (以下内容) 的函数
  4. 指向 (以下内容) 的指针
  5. 包含 10 个元素的数组，这些元素分别为 (以下内容)
  6. 指向 (以下内容) 的指针
  7. char

解释为: 标识符 var 声明为 (指向 (返回 (指向 (包含 10 个元素的数组，这些元素分别为 (指向 (char) 的指针) ) 的指针) 的函数) 的指针)
*/
```

> 复杂声明举例

```c
int *var[5];				// 声明为指向 int 的指针数组 
int (*var)[5];				// 声明为指向 int 数组的指针 
long *var(long, long);		// 声明为返回 long 指针的函数 
long (*var)(long, long);	// 声明为指向返回 long 的函数指针

struct both{	// 声明为指向返回结构 both 的函数的指针数组
    int a;
    char b;
} (*var[5])(struct both, struct both);
struct both *var[5](struct both, struct both);	// 非法：声明函数数组

// 声明为指向常量指针的指针的二维数组，这些常量指针指向返回 unsigned int* 的函数
unsigned int* (*const *name[5][10])(void);

// 声明为返回指向包含 3 个 double 数组指针的函数，其形参是指向包含 3 个 double 数组的指针
double (*var(double(*)[3]))[3];

union sign{     // 声明为指向指针的指针二维数组，这些指针指向具有两个成员的联合的指针
     int x;
     unsigned y;
} **var[5][5];
union sign *(*var[5])[5];   // 声明为一个五元素指针数组，数组元素指向联合的五元素指针数组
```

---
### 3. 类型说明

#### 3.1. 类型推断：auto

```c
static auto Hi = "Hello World";   // string
auto p = (struct {int x; } *)0;   // struct {int x;} * 
```

>---
#### 3.2. 常量表达式：constexpr

`constexpr` 常量表达式，编译时计算，文件范围内默认具有内部链接；类型不能是原子类型、VM 类型、`volatile`、`restrict` 限定。

```cpp
constexpr int tele = 10086;
constexpr int T = tele;
constexpr struct{ void *p; } A = { nullptr };
```

>---
#### 3.3. 链接：static, extern

`static` 声明内部链接，当前声明范围可见，具有静态存储期。`extern` 声明外部链接或外部引用。

```c
static int num;                 
void func(){
	static int local_num = num;     // 块范围，静态存储期
}

#include "some.h"
extern void foo(void);   // from some.h
```

>---
#### 3.4. 存储类：register, thread_local

`register` 声明寄存器局部变量。无法获取寄存器变量的地址。

```c
void Func(register int v){	     // 参数
    register int num = 1;        // 局部变量
}
```

`thread_local` 声明线程存储的 `static` 或 `extern` 线程对象，线程启动时初始化其线程独立副本。

```cpp
void funcThread(){
    thread_local static counter;  
}
```

>---
#### 3.5. 类型别名：typedef

`typedef <Type> <alias>` 声明类型别名。

```c
typedef void fv(int);     // 函数类型
typedef void (*pfv)(int); // 函数指针类型

void (*signal(int, void(*) (int)))(int);
// 相当于
fv* signal(int, fv*);     
pfv signal(int, pfv);     

typedef struct {     
	int count;
	float cost;
} book;                   // 匿名结构别名
typedef char* const ConstString;	// 指向常量字符串的指针类型
typedef const char* ConstpStr;		// 指向字符串的常量指针类型
```

`typedef` 在块范围内声明可变长度数组（VLA）。

```c
void F(int n){
    typedef int Array[n];	
    Array a; 				// a[n]
}
```

>---
#### 3.6. CV 限定：const, volatile

`const` 常量限定。非 `const` 指针能隐式转换兼容的 `const` 指针。

```c
// const int
const int ci;				
int const ci;
void func(int* const size);
void func(int[const size]);
// const *ptr, 值常量
int const *pci;        	
const int *pci;        	
// const ptr, 指针常量
int *const cpi;        
// const *(const ptr), 指向值常量的指针常量
const int* const cp_ci; 
```

`volatile` 易变限定，禁用编译器优化。`volatile` 声明结构 / 联合时成员也限定易变；`volatile` 声明数组时仅限定数组元素。

```c
volatile int vi;
void func(double x[volatile], const double y[volatile]);
void func(double * volatile x, const double * volatile y);
volatile int *pvi;
int *volatile vpi;
```

任何通过非 `volatile` 方式对易变对象尝试读写都会导致未定义行为。

```c
volatile int n = 10010; 

int* p = (int*)&n;
int val = *p;           // 未定义行为

volatile int* vp = &n;	// ok
*vp = 10086
```

>---
#### 3.7. 指针约束：restrict

`restrict` 用于限定指针，表明该指针是访问数据对象的唯一有效方式。

```c
void Func(int* restrict n);
void Func(int n[restrict]);
typedef void* vptr;	
typedef restrict vptr Rvptr;  // typedef restrict
// 用于函数形参，限定仅能从 restrict 指针访问数据
void test(int* restrict first, int* restrict second, int* val)
{
    *first += *val;
    *second += *val;
}
// 将 union 成员标记为 restrict 告诉编译器在任何作用域中只有 z.x 或 z.y 可被访问
union z
{
    int* restrict x;
    double* restrict y;
};
```

`restrict` 指针之间赋值的规则不区分函数调用和等效的嵌套块。只有在嵌套声明的受限指针 “外部到内部” 赋值才定义了行为。

```c
{
    int * restrict p1;
    int * restrict q1;
    p1 = q1; // undefined behavior
    {
        int * restrict p2 = p1; // valid
        int * restrict q2 = q1; // valid
        p1 = q2; // undefined behavior
        p2 = q2; // undefined behavior
    }
}
```

>---
#### 3.8. 原子限定：_Atomic

`_Atomic` 限定原子类型，类型不能是数组、函数、其他原子类型或限定类型。

```c
_Atomic type identifier
_Atomic(type) identifier

_Atomic int ai;
_Atomic const int *pcai;          
const _Atomic(int) *pcai;  
typedef _Atomic int atomic_int;  // typedef 和 _Atomic
```

> 原子类型解释说明：

原子类型的对象是仅有的免除数据竞争的对象。每个原子对象都拥有关联于其自身的修改顺序，对于所有原子运算，保证有四种连贯：写写连贯、读读连贯、读写连贯、写读连贯。

原子属性仅对左值表达式有意义。左值到右值转换会把原子性及其他限定符剥去。

```c
#include <stdio.h>
#include <threads.h>
#include <stdatomic.h>

atomic_int acnt;
int cnt;
int f(void* thr_data) {
    for(int n = 0; n < 1000; ++n) {
        ++cnt;
        ++acnt;
        // 对于此例，宽松内存顺序是足够的，例如
        // atomic_fetch_add_explicit(&acnt, 1, memory_order_relaxed);
    }
    return 0;
}

int main(void) {
    thrd_t thr[100];
    for(int n = 0; n < 100; ++n)
        thrd_create(&thr[n], f, NULL);
    for(int n = 0; n < 100; ++n)
        thrd_join(thr[n], NULL);

    printf("The atomic counter is %u\n", acnt);
    printf("The non-atomic counter is %u\n", cnt);
}
/* 可能的输出
	The atomic counter is 100000
	The non-atomic counter is 98658
*/
```

---
### 4. 表达式

> **运算符与优先级**

| **Category** | **Operator**                                                                                         |
| :----------- | :--------------------------------------------------------------------------------------------------- |
| 基本表达式   | `x[y]`,`x.y`,`x->y`,`f(x)`,`a[x]`                                                                    |
| 一元         | `+x`,`-x`,`!x`,`&x`,`*p`,`~x`,`sizeof`,`alignof`,`typeof`                                            |
| 递增递减     | `++x`,`--x`,`x++`,`x--`                                                                              |
| 强制转换     | `(type)value`                                                                                        |
| 乘法         | `x * y`,`x / y`,`x % y`                                                                              |          |
| 加法         | `x + y`,`x - y`                                                                                      |
| 移位         | `x << y`, `x >> y`                                                                                   |
| 关系         | `x > y`,`x >= y`,`x < y`,`x <= y`                                                                    |
| 相等         | `x == y`,`x != y`                                                                                    |
| 位运算       | `x & y`,`x ^ y`,`x \| y`                                                                             |          |
| 条件逻辑     | `x && y`, `x \|\| y`                                                                                 | 支持短路 |
| 三目运算     | `cond ? TrueExpr : FalseExpr`                                                                        |          |
| 赋值         | `x = y`,`x += y`,`x -= y`,`x *= y`,`x /= y`,`x %= y`,`x &= y`,`x ^= y`,`x \|= y`,`x <<= y`,`x >>= y` |          |
| 逗号运算     | `(expr1, expr2)` 返回 expr2                                                                          |

> *浮点数比较*

浮点数的存储存在精度误差的问题。一个浮点数与 0.0 比较不能简单的使用 `==`，可以依靠 `EPSILON`（较小的正数）。如果正数 `d` < `EPSILON`，那么 `d` 和 `1.0` 相加被认为仍等于 `1.0`。

```c
#include <math.h>
#include <float.h>
/* 浮点数 D 与 0 作比较 */
if(fabs(D - 0.0) < DBL_EPSILON)
	puts("D 与 0.0 相等");
```

>---
#### 4.1. sizeof

`sizeof` 计算完整类型（非函数）或对象的字节大小，编译时计算（除 VLA 外）。

```c
size_t szo = sizeof(expr);
size_t szo = sizeof expr; 
size_t szt = sizeof(Type);

size_t szInt = sizeof(int);
size_t szNum = sizeof 10086;  

// VLA，运行时计算
void Foo(int len) {
	typedef int Arr[len];
	printf("%d\n", sizeof(Arr));
}
```

>---
####  4.2. typeof, typeof_unqual

```c
typeof ( expression | type )
typeof_unqual ( expression | type )
```

`typeof` 保留类型限定，`typeof_unqual` 返回基础类型。*typeof-expr* 不应用于位域成员。

```c
const _Atomic int ai = 0;
const int ci = 1;
const char *const animals[] = {
	"aardvark",
	"bluejay",
	"catte",
};
typeof_unqual(ci) main(void)
{										   // int main
	typeof_unqual(ai) plain_ai;			   // int plain_ai;
	typeof(_Atomic typeof(ci)) atomic_ci;  // const _Atomic int atomic_ci;
	typeof(animals) animals_array;		   // const char* const animals_array[3];
	typeof_unqual(animals) animals2_array; // const char* animals2_array[3];
};
```

> 对于 `typeof` VLA，`sizeof` 在运行时计算

```c
#include <stddef.h>

size_t vla_size(int n)
{
    typedef char vla_type[n + 3];
    vla_type b = {}; 			// VLA
    return sizeof(typeof_unqual(b));  // 运行时计算 
}
```

>---
####  4.3. alignas, alignof

完整对象类型具有 **对齐要求**。`alignas/_Alignas(SIZE) Expr|Type` 为对象类型请求更为严格的对齐，`alignof/_Alignof(Expr|Type)` 以字节返回完整对象类型的对齐要求。**基本对齐** 是小于等于 `alignof(max_align_t)` 的有效对齐，**扩展对齐** 是大于 `alignof(max_align_t)` 的对齐表示。

类型 `bool`、`char`、`signed char` 和 `unsigned char` 具有最弱的对齐要求（1）。以下类型的对齐要求为基本对齐：
- 所有原子、限定或非限定的基本类型、枚举类型、指针类型；
- 其元素类型具有基本对齐要求的所有数组类型；
- 指定为完整对象类型的所有类型；
- 仅包含具有基本对齐要求的类型成员的结构 / 联合。

```c
alignas(SIZE) <Type|Expr> <Identifier>;   // SIZE = 0,1,2,4,8,16,...
size_t sz = alignof(Expr|Type);
```

`alignas` 不在 `typedef`、位域、函数、函数参数、`register` 声明中使用。SIZE 指定值为 0 或 2^n（n = 0,1,2,4,8,16,...）的有效对齐，零对齐没有任何作用。类型的目标对齐应不小于其基本对齐。

`struct` 和 `union` 对齐方式与其成员的最大对齐方式相等。

```c
alignas(16) struct S
{
	alignas(8) bool f1;
	alignas(8) short f2;
	alignas(8) double f3;
} s;
auto S_af = alignof(struct S); // 8
auto s_af = alignof(s);		   // 16
```

>---
#### 4.4. 类型转换

类型转换包含隐式或强制转换（`(type)value`）。任何标量转换为 `bool` 时，数值零、空指针或 `nullptr` 结果为 `false`。指针之间仅强制转换，没有函数指针和对象指针（含 `void *` ）间的转换。

```c
// 检验对象表示是转型的合法使用
double d = 3.14;
printf("The double %.2f is: ", d);
for(size_t n = 0; n < sizeof d; ++n)
    printf("0x%02x ", ((unsigned char*)&d)[n]);
/* The double 3.14 is: 0x1f 0x85 0xeb 0x51 0xb8 0x1e 0x09 0x40 */

struct S {int x;} s;
// (struct S)s; // 错误；非标量类型，尽管转型到相同类型什么都不做
(void)s;        // 转换任何类型到 void 都合法
```

>---
#### 4.5. 按位运算符

按位运算应用于整数类型。

```c
// 按位取反: 1->0, 0->1
	~(10010101) = 01101010
// 按位与:   1&1=1, 0&0=0, 1&0=0
	11010110 & 01101011 = 01000000
// 按位或:   1|1=1, 0|1=1, 0|0=0
	10101110 | 01001010 = 11101110
// 按位异或: 1^1=0, 0^1=1, 0^0=0
	10101101 ^ 01011101 = 11110000
```

> 掩码: F &= M

```c
flags &= MASK // 仅保留掩码位，其他位清空
	MASK   00000010  >>>  ______1_
	           &              &
	flags  10010110  >>>  10010110
	          掩码            =
	flags  ______1_  >>>  00000010
```

> 打开位 (设置位): F |= M

```c
flags |= MASK // 掩码位设置 1
	MASK  >>>  01000010  >>>  _1____1_
                   |              |
	flags >>>  10101001  >>>  10101001
                 打开位           =
	flags >>>  _1____1_  >>>  11101011
```

> 关闭位 (清空位): F &= ~M

```c
flags &= ~MASK // 掩码位设置 0
	MASK  >>> ~00101001  >>>  11010110
			       &		      &
	flags >>>  01011010  >>>  01011010
	             关闭位           =
	flags >>>  __0_0__0  >>>  01010010
```

> 切换位: F ^= M

```c
flags ^= MASK // 将掩码位取反
	MASK  >>>  00110010  >>>  __11__1_
                   ^              ^
	flags >>>  10101001  >>>  10101001
	             切换位           =
	flags >>>  __01__1_  >>>  10011011
```

> 检查位: (F & M) == M

```c
// 相等表示校验位为 1，否则为 0
if((flags & MASK) == MASK) 
	// bit = 1
else
	// bit = 0
```

>---
#### 4.6. 泛型选择

泛型选择根据表达式的类型选择一个值，常用于 `#define` 宏定义的一部分。

```c
// 泛型表达式
_Generic(assign-expr, generic-assoc-list)
// Example cbrt
#define cbrt(X) _Generic((X), 			      \
					     long double: cbrtl,  \
						 default: cbrt,		  \
						 float: cbrtf		  \
						 )(X)
// Example MYTYPE
#define MYTYPE(X) _Generic((X),
		int: "int",
		float : "float",
		double: "double",
		default: "other"
		)
int main(void)
{
	int d = 5;
	printf("%s\n", MYTYPE(d));       // int
	printf("%s\n", MYTYPE(2.0*d));   // double
	printf("%s\n", MYTYPE(3L));		 // long
	printf("%s\n", MYTYPE(&d));	     // int*
}
```

>---
#### 4.7. 静态断言

```c
static_assert (integer-constant-expression, string-literal);  // C23
static_assert (integer-constant-expression);

static_assert(sizeof(int) == 4, "Expecting 32 bit integers");
```

---
### 5. 语句
#### 5.1. 空语句

空语句通常作为 `do`、`for`、`if` 和 `while` 等语句的不执行主体出现。

```c
while(cond)
	;
```

>---
#### 5.2. 迭代语句：while, do, for

> while

```c
while(cond)
    statements
```

> do-while

```c
do 
	block 
while(cond);
```

> for

```c
for( init-expr? ; cond-expr? ; iter-expr?) 
    block
```

>---
#### 5.3. 条件控制语句：if, switch

> if-else

```c
if(cond) block
[else if(cond) block]?
[else block]?
```

> switch

```c
switch(integer-expr){
    [case integer-constexpr: 
		statements 
		[break;]?  // 允许贯穿   
		]+
    [default: 
		statements	
		break;]?
}
```

>---
#### 5.4. 跳转语句

> goto 

`goto` 跳转到目标标签。

```c
void func() { 
	{ // block
		goto out;
	}   
out:
    // ...
}
```

> continue

`continue` 跳转到所属循环体的末尾。

```c
while(cond) {
	/* ... */
	continue;  // 相当于 goto contin;
	/* ... */
contin:
}
```

> break

`break` 中断所属循环体的执行或跳出 `switch`。

```c
while(cond) {
	/* ... */
	break;  // 相当于 goto end;
	/* ... */
}
end:
```

> return

`return` 终止函数执行并返回（值）到调用方。

```c
#define SUCCESS 0
int main(void){
	printf("Hello, World");
	return SUCCESS;
}
```

---
### 6. 函数

函数原型充当无定义的函数声明，被调用函数必须具有定义。不能返回数组或函数类型。

```c
// 函数原型
extern double maximum(int, int, double[*][*]);    // 省略标识符
static double maximum(int n, int m, double a[n][m]);  // 可变长度数组参数
double maximum(int n, int m, double a[*][*]);     // * 占位符
```

> **限定数组形参**

传入的实际参数为指针。

```c
// 要求传入的数组长度至少为 10
void Function(double [static 10], const double [static 10]);
// a 拥有类型 const int*
int f(const int a[20]);
// a 拥有类型 const int* const
int f(const int a[const 20]);
// a 拥有类型 int * const volatile
int f(int a[const volatile]);
// restrict 指针限定
void f(double a[static restrict 10], const double b[static restrict 10]);
```

>---
#### 6.1. 可变参数

`stdarg.h` 提供了宏方法用于访问可变参数列表和清理工作。`va_start` 初始化 `ap`。`va_end(ap)` 后 `ap` 不可用。`va_copy(ap2, ap1)` 复制 `ap1` 的状态给 `ap2`。

```c
// 有效声明
void foo(...);  // C23
void foo(int n, ...);

double sum(int lim, ...) /* 设 lim 表明变参列表中参数的数量 */
{
	va_list ap;
	// 初始化 ap, lim 为可变参数前置参数
	va_start(ap, lim); // va_start(ap)
	// 访问参数列表的内容 va_arg(ap, type)
	double f1 = va_arg(ap, double); // ap[0]
	int f2 = va_arg(ap, int);		// ap[1]
	// 清理工作
	va_end(ap);
	return f1 + f2;
}
sum(2, 3.14, 10086);
```

>---
#### 6.2. 内联函数

`inline` 声明内联函数。内联告知编译器对该函数的调用应尽可能快。函数调用都有一定的开销。编译器将内联函数的调用点替换为对函数体的执行，这可能会生成更大的可执行文件。

```c
inline static void _inline(){
	while(getchar() != '\n')
		continue;
}

void Fun(void){
	_inline();
}
// 类似于
void FunInline(void){
	while(getchar() != '\n')
		continue;
}
```

一般无法获取内联函数的地址。可以混合使用 `inline` 和 `extern`。具有外部链接的内联函数可以产生外部定义。

```c
// 静态内联函数定义，内部链接
inline static void fun();
// 外部链接全局函数定义
void fun();
// 既充当内部内联函数, 又具有外部链接
[extern]? inline void fun();
```

>---
#### 6.3. 函数指针

函数指针常用作函数参数。

```c
void ToUpper(char *);
void ToLower(char *);

void show(void (* fp)(char *), char * str){
	fp(str);
}
show(ToUpper, "Hello"); 
show(ToLower, "World"); 
```

---
### 7. 属性说明符

属性为各种源构造（如类型、对象、标识符或块）指定其他信息。任何不支持的属性标记都将被忽略。属性列表中的显示顺序不重要。

```c
[[attr]]  // 形式 __attr__ 与 attr 行为等价
[[attr1, attr2, attr3(args)]]
[[属性前缀::attr]]
[[属性前缀::attr(arg)]]
// 等价声明
[[deprecated, hal::daisy]] double nine1000(double);
[[deprecated]] [[hal::daisy]] double nine1000(double);
[[deprecated]] double nine1000 [[hal::daisy]] (double);
```

标准属性中的标识符应为以下项之一：

```c
[[deprecated]]		// 弃用
[[maybe_unused]]	// 抑制编译器对象未使用警告
[[noreturn]]		// 函数不会返回
[[fallthrough]]		// 抑制编译器 switch 贯穿警告
[[nodiscard]]		// 建议值需要接收不可弃警告
[[unsequenced]] 	// 指示函数无效果、幂等、无状态且无关联，即它是无序的。	
[[reproducible]]    // 指示函数无效果且幂等，即它是可重现的。    
```

不同属性列表的顺序可能会影响语义，以下两个声明并不等价：

```c
[[hal::daisy]] [[hal::rosie]] double nine999(double);
[[hal::rosie]] [[hal::daisy]] double nine999(double);
```

>---
#### 7.1. nodiscard 弃值表达式警告

`nodiscard` 应用于函数返回、枚举、结构或联合类型的定义。`(void)nodiscardExpr` 忽略编译器警告。

```c
struct [[nodiscard]] S { int status; };
struct S returnStruct(){
	return (struct S){0};
}

[[nodiscard("No Discard")]] int Mrix(int a, int b){
	return a ^ b;
}

int main(void){
	returnStruct();   /* warning */ 
	// (void)returnStruct();   /* no warning */
	int rt = Mrix(1,2);	/* legal */
}
```

>---

#### 7.2. deprecated 弃用

`deprecated` 用于标记弃用的实体。“已弃用” 适用于过时、不安全、不安全或不适合用途的名称和实体。

```c
struct [[deprecated]] S;              // 结构/联合
[[deprecated]] typedef S* PS;         // typedef 名称
[[deprecated]] int x;                 // 对象
union U { [[deprecated]] int n; };    // 结构/联合成员
[[deprecated("Use h() instead.")]] void f(void);          // 函数
enum [[deprecated]] E {};             // 枚举
enum { A [[deprecated]], B [[deprecated]] = 42 };   // 枚举项
```

>---
#### 7.3. fallthrough 贯穿抑制警告


`[[fallthrough]]` 仅用于 `switch` 语句中用于抑制 `case` 贯穿警告。

```c
switch (n) {
    case 1:
    case 2:
        g();
        [[fallthrough]];
    case 3: 	// 贯穿时不警告
        h();
    case 4: 	// 编译器可在发生贯穿时警告
	    if(n < 3) {
            i();
            [[fallthrough]]; 	// OK
        }
        else return;
}
```

>---

#### 7.4. maybe_unused 抑制对未使用实体的警告

`maybe_unused` 抑制由编译器发出的对未使用实体的警告。

```c
struct [[maybe_unused]] S;              // 结构/联合
[[maybe_unused]] typedef S* PS;         // typedef 名称
[[maybe_unused]] int x;                 // 对象
union U { [[maybe_unused]] int n; };    // 结构/联合成员
[[maybe_unused]] void f(void);          // 函数
enum [[maybe_unused]] E {};             // 枚举
enum { A [[maybe_unused]], B [[maybe_unused]] = 42 };   // 枚举项
```

>---

#### 7.5. noreturn 函数不会返回

`[[noreturn]]` 指示函数不会由于执行返回或抵达函数体结尾而返回（它可以通过执行 `longjmp` 返回）。

```c
[[noreturn]] void f(void) {
    abort(); // ok
}
[[noreturn]] void g(int i) { 
    // causes undefined behavior if i <= 0
    if (i > 0) abort();
}
[[noreturn]] int h(void);
```

以下标准库函数带有 `noreturn`：

```c
abort()
exit()
_Exit()
quick_exit()
thrd_exit()
longjmp()
```

>---

#### 7.6. unsequenced 和 reproducible 函数类型标准属性

`[[unsequenced]]` 和 `[[reproducible]]` 应用于函数或函数类型声明。这些属性区分读取操作（无状态和无关联）和写入操作（无效果、幂等和可重现）或两者的组合（未排序）
- `unsequenced` 指示函数无效果、幂等、无状态且无关联，即它是无序的。
- `reproducible` 指示函数无效果且幂等，即它是可重现的。

这些属性为编译器优化的目的而存在：
- 如果函数 `reproducible` 可重现，则可将先后多次调用当做一次调用。
- 如果函数 `unsequenced` 无序，则可将先后多次调用当做一次调用，且这些调用可以并行化并任意重排。

```c
size_t hash(char const[static 32]) [[reproducible]];
bool tendency(signed char) [[unsequenced]];
```

> *无作用*

如果函数调用过程中编入序列的任何存储操作，都是对某对象的同步于此次调用的修改，则该调用的执行是无作用的；如果这种存储操作还是可观察的，则对该对象的所有访问必须都基于函数的一个唯一指针形参进行。

> *幂等*

对于某个求值 `E`，若 `E` 的第二次求值可以紧跟第一次求值编入序列而不改变结果值（如果有）或执行的可观察状态，则它是幂等的。

> *无状态*

如果函数 `F` 或其所调用的任何函数中，具有静态或线程存储期的任意对象的定义均为 `const` 但无 `volatile` 限定，则 `F` 是无状态的。

> *无关联*

对于函数 `F`，如果 `F` 的调用中可以通过并非该调用的形参的左值而观察到任何对象 `X`，而在同一次程序执行中所有对 `F` 的调用中，对 `X` 的所有访问都观察到相同的值，则 `F` 无关联；或者如果访问是通过某个指针形参进行，则应当有一个唯一的这种指针形参 `P`，使得对 `X` 的任何访问都应当是基于 `P` 的左值访问。

对象 `X` 由函数调用所观察的条件是：二者均同步，`X` 并非局部与此次调用，`X` 的生存期开始于函数调用之前，且此次调用中有对 `X` 的访问被排入序列；此次调用前所存储的 `X` 的最新值（如果有），被称为此次调用所观察到的 `X` 的值。

---
### 8. 预处理器与预处理指令

预处理器是将源文件的文本作为翻译的第一阶段操作的文本处理器。

```c
#if   		#else    	#elif		#ifdef		#ifndef		
#elifdef	#elifndef	#endif		#define		#undef 
#line		#error		#warning	#pragma 	#include	
#embed
```

C 和 C++ 程序包含一个或多个源文件。**翻译单元** 包含 `#include` 指定的头文件或其它源文件，但不包括由条件编译指令（如 `#if` ）删除的代码部分。编译后的翻译单元可作为单独的对象文件或对象代码库处理。将这些单独已编译的翻译单元链接起来以构成可执行程序或动态链接库。

>---
#### 8.1. 空预处理指令

```c
//...
#     // 无作用
//...
```

>---
#### 8.2. 条件编译

条件编译由 `#if`、`#else`、`#elif`、`#ifdef`、`#ifndef`、`#elifdef`、`#elifndef`、`#endif` 支持。条件表达式可以具有形式 `defined` 的一元运算符：

```c
#if defined MACRO
#if !defined( MACRO )
```

在条件编译指令中，可以检查 `__has_include`、`__has_embed` 和 `__has_c_attribute` 特性。

```c
__has_include ( header-name ) 
__has_include ( header-name-tokens )

__has_embed ( header-name embed-parameter-sequence? ) 
__has_embed ( header-name-tokens pp-balanced-token-sequence? )

__has_c_attribute ( pp-tokens )
```

>---
#### 8.3. 源文件包含：include

```c
#include <stdio.h>
#include "some.h"
```

为了避免重复包含相同头文件或发生无限递归时，通常会使用头文件防护（或 `#pragma once`）：

```c
#ifndef FOO_H_INCLUDED /* 唯一映射到此文件名的任何名字 */
#define FOO_H_INCLUDED
// 此文件的内容在此
#endif
```

> __has_include

条件表达式搜索 `__has_include` 标识的头文件或源文件，若搜索成功，`__has_include` 表达式结果为 1。

```c
#if __has_include(<optional.h>)
	#include <optional.h>
	#define have_optional 1
#elif __has_include(<experimental/optional.h>)
	#include <experimental/optional.h>
	#define have_optional 1
	#define have_experimental_optional 1
#endif
#ifndef have_optional
	#define have_optional 0
#endif
```

>---

#### 8.4. 二进制资源包含：embed

`#embed` 用于在声明嵌入一个二进制资源，该资源可以作为一个给定的嵌入参数的二进制数据序列来处理。资源具有实现的资源宽度，或由嵌入参数 `limit` 修改。嵌入元素宽度等于 `CHAR_BIT`，或由某个由实现定义的参数所修改。资源宽度必须可被嵌入元素宽度整除，即 *资源宽度* % *嵌入元素宽度* = 0。

```c
#embed "file" embed-parameter-sequence?		
embed-parameter-sequence:
	limit, prefix, suffix, if_empty
```

`#embed` 指令旨在将资源中的二进制数据转换为一系列整数常量表达式，以尽可能保留资源位流的值。

```c
#include <stddef.h>
void have_you_any_wool(const unsigned char*, size_t);

int main (int, char*[]) {
	static const unsigned char baa_baa[] = {
		#embed "black_sheep.ico"
	};
	have_you_any_wool(baa_baa, sizeof(baa_baa));
	return 0;
}
```

> *limit*

```c
limit ( 非负整数常量 )
__limit__ ( 非负整数常量 )	
```

*资源宽度* 为：
- 如果 *E* = 0，则为 0；或
- max { *实现定义资源宽度*, *嵌入元素宽度* × *E* }。


```c
// 检查声音资源的前 4 个元素
#include <assert.h>

int main(int, char *[])
{
	static const char sound_signature[] = {
#embed <sdk/jump.wav> limit(2+2)  
	};
	static_assert((sizeof(sound_signature) / sizeof(*sound_signature)) == 4,
	"There should only be 4 elements in this array.");
	
	// verify PCM WAV resource
	assert(sound_signature[0] == ’R’);
	assert(sound_signature[1] == ’I’);
	assert(sound_signature[2] == ’F’);
	assert(sound_signature[3] == ’F’);
	assert(sizeof(sound_signature) == 4);
	return 0;
}
```

在 `CHAR_BIT` 大于 24 的环境中，资源可能没有足够的信息，这可能违反约束：

```c
int main (int, char*[]) {
	const unsigned char arr[] = {
#embed "24_bits.bin" limit(1) // may be a constraint violation, 资源宽度 = 1 x 24?
	};
	return 0;
}
```

某些实现接口的资源可能具有无限的数据流：

```c
int main (int, char*[]) {
	const unsigned char arr[] = {
embed </owo/uwurandom> limit(513)
	};
	return 0;
}
```

`limit` 参数可以帮助只处理该信息的一部分，并防止在处理此类数据时耗尽实现的内部资源。


> *suffix*

```c
suffix ( 预处理平衡记号序列? )
__suffix__ ( 预处理平衡记号序列? )
```

嵌入参数 `suffix` 在嵌入参数序列中最多可出现一次。它必须带有（可能为空的）实参子句。如果资源非空，则该参数子句的内容被置于紧跟该指令的展开之后。否则，它没有效果。


```c
// 添加到数组初始值设定项的额外元素
#include <string.h>
#ifndef SHADER_TARGET
	#define SHADER_TARGET "edith-impl.glsl"
#endif

extern char* null_term_shader_data;
void fill_in_data () {
	const char internal_data[] = {
#embed SHADER_TARGET \ 
	suffix(,)
	0 // 源序列后补一个 0 元素
	};
	strcpy(null_term_shader_data, internal_data);
}
```

> *prefix*

```c
prefix ( 预处理平衡记号序列? )
__prefix__ ( 预处理平衡记号序列? )
```

嵌入参数 `prefix` 在嵌入参数序列中最多可出现一次。它必须带有（可能为空的）实参子句。如果资源非空，则该参数子句的内容被置于紧接该指令的展开之前。否则，它没有效果。

```c
// 当资源不为空时，为其嵌入一个前缀和后缀的附加标记
#include <assert.h>
#include <string.h>

#ifndef SHADER_TARGET
	#define SHADER_TARGET "ches.glsl"
#endif

extern char* merp;
void init_data () {
	const char whl[] = {
#embed SHADER_TARGET \
	prefix(0xEF, 0xBB, 0xBF, ) /* UTF-8 BOM */ \
	suffix(,)
	0
	};
// always null terminated,
// contains BOM if not-empty
	int is_good = (sizeof(whl) == 1 && whl[0] == ’\0’)
		|| (whl[0] == ’\xEF’ && whl[1] == ’\xBB’
		&& whl[2] == ’\xBF’ && whl[sizeof(whl) - 1] == ’\0’);
	assert(is_good);
	strcpy(merp, whl);
}
```

> *if_empty*

```c
if_empty ( 预处理平衡记号序列? )	
__if_empty__( 预处理平衡记号序列? )	
```

嵌入参数 `if_empty` 在嵌入参数序列中最多可出现一次。它必须带有（可能为空的）实参子句。如果资源为空，则以该参数子句的内容替换该指令。否则，它没有效果。

```c
// 如果资源搜索成功，由于 limit(0) 这个资源总被视为空。这个程序总是返回 0
int main(){
	return 
#embed <some_resource> \
	limit(0) \			// 资源宽度计算为 0
	prefix(1) \			// 资源被视为空，前缀无效
	if_empty(0)			// 资源为空，使用序列 0 替代
	;
	// become: return 0;
}
```

> __has_embed

条件表达式搜索 `__has_embed` 标识的资源，计算结果和以下预定义的宏相同：
- `__STDC_EMBED_NOT_FOUND__  0`：如果搜索资源失败，或者如果指定的嵌入参数序列中的任何嵌入参数不受 `#embed` 指令的实现支持；
- `__STDC_EMBED_FOUND__  1`：如果搜索资源成功，并且 `#embed` 指令的实现支持指定的嵌入参数序列中的所有嵌入参数，并且资源不为空；
- `__STDC_EMBED_EMPTY__  2`：如果搜索资源成功，并且 `#embed` 指令的实现支持指定的嵌入参数序列中的所有嵌入参数，并且资源为空。

```c
int main () {
#if __has_embed ("bits.bin" clang::element_type(short))
	// load "short" values directly from memory
	short meow[] = {
#embed "bits.bin" clang::element_type(short)
	};
#else
	// no support for implementation-specifid
	// clang::element_type parameter
	unsigned char meow_bytes[] = {
#embed "bits.bin"
	};
	unsigned short meow[] = {
		/* parse meow_bytes into short values
		   by-hand! */
	};
#endif
	return 0;
}
```

可以使用 `__FILE__` 和 `__has_embed` 组合来检查是否支持由 `$embed` 指令嵌入参数的特定实现扩展。

```c
#if __has_embed(__FILE__ ext::token(0xB055))
	#define DESCRIPTION "Supports extended token embed parameter"
#else
	#define DESCRIPTION "Does not support extended token embed parameter"
#endif
```

以下用于检查特定实现定义的嵌入参数的支持，否则使用标准行为来产生相同的效果。

```c
void parse_into_s(short *ptr, unsigned char *ptr_bytes, unsigned long long size);
int main()
{
#if __has_embed("test.bin" ds9000::element_type(short))
    /* Implementation extension: create short integers from the */
    /* translation environment resource into */
    /* a sequence of integer constants */
    short meow[] = {
#embed "bits.bin" ds9000::element_type(short)
    };
#elif __has_embed("test.bin")
    /* no support for implementation-specific */
    /* ds9000::element_type(short) parameter */
    const unsigned char meow_bytes[] = {
#embed "bits.bin"
    };
    short meow[sizeof(meow_bytes) / sizeof(short)] = {};
    /* parse meow_bytes into short values by-hand! */
    parse_into_s(meow, meow_bytes, sizeof(meow_bytes));
#else
#error "cannot find test.bin resource"
#endif
    return (int)(meow[0] + meow[(sizeof(meow) / sizeof(*meow)) - 1]);
}
```

>---

#### 8.5. 宏定义：define, undef

预处理器支持文本宏替换及类函数文本宏替换。

```c
// 仿对象宏
#define identifier replacement-list?
// 仿函数宏
#define identifier ( param-list ) replacement-list
#define identifier ( param-list, ... ) replacement-list
#define identifier ( ... ) replacement-list
// 取消宏定义
#undef identifier
```

定义有可变参数的仿函数宏，能用 `__VA_ARGS__` 访问可变参数。*替换列表* 可包含标记序列 `__VA_OPT__( content )`，标记序列在 `__VA_ARGS__` 非空时，将替换为 *content*，否则将展开为空。

```c
#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)
F(a, b, c) // 替换为 f(0, a, b, c)
F()        // 替换为 f(0)

#define G(X, ...) f(0, X __VA_OPT__(,) __VA_ARGS__)
G(a, b, c) // 替换为 f(0, a, b, c)
G(a, )     // 替换为 f(0, a)
G(a)       // 替换为 f(0, a)

#define SDEF(sname, ...) S sname __VA_OPT__(= { __VA_ARGS__ })
SDEF(foo);       // 替换为 S foo;
SDEF(bar, 1, 2); // 替换为 S bar = { 1, 2 };
```

> *字符串化运算符 `#`*

在仿函数宏中，`#` 对 *替换列表* 字符串化并做形参替换，例如对于替换列表 `X`，`#X` 替换为 `"X"`。

```c
#define PSQR(x) printf("The square of " #x " is %d.\n",((x)*(x)))

int y = 5;
PSQR(y);       // The square of y is 25.
PSQR(2 + 4);   // The square of 2 + 4 is 36.
```

`#` 出现在 `__VA_ARGS__` 之前时，将整个展开后的 `__VA_ARGS__` 放入引号：

```c
#define Showlist(...) puts(#__VA_ARGS__)
Showlist();            // 展开成 puts("")
Showlist(1, "x", int); // 展开成 puts("1, \"x\", int")
```

> *连接运算符 `##`*

`##` 运算符把两个记号组合成一个记号。

```c
#include <stdio.h>
#define XNAME(n) x ## n   // 表示将 x 与 n 组合成一个记号
#define PRINT_XN(n) printf("x" #n " = %d\n", x ## n);

int main(void)
{
	int XNAME(1) = 14; 	// 变成 int x1 = 14;
	int XNAME(2) = 20; 	// 变成 int x2 = 20;
	int x3 = 30;

	PRINT_XN(1); // 变成 printf("x1 = %d\n", x1);
	PRINT_XN(2); // 变成 printf("x2 = %d\n", x2);
	PRINT_XN(3); // 变成 printf("x3 = %d\n", x3);
	return 0;
}
/*
	PRINT_XN() 宏用 # 运算符组合字符串
	## 运算符把记号组合为一个新的标识符。
*/
```

>---
#### 8.6. 文件名与行信息：line

```c
#line digit-sequence "s-char-sequence"?

#include <assert.h>
#define FNAME "test.c"
int main(void)
{
#line 777 FNAME
        assert(2+2 == 5);
}
// test: test.c:777: int main(): Assertion `2+2 == 5' failed.
```

当给定的断言失败，断言将使用预定义宏 `__LINE__` ，并 `__FILE__` 打印有关源文件的错误消息。

```c
#include <assert.h>
#line 10086 "test.c"
	assert(1 > 2);
// Assertion failed: 1 > 2, file test.c, line 10086
```

>---

#### 8.7. 诊断：error, warning

`#error` 和 `#warning` 指令使实现产生一个诊断消息。`#error` 会终止编译，`#warning` 仅发出警告。

```c
#if __STDC__ != 1
#error "Not a standard compliant compiler"
#endif
 
#if __STDC_VERSION__ >= 202311L
#warning "Using #warning as a standard feature"
#endif
 
#include <stdio.h>
int main (void){
    printf("The compiler used conforms to the ISO C Standard !!");
}
```

>---
#### 8.8. 实现定义行为控制：pragma

`#pragma` 指令控制编译器行为，如禁用编译器警告或更改对齐要求等。Pragma 指令指定特定于计算机或特定于操作系统的编译器功能。

```c
_Pragma("nonstandardtreatmenttypeB on");
// 等价于
#pragma nonstandardtreatmenttypeB on
```

如果预处理标记 `STDC` 紧跟 `pragma` 之后，则不会对指令执行宏替换，并且指令应具有以下形式之一

```c
#pragma STDC FP_CONTRACT /*on-off-switch*/        
#pragma STDC FENV_ACCESS /*on-off-switch*/
#pragma STDC CX_LIMITED_RANGE /*on-off-switch*/
// on-off-switch: one of
	ON
	OFF
	DEFAULT

#pragma STDC FENV_ROUND direction
// direction: one of
	FE_DOWNWARD
	FE_TONEAREST
	FE_TONEARESTFROMZERO
	FE_TOWARDZERO
	FE_UPWARD
	FE_DYNAMIC

#pragma STDC FENV_DEC_ROUND dec-direction
// dec-direction: one of
	FE_DEC_DOWNWARD
	FE_DEC_TONEAREST
	FE_DEC_TONEARESTFROMZERO
	FE_DEC_TOWARDZERO
	FE_DEC_UPWARD
	FE_DEC_DYNAMIC
```

- `FENV_ACCESS OFF` 默认是关闭，表示编译器程序将访问或修改浮点环境这意味着禁用可能推翻标志测试和模式更改（例如，全局共用子表达式删除、代码移动，及常量折叠）的优化。
- `FP_CONTRACT ON` 允许缩略浮点表达式，即忽略舍入错误和浮点异常的优化，被观察成表达式以如同书写方式准确求值。
- `CX_LIMITED_RANGE OFF` 告知编译器复数的乘法、除法，及绝对值可以用简化的数学公式，不考虑中间溢出的可能性。
- `FENV_ROUND` 浮点舍入方式。
- `FENV_DEC_ROUND` 十进制浮点舍入方式。

> *非标准语用*

```c
#pragma once		// 当某个头文件中包含它时，指示编译器只对其分析一次

#pragma pack		// 控制后继定义的结构体和联合体的最大对齐系数
#pragma pack(integer)          // 设置当前对齐为值 integer
#pragma pack()                 // 恢复默认对齐
#pragma pack(push)             // 推入当前对齐到内部栈
#pragma pack(push, integer)    // 推入当前对齐到内部栈并设置对齐为 integer
#pragma pack(pop)              // 从内部栈弹出栈顶对齐值并恢复当前对齐为该值

#pragma unpack()     // 取消上次设定的对齐系数
```

---
### 9. Annex
#### 9.1. 预定义宏


| Macro                                                                          | Description                                                                                                                        |
| :----------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------- |
| `__STDC__`                                                                     | 展开成整数常量 1。此宏是用以指示遵从标准的实现                                                                                     |
| `__STDC_VERSION__`                                                             | 展开成 `long` 类型的整数常量，其值随着 C 标准的每个版本递增                                                                        |
| `__STDC_HOSTED__`                                                              | 若实现有宿主（在操作系统下运行），则展开成整数常量 1，若为自立的（不在操作系统中运行）则展开成 ​0                                  |
| `__FILE__`                                                                     | 展开成当前文件名，为字符串字面量，可用 `#line` 指令更改                                                                            |
| `​__LINE__`                                                                    | 展开成源文件行号，为整数常量，可用 #line 指令更改                                                                                  |
| `__DATE__`                                                                     | 展开成翻译的日期，格式为 `"Mmm dd yyyy"` 的字符串字面量。月份名如同以 `asctime` 生成，而若月之日期小于 10 则 `"dd"` 的首字符为空格 |
| `__TIME__`                                                                     | 展开成翻译的时间，格式为 `"hh:mm:ss"` 的字符串字面量，如同 `asctime()` 所生成                                                      |
| `__STDC_UTF_16__`                                                              | 扩展为 1 以指出 `char16_t` 使用 UTF-16 编码                                                                                        |
| `__STDC_UTF_32__`                                                              | 扩展为 1 以指出 `char32_t` 使用 UTF-32 编码                                                                                        |
| `__STDC_EMBED_NOT_FOUND__`>---`__STDC_EMBED_FOUND__`>---`__STDC_EMBED_EMPTY__` | 分别扩展为 ​0​、1 和 2                                                                                                             |
  
实现可能预定义下列额外宏名：

| Macro                        | Description                                                                                                         |
| :--------------------------- | :------------------------------------------------------------------------------------------------------------------ |
| `__STDC_ISO_10646__`         | 若 wchar_t 使用 Unicode，则展开成形式为 yyyymmL 的整数常量，日期指示受支持的 Unicode 最近版本                       |
| `__STDC_IEC_559__`           | 若支持 IEC 60559 则展开成 1 (弃用) (C23 起)                                                                         |
| `__STDC_IEC_559_COMPLEX__`   | 若支持 IEC 60559 复数算术则展开成 1 (弃用) (C23 起)                                                                 |
| `__STDC_UTF_16__`            | 若 `char16_t` 使用 UTF-16 则展开成 1                                                                                |
| `__STDC_UTF_32__`            | 若 `char32_t` 使用 UTF-32 则展开成 1                                                                                |
| `__STDC_MB_MIGHT_NEQ_WC__`   | 若 `'x' == L'x'` 可能对基础字符集的成员为 `false` 则展开成 1，例如在基于 EBCDIC 的，`wchar_t` 使用 Unicode 的系统上 |
| `__STDC_ANALYZABLE__`        | 若支持可分析性则展开成 1                                                                                            |
| `__STDC_LIB_EXT1__`          | 若支持边界检查接口则展开成整数常量 201112L                                                                          |
| `__STDC_NO_ATOMICS__`        | 若不支持原子类型和原子操作库则展开成 1                                                                              |
| `__STDC_NO_COMPLEX__`        | 若不支持复数类型和复数运算库则展开成 1                                                                              |
| `__STDC_NO_THREADS__`        | 若不支持多线程则展开成 1                                                                                            |
| `__STDC_NO_VLA__`            | 若不支持自动存储期的 (C23 起) 非常量长度数组及可变修改类型 (C23 前) 则展开成 1                                      |
| `__STDC_IEC_60559_BFP__`     | 若支持 IEC 60559 二进制浮点算术则展开成 202311L                                                                     |
| `__STDC_IEC_60559_DFP__`     | 若支持 IEC 60559 十进制浮点算术则展开成 202311L                                                                     |
| `__STDC_IEC_60559_COMPLEX__` | 若支持 IEC 60559 复数算术则展开成 202311L                                                                           |
| `__STDC_IEC_60559_TYPES__`   | 若支持 IEC 60559 互换可扩展类型则展开成 202311L                                                                     |

这些宏的值（除了 `__FILE__` 和 `__LINE__`）在整个翻译单元中保持常量。尝试重定义或解除定义这些宏导致未定义行为。

> *预定义变量*

预定义变量 `__func__` 不是预处理器宏，`__func__` 替换为当前函数名称。

```c
void example(){
    printf("%s\n", __func__);
}
// prints "example"
```

>---
#### 9.2. 流与文件

> Stream（流）

流（stream）是数据序列的抽象，包括文本流和二进制流。文本流是由行组成的有序字符序列；二进制流是一个有序的字符序列。在相同的实现下，从二进制流读入的数据应该与早先写进该流的数据比较相等。这样的流可以在流的末尾附加上不确定数目的实现定义的空字符。

每个流都有一个方向。在流与外部文件关联后，在对其执行任何操作之前，流没有方向。一旦将宽字符输入输出函数应用于没有方向的流，该流就成为宽方向流。一旦将字节输入输出函数应用于没有方向的流，该流就会成为面向字节的流。只有调用 `freopen` 或 `fwide` 函数才能改变流的方向，如果成功调用 `freopen`，则会消除任何定向。

字节输入输出函数不能应用于面向宽的流，宽字符输入输出函数不能应用于面向字节的流。其余的流操作不影响流的方向，也不受流方向的影响，除了：
  - 二进制宽定向流具有文本流和二进制流的文件定位限制；
  - 对于面向宽的流，在成功调用文件定位函数（在文件结束之前留下文件位置指示符）之后，宽字符输出函数可以覆盖部分多字节字符；之后任何超出写入字节的文件内容从此可能不包含有效的多字节字符。

每个面向宽的流都有一个关联的 `mbstate_t` 对象，用于存储流的当前解析状态。对 `fgetpos` 的成功调用将这个 `mbstate_t` 对象的值的表示存储为 `fpos_t` 对象值的一部分。稍后使用相同的存储的 `fpos_t` 值成功调用 `fsetpos` 将恢复相关的 `mbstate_t` 对象的值以及在受控流中的位置。

每个流都有一个相关的锁，用于防止多个执行线程访问同一流时的数据竞争，并限制多个线程执行的流操作的交错。一次只有一个线程可以持有这个锁。锁是可重入的：一个线程可以在给定时间多次持有锁。所有读、写、定位或查询流位置的函数在访问流之前都会锁定流。当访问完成时，它们释放与流关联的锁。

> Files（文件）

通过打开文件，流与外部文件（可能是物理设备）相关联。如果一个文件可以支持定位请求，那么与流关联的文件位置指示器定位在文件的开始，除非文件以追加模式打开。文件位置指示器由随后的读取、写入和定位请求等维护，以保证指示器在文件中的有序前进。

当流 *无缓冲* 时，字符将从源端或目标端尽快出现，字符可能会作为一个块被累积和传输到主机环境或从主机环境传输出去。当流 *全缓冲* 时，在缓冲区被填满时，字符将作为一个块传输到主机环境或从主机环境传输出去。当流 *行缓冲* 时，在遇到换行符时，字符将作为块传输到主机环境或从主机环境传输出去。此外，在缓冲区被填满时、或者是在未缓冲的流上请求输入时、或者在需要从主机环境传输字符的行缓冲流上请求输入时，字符将作为块传输到主机环境中。

可以通过关闭文件来解除文件与控制流的关联。输出流在与文件解除关联之前被刷新，任何未写入的缓冲区内容都被传输到主机环境。`FILE` 对象的生存期在相关文件（包括标准文本流）关闭时结束。该文件可能随后由相同或另一个程序执行重新打开，并回收或修改其内容。如果 `main` 函数返回到它的原始调用方，或者如果 `exit` 函数被调用，则在程序终止之前正确关闭所有打开的文件。其他终止程序（例如调用 `abort` 函数）的途径不需要正确关闭所有文件。

在程序启动时，三个文本流是预定义的，并且已经打开：标准输入（`stdin`）、标准输出（`stdout`）和标准错误（`stderr`）。在最初打开时，标准错误流未被完全缓冲；当且仅当标准输入和标准输出流可以被确定为不引用交互式设备时，该流才被完全缓冲。 

打开其他（非临时）文件的函数需要一个文件名，文件名是一个字符串。虽然文本和二进制宽面向流在概念上都是宽字符序列，但与宽面向流相关的外部文件是多字节字符序列。文件中的多字节编码可能包含嵌入的空字节（与程序内部使用的有效多字节编码不同），文件也不必以初始移位状态开始或结束。此外，用于多字节字符的编码在文件之间可能不同。这种编码的性质和选择都是由实现定义的。

宽字符输入函数从流中读取多字节字符，并将其转换为宽字符，就像连续调用 `fgetwc` 函数一样。每次转换都像调用 `mbrtowc` 函数一样发生，转换状态由流自己的 `mbstate_t` 对象描述。字节输入函数从流中读取字符，就像连续调用 `fgetc` 函数一样。字符输出函数将宽字符转换为多字节字符，并将其写入流，就像连续调用 `fputwc` 函数一样。每次转换都像调用 `wcrtomb` 函数一样发生，转换状态由流自己的 `mbstate_t` 对象描述。字节输出函数将字符写入流，就像连续调用 `fputc` 函数一样。

在某些情况下，一些字节输入输出函数还执行多字节字符和宽字符之间的转换。如果提供给底层 `mbrtowc` 函数的字符序列没有形成有效的（通用的）多字节字符，或者传递给底层 `wcrtomb` 的代码值不对应于有效的（通用的）多字节字符，则会发生编码错误。当且仅当编码错误发生时，宽字符输入输出函数和字节输入输出函数将宏 `EILSEQ` 的值存储在 `errno` 中。

> *fopen-like* 函数

```c
FILE *fopen(const char *restrict filename, const char *restrict mode);
```

`fopen` 函数中，参数 `mode` 的格式字符串：
  - `"r"` 表示打开文件以读取，`"a"` 表示打开或创建文件以末尾写入，`"w"` 表示打开清空或创建文件并从头写入；
  - 附加二进制访问标签 `"b"` 表示使用二进制模式（默认使用文本模式，仅在 Windows 上生效）。
  - 附加更新模式标签 `"+"` 表示文件打开时可以在相关的流上进行读取和写入。但是如果不调用 `fflush` 或文件定位函数时，输出不能直接跟在输入后面；如果不调用文件定位函数，输入不能直接跟在输出后面。
  - 附加排他模式标签 `"x"` 可以可选地后附到 `"w"` 或 `"w+"` 指定符，表示文件存在或无法创建时，强制函数是失败。
  - 附加默认 `fopen` 许可标签 `"u"` 可以可选地前附到 `"w"` 或 `"a"` 指定符，表示启用默认的 `fopen` 许可。一般使用 `fopen` 时，文件以 `"w"` 或 `"a"` 创建的文件的文件许可是禁止任何其他用户访问它（独占模式）。

`"r"` 读取模式： 
  - `"r"`：打开文本文件并从头读取（文本模式打开读取）
  - `"rb"`：打开二进制文件并从头读取（二进制模式打开读取）
  - `"r+"`：打开文本文件并从头进行读写更新（文本模式打开读写更新）
  - `"r+b"/"rb+"`：打开二进制文件并从头进行读写更新（二进制模式打开读写更新）

`"a"` 追加模式：
  - `"a"`：打开或创建文本文件，以便在文件末尾写入（文本模式创建或打开写入）
  - `"ab"`：打开或创建二进制文件，以便在文件末尾写入（二进制模式创建或打开写入）
  - `"a+"`：打开或创建文本文件，以便在文件末尾读写更新（文本模式创建或打开读写更新）
  - `"a+b"\"ab+"`：打开或创建二进制文件，以便在文件末尾读写更新（二进制模式创建或打开读写更新）

`"w"` 文件访问模式：
  - `"w"`：截断为零长度或创建用于写入的文本文件（文本模式创建或打开写入）
  - `"wb"`：截断为零长度或创建用于写入的二进制文件（二进制模式创建或打开写入）
  - `"w+"`：截断为零长度或创建用于读写更新的文本文件（文本模式创建或打开读写更新）
  - `"w+b"/"wb+"`：截断为零长度或创建用于读写更新的二进制文件（二进制模式创建或打开读写更新）

`"wx` 文件访问模式： 
  - `"wx"`：创建文本文件以写入，文件存在则失败（文本模式创建写入）
  - `"wbx"`：创建二进制文件以写入，文件存在则失败（二进制模式创建写入）
  - `"w+x"`：创建文本文件以读写更新，文件存在则失败（文本模式创建读写更新）
  - `"w+bx"/"wb+x"`：创建二进制文件以读写更新，文件存在则失败（二进制模式创建读写更新）

如果文件不存在或无法读取，则以读取模式（`mode` 参数中的第一个字符为 “`'r'`”）打开文件将失败。当打开时，当且仅当可以确定流不引用交互式设备时，流被完全缓冲。流的错误和文件结束指示符将被清除。

```c
#include <stdio.h>
void test_fopen()
{
#define m_filename "myfile.txt"
    FILE *my_file;
    if (!fopen_s(&my_file, m_filename, "a")) // 追加写入
    {
        fprintf(my_file, "Hello world");
        fclose(my_file);
    }
    // 程序结束时会自动 fflush
}
```

>---
#### 9.3. 格式化输出

*print-like* 函数参数 `format`，由普通多字节和若干的 *转换说明符* 构成。每个格式规范由字符 `%` 表示，在 `%` 之后，可以出现：
  - 修改转换规范的零个或多个 **标志**（任何顺序）；
  - **可选的最小字符宽度**。转换值的字符少于字符宽度时用空格填充，字符宽度采用星号或者非负十进制整数的形式；
  - **可选的精度**。即给出 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换要出现的最小位数，`a`、`A`、`e`、`E`、`f`、`F` 转换要出现在小数点后的位数，`g`、`G` 转换的最大有效位数，`s` 转换要写入的最大字节数。其中精度采用句点 `.` 后跟星号或可选的非负十进制整数（只指定句点表示精度为 0）。如果精度与其他的转换说明符一起出现则行为未定义；
  - **可选的长度修饰符**，用于指定实参的大小；
  - **指定要应用的转换类型的转换说明符**。

字符的精度或宽度，都可以用 `*` 表示。此时需要提供一个 `int` 参数提供对应的数值，此时会插入一个宽度或精度参数到该转换说明符对应格式参数的位置之前。宽度提供负数表示左对齐的字符宽度；精度提供负数则精度将被忽略。

```c
printf("%*d", -5, 10);   // - 表示左对齐, 5 指定 %*d 的字符宽度至少为 5, 10 对应 "%d"
```

> 标志字符（flags）：

+ `-`：要求转换后的结果在字段内左对齐（未指定时右对齐），如 `"%-d"`、`"%-.2f"`、`"%-10s"`；

- `+`：数值转换结果显示符号字符，未指定时数值时仅在负值时显示符号，如 `"%+lu"`；

+ ` `：空格，表示带符号转换不产生字符时，在结果前加一个空格（同时出现空格和 `+`，则忽略空格），如 `% d`；

- `#`：结果转换为替代模式：
  - 对于 `o` 转换，当且仅当必要时，它会增加精度，以强制结果的第一位为零，如果值和精度都为 0，则打印单个 0（`"%#o",9` = `"011"`，`"%#o",0` = `0`）；
  - 对于 `b` 转换，非零结果的前缀为 `0b`；
  - 对于可选的 `B` 转换，非零结果的前缀为 `0B`。
  - 对于 `x` （或 `"X"`） 转换，非零结果带有 `"0x"` （或 `"0X"`） 前缀；
  - 对于 `a`，`A`，`e`，`E`，`f`、`F`、`g`、`G` 转换，转换浮点数的结果总是包含一个小数点符号（通常，只有当小数点字符后面有一个数字时，它才会出现在这些转换的结果中。）。
  - 对于其他转换则行为未定义；

+ `0`：对于 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X`、`a`、`A`、`e`、`E`、`f`、`F`、`g`、`G` 转换，除非转换无穷大或 NaN，否则使用前导零（在任何符号或基数指示之后）用于填充字段宽度，而不是用空格填充。同时出现 `-` 和 `0` 则忽略前导零。对于 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 指定精度时，忽略前导零。对于其他的转换则行为未定义。

> 长度修饰符（length modifier）：

- `hh`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `signed char` 或 `unsigned char` 参数（参数将根据整数提升进行提升，但其值应在打印前转换为 `signed char` 或 `unsigned char`）；对于 `hhn` 适用于 `signed char` 类型的指针参数。 

+ `h`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `signed short` 或 `unsigned short` 参数；对于 `hn` 则适用于 `signed short` 类型的指针参数。 

- `l`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `signed long` 或 `unsigned long` 参数；对于 `ln` 则应用 `signed long` 类型的指针参数；`lc` 则应用 `wint_t` 参数；`ls` 应用 `wchar_t` 类型的指针参数；对于浮点数的转换说明符则没有效果。

+ `ll`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `signed long long` 或 `unsigned long long` 参数；对于 `lln` 则应用 `signed long long` 类型的指针参数。 

- `j`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `intmax_t` 或 `uintmax_t` 参数；对于 `jn` 则应用 `intmax_t` 类型的指针参数。 

+ `z`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `size_t` 或相应的有符号整数参数；对于 `zn` 则应用 `size_t` 类型的指针参数。 

- `t`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `ptrdiff_t` 或相应的无符号整数参数；对于 `tn` 则应用 `ptrdiff_t` 类型的指针参数。 

+ `w`*N*：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符应用于具有特定宽度的整数参数，其中 *N* 是不带前导零的十进制正整数（参数将根据整数提升进行提升，但其值应转换为未提升的类型）；对于 `w`*N*`n` 则应用指向具有 *N* 位宽度的整数类型参数的指针。应支持 `stdint.h` 头文件中定义的所有最小宽度整数类型和精确宽度整数类型。

- *`wf`*N：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符应用于最快最小宽度的整数参数，其中 *N* 是不带前导零的十进制正整数（参数将根据整数提升进行提升，但其值应转换为未提升的类型）；对于 `wf`*N*`n` 则应用指向具有 *N* 位宽度的最快最小整数类型参数的指针。应支持 `stdint.h` 头文件中定义的所有最快最小宽度整数类型和精确宽度整数类型。

+ `L`：指定 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 转换说明符应用 `long double` 类型参数。

- `H`：指定 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 转换说明符应用 `_Decimal32` 类型参数。

+ `D`：指定 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 转换说明符应用 `_Decimal64` 类型参数。

- `DD`：指定 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 转换说明符应用 `_Decimal128` 类型参数。

+ 如果长度修饰符与其他转换符一起出现，则行为未定义。

> 转换说明符：

- `d`、`i`：`int` 参数转换成有符号十进制整数 *[-]dddd* 形式。`%.*d` 精度指定要显示的最小位数，如果转换的位数不足则以前导零进行扩展（默认精度为 1，转换精度为 0 的零值 `%.d, 0` 结果是没有字符）。

+ `b`、`B`、`o`、`u`、`x`、`X`：`unsigned int` 参数分别转换形式为 *dddd* 的无符号二进制 `b` 或 `B`、无符号八进制 `o`、无符号十进制 `u`、无符号十六进制 `x` 或 `X`。精度指定要显示的最小位数，不足位数则以前导 0 填充。默认精度为 1。转换精度为零的零值的结果是没有字符。说明符 `B` 是可选的。

- `f`、`F`：表示浮点数的 `double` 转换为十进制 *[-]ddd.ddd* 形式。精度指定要显示的小数位数，未指定时默认精度为 6，舍入方式是四舍五入。若精度为 0 且未指定 `#` 标志，则不显示小数点字符。对于无穷大，则显示 `[-]inf` 或 `[-]infinity`；NaN 则显示为 `[-]nan` 或 `[-]nan(n-char-sequence)` 则是实现定义的。`F` 则分别显示为 `INF`、`INFINITY`、`NAN`。

+ `e`、`E`：表示浮点数的 `double` 转换为十进制 *[-]d.ddd±dd* 形式。精度指定要显示的小数位数，未指定时默认精度为 6，舍入方式为四舍五入。若精度为 0 且未指定 `#` 标志，则不显示小数点字符。`E` 则表示 `e[±dd]` 替换为 `E[±dd]`。指数总是至少包含两位数字，位数不足用零补齐。

- `g`、`G`：表示浮点数的 `double` 根据值和精度自动转换为 `e` 或 `f` 的样式。指定 $P$ 表示为精度，若精度未指定时 $P$ 为 6，精度为 0 时 $P$ 为 1。若带 `E` 的转换会有指数 $X$：若 $P$ > $X$ >= -4，转换为 `f` 的样式及精度 $P$ - 1 - $E$；否则为 `e` 风格及精度 $P$ - 1。除非使用 `#` 标志，否则将从结果的小数部分中删除任何尾随零，如果没有剩余的小数部分，则将删除小数点字符。

+ `a`、`A`：表示浮点数的 `double` 转换为十六进制 P 计数法下的 *[-]0xh.hhhp±d* 形式。精度指定要显示的小数位数，若精度为 0 且未指定 `#` 标志，则不显示小数点字符。若参数是正规化的浮点值，则首位数非 0。若值为 0，则指数为 0。指数总是至少包含一位数字。

- `c`：没有长度修饰符 `l` 则转换 `int` 参数为 `unsigned char`，并写入结果字符。若使用 `l` 修饰，则 `wint_t` 参数就像由一个没有精度的 `%ls` 转换规范和一个指向 `wchar_t[2]` 双元素数组的初始元素的参数进行转换，第一个元素包含指向 `lc` 转换规范的 `wint_t` 参数，第二个元素包含一个空宽字符。

+ `s`：没有长度修饰符 `l` 则实参是指向字符类型数组的指针，数组中的字符写到空终止符 `\0`。精度指定写入字符的最大数目。未指定精度或精度大于数组的大小，则数组必须包含空终止符。若使用了长度修饰符 `l` 则参数必须是指向 `wchar_t` 数组。

- `p`：实参是指向 `void` 的指针。指针的值以实现定义的方式转换为一系列打印字符。

+ `n`：实参应该是一个指向有符号整数的指针 `int *`，该指针表示调用 `fprintf` 到目前为止写入输出流的字符数。该转换符不会转换任何类型，但是会占用一个格式参数（必须是 `int *`），并且会将当前位置的字符数结果被写入到参数中。转换规范中不可包含任何标志，宽度，精度。
- `%`：`%%` 打印一个 `"%"` 百分号。没有参数被转换。

对于 `e`、`E`、`f`、`F`、`g` 和 `G` 转换，有效十进制位数的数量最多是对应类型的 `T_DECIMAL_DIG`（如 `FLT_DECIMAL_DIG`）的最大值 *M*，那么结果应该是正确的四舍五入。如果有效十进制位数的数量多于 *M*，但是源值可以用 *M* 数字精确地表示，那么结果应该是带末尾零的精确表示。否则，源值被两个相邻的十进制字符串 *L < U* 包围，其中字符串 *L* 和 *U* 都有 *M* 位有效数字；所得到的十进制字符串 *D* 的值应满足 *L ≤ D ≤ U*，并附带一个额外的规定，即误差应具有当前舍入方向的正确符号。

> *格式转换案例*

```c
#include <stdio.h>
 
int main(void)
{
    printf("%s", "Strings:\n");
    const char s[] = "Hello";
    printf("\t.%10s.\n\t.%-10s.\n\t.%*s.\n", s, s, 10, s);
 
    printf("Characters:\t%c %%\n", 65);
 
    printf("%s", "Integers\n");
    printf("Decimal:\t%i %d %.6i %i %.0i %+i %u\n", 1, 2, 3, 0, 0, 4, -1);
    printf("Hexadecimal:\t%x %x %X %#x\n", 5, 10, 10, 6);
    printf("Octal:\t%o %#o %#o\n", 10, 10, 4);
 
    printf("%s", "Floating point\n");
    printf("Rounding:\t%f %.0f %.32f\n", 1.5, 1.5, 1.3);
    printf("Padding:\t%05.2f %.2f %5.2f\n", 1.5, 1.5, 1.5);
    printf("Scientific:\t%E %e\n", 1.5, 1.5);
    printf("Hexadecimal:\t%a %A\n", 1.5, 1.5);
}
/*
Strings:
    .     Hello.
    .Hello     .
    .     Hello.
Characters:     A %
Integers
Decimal:        1 2 000003 0  +4 4294967295
Hexadecimal:    5 a A 0x6
Octal:          12 012 04
Floating point
Rounding:       1.500000 2 1.30000000000000004440892098500626
Padding:        01.50 1.50  1.50
Scientific:     1.500000E+00 1.500000e+00
Hexadecimal:    0x1.8p+0 0X1.8P+0
*/
```

> *十进制浮点数格式化输出*

```c
int main(){
	_Decimal32 x = 6543.00DF; // (+1, 654300, -2)
	fprintf(stdout, "%Ha\n", x);  	  // 6543.00		
	fprintf(stdout, "%.6Ha\n", x);	  // 6543.00
	fprintf(stdout, "%.5Ha\n", x);	  // 6543.0
	fprintf(stdout, "%.4Ha\n", x);	  // 6543
	fprintf(stdout, "%.3Ha\n", x);	  // 6.54e+3
	fprintf(stdout, "%.2Ha\n", x);	  // 6.5e+3
	fprintf(stdout, "%.1Ha\n", x);	  // 7e+3
	fprintf(stdout, "%.0Ha\n", x);	  // 6543.00
}
```

>---
#### 9.4. 格式化输入

*scanf-like* 函数参数 `format` 指定可接受的输入序列以及如何将它们转换为赋值，并使用后续对应参数作为指向对象的指针来接收转换后的输入。格式字符串由下列内容组成：
  - **非空白多字节字符**，除了 `%`：每个格式字符串中的这种字符处理来自输入流的准确同一字符，或若它与流的下个字符比较不相等则导致函数失败。
  - **空白符**：任何格式字符串中的单个空白符处理所有来自输入的可用连续空白符（符合 `isspace` 规定）。格式字符串中 `"\n"`、`" "`、`"\t\t"` 或其他空白无区别。
  - **转换规范**：转换规范由字符 `%` 表示，在 `%` 之后，依次出现以下内容：
    - 可选的赋值抑制字符 `*`；
    - 可选的大于零的十进制整数，指定最大字符宽度（如不提供宽度，`%s`、`%[` 可能会导致缓冲区溢出）；
    - 可选的长度修饰符，指定接收对象的类型大小；
    - 指定要应用的转换类型的转换说明符。

格式输入函数会依次执行该 `format` 格式的每个指令。当所有的指令都被执行完，或其中一个指令失败时函数返回。失败被描述为输入失败（编码错误或输入字符不可用）或匹配失败（不适当的输入）。空白字符不被读取，除非有指令匹配。

> 长度修饰符： 	

- `hh`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `signed char` 或 `unsigned char` 的指针参数。

+ `h`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `signed short` 或 `unsigned short` 的指针参数。

- `l`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 适用于指向 `long int` 或 `unsigned long` 的指针参数；指定 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 适用于指向 `double` 的指针参数；指定的 `c`、`s` 或 `[` 转换说明符应用于指向 `wchar_t` 的指针参数。

+ `ll`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `long long` 或 `unsigned long long` 的指针参数。

- `j`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `intmax_t` 或 `uintmax_t` 的指针参数。

+ `z`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `size_t` 或相应的有符号整数类型的指针参数。

- `t`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `ptrdiff_t` 或相应的无符号整数类型的指针参数。

+ `w`*N*：指定的 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 转换说明符应用于指向具有特定宽度的整数的指针参数，其中 *N* 是不带前导零的十进制正整数。

- `wf`*N*：指定的 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 转换说明符应用于指向具有特定宽度的最快最小宽度整数的指针参数，其中 *N* 是不带前导零的十进制正整数。

+ `L`：指定的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 应用于指向 `long double` 的指针参数。

- `H`：指定的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 应用于指向 `_Decimal32` 的指针参数。

+ `D`：指定的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 应用于指向 `_Decimal64` 的指针参数。

- `DD`：指定的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 应用于指向 `_Decimal128` 的指针参数。

> 转换说明符：

- `d`：匹配一个可选的有符号十进制整数，对应的实参是一个指向 `int` 的指针，除非指定了长度修饰符。

+ `b`：匹配一个可选的有符号二进制整数，对应的实参是一个指向 `unsigned int` 的指针，除非指定了长度修饰符。

- `i`：匹配一个可选的有符号整数，对应的实参是一个指向 `int` 的指针，除非指定了长度修饰符。

+ `o`：匹配一个可选的有符号八进制整数，对应的实参是一个指向 `unsigned int` 的指针，除非指定了长度修饰符。

- `u`：匹配一个可选的有符号十进制整数，对应的实参是一个指向 `unsigned int` 的指针，除非指定了长度修饰符。

+ `x`：匹配一个可选的有符号十六进制整数，对应的实参是一个指向 `unsigned int` 的指针，除非指定了长度修饰符。

- `a`、`e`、`f`、`g`：匹配可选的有符号浮点数、infinity、NaN。对应的实参是一个指向 `float` 的指针，除非指定了长度修饰符。

+ `c`：匹配正好指定字段宽度的字符序列（未指定字段宽度则为 1）。
  + 若没有长度修饰符，对应的参数是一个足够容纳字符序列的指向 `char`、`signed char`、`unsigned char` 或 `void` 的指针。不会添加空终止符。
  + 若存在 `l` 修饰，则输入应该是一个从初始移位状态开始的多字节字符序列，每个多字节字符被转换为宽字符，对应的实参应该是指向 `wchar_t` 数组初始元素的指针。不会添加宽空终止符。

- `s`：匹配非空白字符序列。
  - 若没有长度修饰，对应的参数是一个足够大的指向 `char`、`signed char`、`unsigned char` 或 `void` 的指针，该数组可以容纳字符序列和一个空终止符（null 字符被自动添加）。
  - 若存在 `l` 则输入应该是一个从初始移位状态开始的多字节字符序列，每个多字节被转换为宽字符，对应的实参应该是指向 `wchar_t` 数组初始元素的指针，宽空终止符会被自动添加。

+ `[`：匹配一组预期字符（扫描集）的非空字符序列。
  + 若没有长度修饰，对应的参数是一个足够大的指向 `char`、`signed char`、`unsigned char` 或 `void` 的指针，该数组可以容纳字符序列和一个空终止符（null 字符被自动添加）。
  + 若存在 `l` 则输入应该是一个从初始移位状态开始的多字节字符序列，每个多字节被转换为宽字符。对应的实参应该是指向 `wchar_t` 数组初始元素的指针，宽空终止符会被自动添加。
  + 若集合的首字符是 `^`，则匹配所有不在集合中的字符。若集合以 `]` 或 `]^` 开始，则 `]` 字符包含在集合中。`-` 可以指示范围（如 `[0-9]`）。

- `p`：匹配定义一个指针的实现定义的字符序列。该序列集应与 `fprinf` 的 `%p` 转换可能产生的序列集相同。对应的实参是指向指向 `void` 的指针的指针（`void **`）。如果输入项是在同一程序执行期间较早转换的值，则结果指针应与该值相等；否则 `%p` 转换的行为未定义。

+ `n`：返回已读取的字符数，且不消耗任何输入。相应的参数应是有符号整数类型的指针。执行 `%n` 指令不会增加 `scanf` 系列函数执行完成时返回的赋值计数。如果转换规范包括禁止赋值的字符或字段宽度，则行为未定义。

- `%%`：匹配单个字符 `'%'`。

+ 转换说明符 `A`、`E`、`F`、`G` 和 `X` 也是有效的，其行为分别与 `a`、`e`、`f`、`g` 和 `x` 相同。

> *格式转换案例*

```c
#define _CRT_SECURE_NO_WARNINGS 1 // 0
#include <stdio.h>
#include <stddef.h>
#include <locale.h>

int main(void)
{
	int i, j;
	float x, y;
	char str1[10], str2[4];
	wchar_t warr[2];
	setlocale(LC_ALL, "en_US.utf8");

	char input[] = "25 54.32E-1 Thompson 56789 0123 56ß水";
	/* 按下列分析：
	   %d ：整数
	   %f ：浮点值
	   %9s ：最多有 9 个非空白符的字符串
	   %2d ： 2 位的整数（数位 5 和 6 ）
	   %f ：浮点值（数位 7 、 8 、 9）
	   %*d ：不存储于任何位置的整数
	   ' ' ：所有连续空白符
	   %3[0-9] ：至多有 3 个十进制数字的字符串（数位 5 和 6 ）
	   %2lc ：二个宽字符，使用多字节到宽转换  */
	int ret = sscanf(input, "%d%f%9s%2d%f%*d %3[0-9]%2lc",
		&i, &x, str1, &j, &y, str2, warr);

	printf("Converted %d fields:\ni = %d\nx = %f\nstr1 = %s\n"
		"j = %d\ny = %f\nstr2 = %s\n"
		"warr[0] = U+%x warr[1] = U+%x\n",
		ret, i, x, str1, j, y, str2, warr[0], warr[1]);

	int n = sscanf_s(input, "%d%f%s", &i, &x, str1, (unsigned)sizeof(str1));
	// 写 25 到 i ， 5.432 到 x ， 9 个字节 "thompson\0" 到 str1 ，和 3 到 n 。
}
```

>---
#### 9.5. 时间格式化输出

```c
size_t strftime( char* restrict str, size_t count, const char* restrict format, const struct tm* restrict tp );
```

`strftime` 按照格式 `format`，转换给定 `tp` 的日期和时间信息为字符串。`format` 中每个转换符都应替换为以下描述的适当字符。适当的字符应该使用当前语言环境的 `LC_TIME` 类别以及 `timeptr` 指向的分解时间结构的零个或多个成员的值来确定。

```c
//=== 符号类
"%%"      // 符号 "%"
"%n"      // 换行符 "\n"
"%t"      // 水平制表符 "\t"

//===  year  年  (tm_year)
"%y"      // 写年的末两位数字 [00,99].
"%Y"      // 以四位十进制写年, 1997.
"%Ey"     // 将年写作本地环境的替用时期 %EC 的偏移 (本地环境依赖).
"%EY"     // 依据区域设置, 以完整替用方式写年, 例如在 ja_JP 环境中, 以 "平成23年" 取代 "2011年". 
"%Oy"     // 以替用数字系统写年的末 2 位数字, 例如在 ja_JP 环境中以 "十一" 取代 "11".
"%C"      // 写年的首两位数字 [00,99].
"%EC"     // 依据区域设置, 以替用表示写年份基底 (时期)，例如 ja_JP 中的 "平成".
"%g"      // 写基于 ISO 8601 的年后两位 [00,99]，包含指定星期.  (tm_year,tm_wday,tm_yday)
"%G"      // 写基于 ISO 8601 的年, 包含指定星期.  (tm_year,tm_wday,tm_yday)

//=== month  月  (tm_mon)
"%b"      // 写缩略月名, 例如 Oct.
"%Ob"     // 替换为区域设置的缩写替代月份名称
"%h"      // 相当于 b.
"%B"      // 写完整月名, 例如 October.
"%OB"     // 依据区域设置, 以替用表示写完整月名.
"%m"      // 将月写作十进制数, [01,12].
"%Om"     // 依据区域设置, 以替用数字系统写月, 例如 ja_JP 本地环境中 "十二" 取代 "12".

//=== weekday 星期  (tm_year,tm_wday,tm_yday)
"%U"      // 以十进制数写年的星期, 星期日是星期的首日, [00,53].
"%OU"     // 依据区域设置, 以替用数值系统写如同用 %U 的年的星期, 例如 "五十二" 在 ja_JP 中取代 "52".
"%W"      // 以十进制数写年的星期, 星期一是星期的首日, [00,53].
"%OW"     // 依据区域设置, 以替用数值系统写如同用 %W 的年的第星期, 例如 "五十二" 在 ja_JP 中取代 "52".
"%V"      // 写 ISO 8601 的年的星期, [00,53].
"%OV"     // 依据区域设置, 以替用数值系统写如同用 %V 的年的星期, 例如 "五十二" 在 ja_JP 中取代 "52".

//=== day of year/month 年/月之日  (tm_mday)
"%j"      // 以十进制数写年的第几日, [001,366].  (tm_yday) 
"%d"      // 以十进制数写月的第几日, [01,31].
"%Od"     // 依据区域设置, 以替用数字系统写零基的月的第几日, 例如 ja_JP 中 "二十七" 取代 "27", 单字符前加空格 (" 1").
"%e"      // 以十进制数写月的第几日, [01,31]. 单数字前加空格.
"%Oe"     // 依据区域设置, 以替用数字系统写一基的月的第几日, 例如 ja_JP 中 "二十七" 取代 "27", 单字符前加空格.

//=== day of week  星期之日  (tm_wday)
"%a"      // 写缩略的星期日期名, 例如 Fri.  
"%A"      // 写完整的星期日期名, 例如 Friday.
"%w"      // 以十进制数写星期日期, 其中星期日是 0, [0,6].
"%Ow"     // 依据区域设置, 用替用数字系统写星期日期, 其中星期日是 0. 例如 ja_JP 中 "二" 取代 "2".
"%u"      // 十进制数写星期日期, 其中星期一是 1, [1-7] (ISO 8601 格式).
"%Ou"     // 依据区域设置, 用替用数字系统写星期日期, 其中星期一是 1. 例如 ja_JP 中 "二' 取代 "2".

//=== hour/min/sec  时,分,秒  (tm_hour), (tm_min), (tm_sec)
"%H"      // 以十进制数写时, 24 小时制 [00-23].
"%OH"     // 依据区域设置, 以替用数字系统写 24 小时制的时, 例如 ja_JP 中 "十八" 取代 "18".
"%I"      // 以十进制数写时, 12 小时制 [01,12].
"%OI"     // 依据区域设置, 以替用数字系统写 12 小时制的时, 例如 ja_JP 中 "六" 取代 "6".
"%M"      // 以十进制数写分[00,59].
"%OM"     // 依据区域设置, 以替用数字系统写分, 例如 ja_JP 中 "二十五" 取代 "25".
"%S"      // 以十进制数写秒 [00,640]. 
"%OS"     // 依据区域设置, 以替用数字系统写秒, 例如 ja_JP 中 "二十四" 取代 "24".

//===== others
"%c"      // 写标准日期时间字符串, 例如 Sun Oct 17 04:41:13 2010.  (All)
"%Ec"     // 依据区域设置, 写替用日期时间字符串, 例如 ja_JP 中 "平成23年" 取代 "2011年".  (All)
"%x"      // 写本地化的日期表示.
"%Ex"     // 依据区域设置, 写替用日期表示, 例如 ja_JP 中 "平成23年" 取代 "2011年".  (All)
"%X"      // 写本地化的时间表示, 例如 18:40:20 或 6:40:20 PM.  (All)
"%EX"     // 依据区域设置, 写替用时间表示.  (All)
"%D"      // 等价于 "%m/%d/%y". (tm_mon, tm_mday, tm_year)
"%F"      // 等价于 "%Y-%m-%d", ISO 8601 日期格式.  (tm_mon, tm_mday, tm_year)
"%r"      // 写本地化的 12 小时制时间.  (tm_hour, tm_min, tm_sec)
"%R"      // 等价于 "%H:%M".  (tm_hour, tm_min)
"%T"      // 等价于 "%H:%M:%S", ISO 8601 时间格式.  (tm_hour, tm_min, tm_sec)
"%p"      // 写本地化的 a.m. 或 p.m.  (tm_hour)
"%z"      // 以 ISO 8601 格式（例如 -0430 ）写距 UTC 的偏移，或者倘若时区信息不可用则不写字符.  (tm_isdst)
"%Z"      // 写依赖本地环境的时区名或缩写，或者若时区信息不可用则不写字符.  (tm_isdst)
```

在 `"C"` 的区域设置中，`E` 和 `O` 被忽略，以下说明符的替换字符串为：

```c
"%a"      // %A 的前三个字符
"%A"      // "Sunday", "Monday", . . . , "Saturday" 之一
"%b"      // %B 的前三个字符
"%B"      // "January", "February", . . . , "December" 之一	
"%c"      // 相当于 "%a %b %e %T %Y"
"%p"      // "AM" 或 "PM" 之一
"%r"      // 相当于 "%I:%M:%S %p"
"%x"      // 相当于 "%m/%d/%y"
"%X"      // 相当于 "%T"
"%Z"      // 实现定义。
```

> strftime

```c
#include <stdio.h>
#include <time.h>
#include <locale.h>

int main(void)
{
    char buff[70];
    struct tm timer;
    time_t time_l = time(NULL);
    localtime_s(&timer, &time_l);

    setlocale(LC_TIME, "zh_CN.utf8");
    if (strftime(buff, sizeof buff, "[Native format]= %A %c", &timer))
        puts(buff); // [Native format]= 星期一 2000/1/1 0:00:00

    setlocale(LC_TIME, "en_us.utf8");
    if (strftime(buff, sizeof buff, "[USA format] = %A %c", &timer))
        puts(buff); // [USA format] = Monday 1/1/2000 0:00:00 AM
}
```

>---
#### 9.6. 原子操作

`stdatomic.h` 提供原子操作、互斥、条件变量的内建支持。

> 多线程执行和数据竞争

在没有定义 `__STDC_NO_THREADS__` 宏的宿主环境中，程序可以并发运行多个执行线程（或线程）。线程 *T* 在特定点上可见的对象的值是该对象的初始值、*T* 存储在该对象中的值或另一个线程存储在该对象中的值。如果其中一个表达式计算修改内存位置，而另一个表达式计算读取或修改相同的内存位置，则两个表达式计算会发生冲突。

`stdatomic.h` 库定义了原子操作，`threads.h` 定义了对互斥锁的操作，这些操作被特别标识为同步操作。对一个或多个内存位置的同步操作可以是 *获取操作*、*释放操作*、*获取和释放操作* 或 *消耗操作*。没有关联内存位置的同步操作是一个屏障（*fence*），可以是 *获取屏障*、*释放屏障*，或 *获取和释放屏障*。此外，还有不属于同步操作的 *宽松原子操作*，以及具有特殊特征的 *原子读-修改-写操作*。

例如，获取互斥锁的调用将对组成互斥锁的位置执行获取操作。相应地，释放相同互斥锁的调用将在这些相同的位置执行释放操作。非正式地，对 *A* 执行释放操作会强制其他内存位置上先前的副作用对稍后对 *A* 执行获取或消耗操作的其他线程可见。宽松的原子操作不包括在同步操作中，尽管与同步操作一样，它们不会导致数据争用。

对特定原子对象 *M* 的所有修改都以某种特定的总顺序发生，称为 *M* 的修改顺序。如果 *A* 和 *B* 是原子对象 *M* 的修改，并且 *A* 发生在 *B* 之前，那么 *A* 应按照 *M* 的修改顺序在 *B* 之前。每个原子对象都有单独的顺序。以原子对象 *M* 上的释放操作 *A* 为首的释放序列是 *M* 修改顺序中副作用的最大连续子序列，其中第一个操作是 *A*，每个后续操作要么由执行释放的同一线程执行，要么是 *原子读-修改-写操作*。

某些库调用与另一个线程执行的其他库调用同步（“*synchronizes with*”）。对对象 *M* 执行释放操作的原子操作 *A* 与对 *M* 执行获取操作的原子操作 *B* 同步，并读取以 *A* 为首的释放序列中任何副作用写入的值。同步操作定义了何时读取另一个值。对于原子变量，对给定互斥锁的所有操作都以单一的总顺序发生，每个获取互斥锁都会 “读取” 上一次释放互斥锁时 “写入的值”。

如果满足下列条件，则求值 *A* 依赖于（*carries a dependency*，“*synchronizes with*” 关系的子集）求值 *B*：
- *A* 的值用作 *B* 的操作数，除非：
  - *B* 是 `kill_dependency` 宏的调用，
  - *A* 是 `&&` 或 `||` 运算符的左操作数；
  - *A* 是 `? :` 运算符的左操作数，或，
  - *A* 是 `,` 运算符的左操作数。
- 或，*A* 写入标量对象或位域 *M*，*B* 从 *M* 中读取 *A* 写入的值，并且 *A* 顺序在 *B* 之前，或
- 对于某些求值 *X*，*A* 对 *X* 有依赖，*X* 对 *B* 有依赖。

如果满足以下条件，则求值 *A* “*dependency-ordered before*” 求值 *B*（类似于 “*synchronizes with*”，但是使用 *释放 / 消耗* 来代替 *释放 / 获取*）：
- 求值 *A* 对原子对象 *M* 执行释放操作，在另一个线程中，求值 *B* 对 *M* 执行消耗操作，并读取在释放序列中以求值 *A* 为首的任何副作用写入的值，或者；
- 对于某些求值 *X*，求值 *A* “*dependency-ordered before*” 求值 *X*，并且 *X* 对 *B* 有依赖关系。

如果求值 *A* “*synchronizes with*” 求值 *B*，或求值 *A* “*dependency-ordered before*” 求值 *B*，或对于下列的某些求值 *X*，则求值 *A* “*inter-thread happens before*” 求值 *B* ：
- *A* “*synchronizes with*” *X*，*X* “*sequenced before*” *B*；
- *A* “*sequenced before*” *X*，且 *X* “*inter-thread happens before*” *B*；
- *A* “*inter-thread happens before*” *X*，且 *X* “*inter-thread happens before*” *B*。

“*inter-thread happens before*” 关系描述了 “*sequenced before*”、“*synchronizes with*” 和 “*dependency-ordered before*” 关系的任意串联，但有两个例外。
- 第一个例外是，串联不允许以 “*dependency-ordered before*” 后跟 “*sequenced before*” 结尾。造成此限制的原因是，参与 “*dependency-ordered before*” 关系的消耗操作仅针对此消耗操作具有依赖关系的操作提供排序。此限制仅适用于以此类串联结尾的原因是，任何后续发布操作都将为先前的消费操作提供所需的排序。
- 第二个例外是，串联不允许完全由 “*sequenced before*” 组成。这种限制的原因，一是允许 “*inter-thread happens before*” 被传递地关闭，二是 “*happens before*” 关系提供了完全由 “*sequenced before*” 组成的关系。

如果求值 *A* “*sequenced before*” 求值 *B*，或 *A* “*inter-thread happens before*” *B*，则求值 *A* “*happens before*” 求值 *B*。实现应确保没有程序执行在 “*happens before*” 关系的循环中。

对象 *M* 的可见副作用（“*visible side effect*”）*A* 相对 *M* 的值的计算过程 *B* 应满足：*A* *happens before* *B*；且 *X* 对 *M* 没有其他副作用，因此 *A* *happens before* *X*，*X* *happens before* *B*。由求值 *B* 确定的非原子标量对象 *M* 的值应为可见副作用 *A* 存储的值。

如果对非原子对象的副作用存在歧义，则存在数据争用，并且行为未定义。这说明对普通变量的运算不会明显地重新排序。如果没有数据争用，这是无法检测到的，但可以确保数据争用以及对原子的使用有适当的限制，与简单交错（顺序一致）执行中的数据争用相对应。由求值 *B* 确定的原子对象 *M* 的值应为修改 *M* 的某个副作用 *A* 存储的值，其中 *B* 在 *A* 之前不会发生。

***写-写一致性*** (***write-write coherence***)：如果修改原子对象 *M* 的操作 *A* 发生在修改 *M* 的操作 *B* 之前，则 *A* 在 *M* 的修改顺序上应早于 *B*。

***读-读一致性*** (***read-read coherence***)：如果原子对象 *M* 的值计算 *A* 发生在 *M* 的值计算 *B* 之前，并且 *A* 从 *M* 上的副作用 *X* 中获取其值，则 *B* 计算的值应为 *X* 存储的值或副作用 *Y* 在 *M* 上存储的值，其中 *Y* 按照 *M* 的修改顺序跟随 *X*。

***读-写一致性*** (***read-write coherence***)：如果原子对象 *M* 的值计算 *A* 发生在对 *M* 的操作 *B* 之前，则 *A* 应从 *M* 上的副作用 *X* 中获取其值，其中 *X* 在 *M* 的修改顺序中先于 *B*。

***写-读一致性*** (***write-read coherence***)：如果原子对象 *M* 上的副作用 *X* 发生在 *M* 的值计算 *B* 之前，则求值 *B* 应从 *X* 或沿 *M* 的修改顺序跟随 *X* 的副作用 *Y* 中获取其值。

如果程序在不同的线程中包含两个冲突的操作，其中至少有一个不是原子的，并且都没有先于另一个发生，则程序的执行包含数据争用。任何此类数据争用都会导致未定义行为。

> 顺序与一致性


```c
typedef enum{
    memory_order_relaxed = __ATOMIC_RELAXED,
    memory_order_consume = __ATOMIC_CONSUME,
    memory_order_acquire = __ATOMIC_ACQUIRE,
    memory_order_release = __ATOMIC_RELEASE,
    memory_order_acq_rel = __ATOMIC_ACQ_REL,
    memory_order_seq_cst = __ATOMIC_SEQ_CST
} memory_order;
```
枚举类型 `memory_order` 指定上节定义的常规（非原子）内存同步操作，并提供可能的操作排序。它的枚举常量如下：
  - `memory_order_relaxed`	无需排序（宽松顺序）。
  - `memory_order_consume`	加载操作将充当内存位置上的消耗操作。
  - `memory_order_acquire`	加载操作将充当内存位置上的获取操作。
  - `memory_order_release`	存储操作将充当内存位置上的释放操作。
  - `memory_order_acq_rel`	将 `memory_order_acquire` 和 `memory_order_release` 结合。
  - `memory_order_seq_cst`	将 `memory_order_acquire` 和 `memory_order_release` 结合。标记为 `memory_order_seq_cst` 的内存访问必须顺序一致。

对于 `memory_order_relaxed`，无操作排序内存。

对于 `memory_order_release`、`memory_order_acq_rel` 和 `memory_order_seq_cst`，存储操作对受影响的内存位置执行释放操作。

对于 `memory_order_acquire`、`memory_order_acq_rel` 和 `memory_order_seq_cst`，加载操作对受影响的内存位置执行获取操作。

对于 `memory_order_consume`，加载操作对受影响的内存位置执行消耗操作。

所有 `memory_order_seq_cst` 操作上应该有一个单一的总排序 *S*，与所有受影响位置的 “*happens before*” 顺序和修改顺序一致，以便每个从原子对象 *M* 加载值的 `memory_order_seq_cst` 操作 *B* 都会观察到以下值之一：
- 在 *S* 排序中的操作 *B* 之前，观察到对 *M* 进行最后一次修改操作 *A* 的结果（如果存在），或者
- 如果 *A* 存在，则观察到对 *M* 进行某些修改的结果，该修改不是 `memory_order_seq_cst`，且在 *A* 之前不会发生，或者
- 如果 *A* 不存在，则观察到对 *M* 进行某些操作（非 `memory_order_seq_cst`）的结果。

虽然没有明确要求 *S* 包含锁定操作，但它始终可以扩展到包含锁定和解锁操作的顺序，因为这些操作之间的排序已经包含在 “*happens before*” 排序中。

指定 `memory_order_relaxed` 的原子运算仅在内存排序方面有所放宽。实现仍然保证对特定原子对象的任何给定原子访问相对于对该对象的所有其他原子访问是不可分割的。

对于读取原子对象 *M* 值的原子操作 *B*，如果存在一个 `memory_order_seq_cst` 屏障 *X* *sequenced before* *B*，则 *B* 要么观察到 *M* 在 *X* 之前以单一总排序 *S* 的最后一次 `memory_order_seq_cst` 的修改，要么观察到 *M* 自身的修改顺序的最近一次修改。

对于原子对象 *M* 上的原子运算 *A* 和 *B*，其中 *A* 修改 *M* 并且 *B* 取其值，如果有一个 `memory_order_seq_cst` 屏障 *X*，使得在单一总排序 *S* 上，*A* “*sequenced before*” *X* 且 *B* 紧随 *X* 之后，则 *B* 要么是观察到 *A* 副作用，要么观察到 *M* 自身的修改顺序的最近一次修改。

对于原子对象 *M* 的原子修改 *A* 和原子修改 *B*，如果满足以下条件，则在 *M* 的修改顺序中，*B* 发生在 *A* 之后：
- 存在一个 `memory_order_seq_cst` 屏障 *X*，使得在单一总排序 *S* 上，*A* “*sequenced before*” *X*，且 *X* 先于 *B*；或
- 存在一个 `memory_order_seq_cst` 屏障 *Y*，使得在单一总排序 *S* 上，*Y* “*sequenced before*” *B*，且 *A* 先于 *X*；或
- 存在 `memory_order_seq_cst` 屏障 *X* 和 *Y*，使得在单一总排序 *S* 上，*A* “*sequenced before*” *X*，*Y* “*sequenced before*” *B*，且 *X* 先于 *Y*。

原子 *读-修改-写操作* 应始终读取与 *读-修改-写操作* 关联的写入之前存储的最后一个值（按修改顺序）。

原子存储应仅存储通过有限程序求值序列，从常量和程序输入值中计算得出的值，以便每个求值都可以观察存储的有序列中最后一个先前赋值计算的对象值。按此序列进行求值的顺序如下：
- 如果求值 *B* 观察到 *A* 在不同线程中计算的值，则 *B* 不会在 *A* 之前发生。
- 如果序列中包含求值 *A*，则还包括分配给同一对象并在 *A* 之前发生的所有求值。

实现应使原子存储在合理的时间内对原子加载可见。

> Fences（屏障）

屏障可以有获取语义、释放语义、或两者都有。具有获取语义的屏障称为 *获取屏障*；具有释放语义的屏障称为 *释放屏障*。

对于释放屏障 *A* 与获取屏障 *B*，如果存在原子操作 *X* 和 *Y*，且两者都对某个原子对象 *M* 进行操作，并使得 *A* *sequenced before* *X*，*X* 修改 *M*，*Y* *sequenced before* *B* 且 *Y* 读取由 *X* 写入的值或由假定的释放序列 *X*（如果它是释放操作）中的任何副作用写入的值，则释放屏障 *A* 与获取屏障 *B* 同步。

对于释放屏障 *A* 与原子操作 *B*，原子操作 *B* 对原子对象 *M* 执行获取操作，如果存在原子操作 *X*，使得 *A* *sequenced before* *X*，*X* 修改 *M*，*B* 读取由 *X* 写入的值或由假定的释放序列 *X*（如果它是释放操作）中的任何副作用写入的值，则释放屏障 *A* 与原子操作 *B* 同步。

对于原子操作 *A* 和释放屏障 *B*，原子操作 *A* 在原子对象 *M* 上执行释放操作，如果在 *M* 上存在某俄歇原子操作 *X*，使得 *X* *sequenced before* *B*，并且 *X* 读取由 *A* 写入的值或由以 *A* 为首的释放序列中的任何副作用写入的值，则原子操作 *A* 与释放屏障 *B* 同步。

```c
void atomic_thread_fence(memory_order order);
```

根据 `order` 的值，该操作 `atomic_thread_fence(order)`：
- `memory_order_relaxed`，没有效果；
- `memory_order_acquire` 或 `memory_order_consume`，是一个获取屏障；
- `memory_order_release`，是一个释放屏障；
- `memory_order_acq_rel`，是兼具释放和获取语义的屏障；
- `memory_order_seq_cst`，是顺序一致的释放和获取语义的屏障。

```c
void atomic_signal_fence(memory_order order);
```

`atomic_signal_fence` 等效于 `atomic_thread_fence(order)`，不同之处在于生成的排序约束仅在线程和在同一线程中执行的信号处理程序之间建立。`atomic_signal_fence` 函数可用于指定线程执行的操作对信号处理程序可见的顺序。

---