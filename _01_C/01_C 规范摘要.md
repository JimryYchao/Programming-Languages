## C 语法规范摘要

### 1. 基本概念

#### 1.1. 程序结构

作用域（范围）层次结构分为 *全局存储期* > *文件范围* > *函数范围* > *块范围*。所有 C 函数都是全局存储期。

变量的 **存储期** 分为 *静态存储期*、*线程存储期*、*自动存储期*、*动态分配存储期*。

标识符通过 **链接** 描述可见性，包括 `extern` 外部链接、`static` 内部链接、无链接。

标识符名称在各自 **名称空间** 中 *单一定义*：标签、结构、联合和枚举说明符、结构或联合的成员、标准属性和属性前缀、属性前缀令牌中的尾随标识符、普通标识符、typedef 名称。

```c
/* student 在各自的名称空间内具有唯一性 */
struct student {
   char student[20];
   int class;
   int id;
} student;
printf("%d", student.id);  
```

> **入口函数 Main**

```c
int/void main(void);
int/void main(int argc, char *argv[ ] <, char *envp[ ]>?);
int/void wmain(int argc, wchar_t *argv[ ], wchar_t *envp[ ]);   // 宽字符版本

// argc 命令行实参数量，至少为 1；
// argv 包含 argc+1 个指针，argv[0] 是程序名称，后面为命令行参数；
// envp 用户环境变量。
// return 隐式调用 exit(int rtCode)
```

>---
#### 1.2. 词法元素

> **标准关键字**

```cpp
static             // 内部链接                              
extern             // 外部链接                              
constexpr          // 常量表达式       
auto               // 类型推断 
thread_local       // _Thread_local，线程本地存储类说明符 
register           // 寄存器存储类说明符                    
typedef            // 类型别名                              
const              // 常量限定                              
inline             // 内联函数声明                          
restrict           // 参数引用类型声明                      
volatile           // 易变类型说明符  
_Atomic            // 原子类型限定                          

bool               // 布尔类型                     
char               // 字符类型                  
short              // 短整数类型                            
int                // 整数类型                              
long               // 长整数类型  
signed             // 有符号整数限定                        
unsigned           // 无符号整数限定  
float              // 单精度浮点类型                        
double             // 双精度浮点类型                        
void               // 无类型                                
enum               // 枚举类型                              
struct             // 结构类型                              
union              // 联合类型                              

false              // 布尔值，假          
true               // 布尔值，真                            
nullptr            // 空指针常量                            

if                 // if 条件分支语句                     
else               // if 条件分支语句 else 分支         
do                 // do 循环语句                         
while              // while 循环语句                      
for                // for 循环语句                        
switch             // switch 条件分支语句                 
case               // switch 语句 case 分支             
default            // switch 语句的默认分支               

break              // 跳出当前循环或分支                    
continue           // 跳转至控制语句
return             // 函数返回语句                          
goto               // 标签跳转语句                          
                        
alignas            // _Alignas，设置类型对齐要求          
alignof            // _Alignof，获取类型对齐要求    
sizeof             // 计算数据类型或变量所占字节数          
typeof             // 类型或对象反射，获得变量或函数的类型  
typeof_unqual      // 无限制 typeof   
static_assert      // _Static_assert，静态断言            
_Generic           // 泛型宏                                
noreturn           // 属性，函数不返回调用方                

_Imaginary         // 虚数类型                              
_Complex           // 复数类型                              
_BitInt            // 位精确整数                            
_Decimal32         // 32 位十进制数                         
_Decimal64         // 64 位十进制数                         
_Decimal128        // 128 位十进制数                        
```

> **运算符**

```c
[    ]    (    )    {    }    .    ->
++   --   &    *    +    -    ~    !
/    %    <<   >>   <    >    <=   =>   ==   !=   ^    |    &&   ||
?    :    ::   ;    ...
=    *=   /=   %=   +=   -=   <<=  >>=  &=   ^=   |=
,    #    ##
```

> 替用运算符 (iso646.h)

```c
&&		and
&=		and_eq
&		bitand
|		bitor
~		compl
!		not
!=		not_eq
||		or
|=		or_eq
^		xor
^=		xor_eq
```


> *替用记号（弃用）*

```c
// 双标符
{	<%		}	%>
[	<:		]	:>
# 	%:		##	%:%:
// 三标符
{	??<		}	??>
[	??(		]	??)
#	??=		\	??/
^	??'		|	??!
~	??-
```

---
### 2. 类型

#### 2.1. 内置类型

| Type                                     | Description                  |
| :--------------------------------------- | :--------------------------- |
| `void`                                   | 无类型                       |
| `bool`                                   | 布尔，`true` 和 `false`      |
| `nullptr`                                | 空指针常量，具有 `nullptr_t` |
| `char`                                   | 字符                         |
| `[signed] char/short/int/long/long long` | 有符号整数                   |
| `unsigned char/short/int/long/long long` | 无符号整数                   |
| `[signed]/unsigned _BitInt(N)`           | 指定宽度的整数               |
| `float`,`double`,`long double`           | 浮点数                       |
| `_Decimal32`,`_Decimal64`,`Decimal128`   | 十进制浮点数                 |
| `_Complex`,`_Imaginary`                  | 复数                         |

> **整数字面值**

| Suffix     | description                                                |
| :--------- | :--------------------------------------------------------- |
| `u`,`U`    | 无符号整数                                                 |
| `l`, `L`   | `long/long long`                                           |
| `ll`, `LL` | `long long`                                                |
| `wb`, `WB` | `_BitInt(N)`，宽度 N 是大于 1 的可以容纳值和符号位的最小值 |

```c
0b1010'0101            // 二进制
076543210              // 八进制
0xabcdef               // 十六进制 
0XABCDEF'01234'56789   // 十六进制 
```

> **浮点数字面值**


| Suffix     | Description                         |
| :--------- | :---------------------------------- |
| `f`, `F`   | `float`                             |
| `l`, `L`   | `long double`                       |
| `df`, `DF` | `_Decimal32`，32 位十进制浮点类型   |
| `dd`, `DD` | `_Decimal64`，64 位十进制浮点类型   |
| `dl`, `DL` | `_Decimal128`，128 位十进制浮点类型 |

```c
double d = 0x1.ap-132;   // P 十六进制计数法
float f = 3.14e15F;      // E 十进制计数法
```

一个浮点数由以下模型定义，ISO/IEC 60559 格式：

- $x = sb^e \sum_{k =1}^p f_k b^{-k}$，$e_{min} \leq e \leq e_{max}$
  - $s$：符号位（$\pm 1$）
  - $b$：指数表示的基数（大于 1 的整数）
  - $e$：指数（介于最小 $e_{min}$ 和 $e_{max}$ 之间的整数）
  - $p$：精度（以 $b$ 为基数的有效位数）
  - $f_k$：小于 $b$ 的非负整数（有效位数）

> **字符字面值**

字符常量可以是单或多字节序列。不能使用多字节表示宽字符。

```c
// 字面值
char c = 'A';      
int mc = '123';         // 多字节
wchar_t wc = L'A';      // 宽字符
char8_t c8 = u8'A';     // UTF-8
char16_t c16 = u'A';    // UTF-16
char32_t c32 = U'A';    // UTF-32

// 转义字符
char oct = '\64';       // \ oo     八进制，最大 \377
char hex = '\xff';      // \x hh    十六进制转义序列
char uni = '\u00f4';    // \u hhhh  
char Uni = '\U000000F4' // \U HHHHHHHH

// 转义字符
'\'' '\"' '\?' '\\' '\a' '\b' '\f' '\n' '\r' '\t' '\v'
```

>---
#### 2.2. Enum 枚举

枚举由一组命名整数常量构成，默认为 `int`。支持自增自减运算。

```c
enum DAY {
    saturday, // 0
    sunday = 0,
    monday,  // 1
    tuesday, // 2
    wednesday,
    thursday,
    friday
} workday = monday;

// 指定类型的枚举：
enum Month : unsigned char {
    Jan = 1, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec
}
```

>---
#### 2.3. Array 数组

数组类型的变量被视为指向数组首元的指针。

```c
char Str[] = "This is a String";    // 数组初始化时，长度可以省略
int arr[] = {1, 2, 3};              
int arr[5] = {0,1,2,3,4};           // 初始化器
int arr[5] = {[2] = 2};             // 指定初始化器，其他元素零初始化
int arr[5] = {};                    // 零初始化器

// 多维数组
int Arr[length0][length1];
int Arr[3][3][3][3];  //......多维数组
int Array[4][4] = {
	{1,2,3,4},
    {10,20,30,40},
    {100,200,300,400},
    {0,0,0,0}
}
int arr[2][3] = {[1][2] = 1};  
int arr[2][3] = {};     
int arr[2][3] = {1,2,3,4,5,6};  // 多维数组顺序初始化
```

不允许声明零长数组，试探性声明暂时被视为具有一个数值为 0 的数组。

```c
//------ 试探性声明 ------
int[] a;  // 暂认为是 a[] = {0}
```

函数参数 `T arr[static len]` 要求传入数组的长度至少为 `len`：

```c
int fun1(int a, int arr[static a]);
int fun2(int arr[restrict const static 5]);   // 传入的数组长度至少为 5
```

> 可变长度数组（VLA）

可以在函数域内 `typedef` 定义可变长度数组（VLA），这类对象称为可变修改对象（VM）。VLA 对象无法限定为 `thread_local`、`static`、`extern`。VLA 类型不能是结构或联合的成员。指向 VLA 数组的指针声明可以是 `static`。

```c
extern int n;
int A[n];                       // invalid: file scope VLA
extern int (*p2)[n];            // invalid: file scope VM
int B[100];                     // valid: file scope but not VM
void fvla(int m, int C[m][m]);  // valid: VLA with prototype scope
void fvla(int m, int C[m][m])   // valid: adjusted to auto pointer to VLA
{
    typedef int VLA[m][m];      // valid: block scope typedef VLA
    struct tag
    {
        int (*y)[n];            // invalid: y not ordinary identifier
        int z[n];               // invalid: z not ordinary identifier
    };
    int D[m];                   // valid: auto VLA
    int(*s)[m];                 // valid: auto pointer to VLA
    static int(*q)[m] = &B;     // valid: q is a static block pointer to VLA
    static int E[m];            // invalid: static block scope VLA
    extern int F[m];            // invalid: F has linkage and is VLA
    extern int(*r)[m];          // invalid: r has linkage and points to VLA
}
```

>---
#### 2.4. Struct 结构

结构声明描述了一个组织布局，可以嵌套类型如结构或联合。

```c
#include <stdio.h>
struct book {
	const char * Name;
	int price;
	struct inner { // 嵌套结构
      int cost;
    };
};
int main(void){
// 1. 外部声明
	struct book myBook;
	myBook.Name = "C Language";
	myBook.cost = 20;
	myBook.price = 99;

	struct inner myInner;
    myInner.cost = 20;
	
// 2. 块初始化
	struct book myBook2 = {
		"C Language", 20, 99
	};
// 3. 指定初始化器
	struct book mBook3 = {
		.Name = "C Language",
		.cost =20,
        .price = 99
	};
// 4. 匿名结构
	struct {
		const char * Name;
		int cost;
	} mBook4 = {
		.Name = "C Language",
		.cost = 20,
	};
}
```

> **灵活数组成员**

灵活数组成员只能作为结构的最后一个成员，且至少有一个非灵活数组成员。该数组不会立即存在，一般由分配函数（例如 `malloc`）分配灵活数组需要的额外内存空间。`sizeof` 表达式忽略灵活数组成员。灵活数组结构无法作为数组元素或其他结构的成员。

```c
struct flex {
	int count;
	double average;
	double scores[];   // 灵活数组
}
// 设置灵活数组长度为 5
struct flex * pf = (struct flex*)malloc(sizeof(struct flex) + 5 * sizeof(double));   // need free(pf)
auto sz = sizeof(*pf);     // sizeof(int) + sizeof(double)
```

> **结构成员的填充与对齐**

结构成员按其声明顺序从低到高存储。
- 结构体的对齐步骤：结构体各成员对齐 -> 结构体总体对齐。
- 结构体对齐规则：首成员位于结构偏移量 0 的地址。其他成员自身对齐时，地址为 min { 有效对齐值为自身对齐值，对齐系数 } 的最小整数倍的地址处（其中，自身对齐值表示成员自身大小；**对齐系数** 指宏 `pack(N)` 指定值或本机机器位数）。总体对齐时，结构体字节大小为 min { 所有成员自身对齐值最大值，对齐系数 } 的整数倍。
- 对齐系数：宏 `#pragma pack(N)` 指定的值，N 是 2 的幂次方，1、2、4 等。32 位 Linux 主机的默认对齐值为 4；64 位为 8；AMR CPU 为 8。

```c
// 64 位 Linux，默认系数为 8
typedef struct _st_struct1
{
	char 	a;		// 1
	short   b;		// 2
	int		c;		// 4
} st_struct1;
printf("%ld\n",sizeof(st_struct1)); // size = 8
/* PS
1. a 是 char 类型，占 1 个字节，第一个数据成员，放在结构体变量偏移量为 0 的地址处
2. b 是 short 类型，占 2 个字节，b 的有效对齐值为 min{2, 8}=2；
   依次查看 2 的整数倍地址是否可以存放 2 个字节；
   	【2×0 = 0】 此地址处已经存放 a
   	【2×1 = 2】 此地址为空，可以将 b 存放在地址偏移量为 2 和 3 处.
3. c 是 int 类型，占 4 个字节，c 的有效对齐值为 4
   对齐到 4 的整数倍地址，即地址偏移量为 4 处.在内存中存放的位置为 4,5,6,7
4. 结构体总对齐字节大小为 min{4, 8}=4 的整数倍，此时内存中共占 8 个字节，正好是 4 的整数倍，sizeof(st_struct1) = 8
*/

typedef struct _st_struct2
{
	char    a;     // 地址位 0
	int     c;     // 地址位 4
	short   b;     // 地址位 8
} st_struct2;
printf("%ld\n",sizeof(st_struct2));	// size = 12
```

`#pragma pack(N)` 指定用户定义对齐值，`#pragma unpack()` 取消用户定义。

```c
#pragma pack(1)    // 对齐遵循始终寻址为 1 的倍数的地址
typedef struct _st_struct3
{
 	char    a;     // 地址位 0
	int     c;     // 地址位 1
	short   b;     // 地址位 5
} st_struct3;      // 根据对齐规则，总体的结构体大小为 7
printf("%ld\n", sizeof(st_struct3)); // 7
#pragma unpack()   // 恢复系统默认的对齐特性
```

>---
#### 2.5. Bit Domain 位域

结构可包含比整型类型占用更少存储空间的位域成员。位字段只能是 `bool` 或 `int`、`char`、`short`，字段宽度不能超过其基础类型长度，值不可超过容纳范围。

```c
struct{
	unsigned int first : 4;   // 表明该字段占用的 bit
	unsigned int second : 2;
	unsigned int third : 8;
} BitDomain = {
	.first = 0b0010,
	.second = 0b10,
	.third = 0b10100101
};
```

一个字段无法跨越两个基础整数位之间的边界，编译器会自动移动跨界字段，以保持它们之间的边界对齐。

```c
struct
{									  // offset 
    unsigned int first : 9;				// 0
    unsigned int second : 7;            // 9
    unsigned int may_straddle : 30;     // 32
    unsigned int last : 18;             // 64
} Bits;						// sizeof = 3 * sizeof int

printf("%zd", sizeof Bits); // 防止跨越，12
```

匿名位字段表示填充，0 值匿名位字段表示使下一个位字段与下一个整数边界对齐。

```c
struct {
	unsigned int f0;  		// 成员 field_0 没有限制，占用 4B;
	unsigned int f1 : 1 ;
	unsigned int : 2 ;      // 2 位的填充
	unsigned int f2 : 1 ;
	unsigned int : 0 ;      // 迫使下一个位字段与 int 边界对齐
	unsigned int f3 : 1 ;
} Bits;
```

>---
#### 2.6. Union 联合

联合成员可以具有不同的类型，所有成员共享单个存储。联合大小与最大成员字节相同。联合可以具有位域，但不能包含不完整类型、`void` 或函数类型。

```c
// 声明
union sign
{
    int svar;
    unsigned uvar;
};	// size = 4

// 初始化
union sign digit = {99}; 	    // 默认初始化第一个元素
union sign val = {.uvar = 100};	// 指定成语初始化

// 具有位域的联合
union{ 		
	unsigned int a:1;
	unsigned int b:4;
	int value;
} BitUnion;	// size = 4

// 联合常嵌套在一个结构中
struct x
{
    int type_tag;
    union
    {
      int x;
      float y;
    };
};
```

>---
#### 2.7. Pointer 指针

可以为任何基本类型、结构或联合类型、函数、数组和其他指针对象创建关联指针。取址对象不能是位域、寄存器变量。`void*` 表示无类型指针，可以强制转换为（除 `char*` 类型外，隐式）其他类型的指针。指针可以是 `const`、`volatile` 限定。

```c
int number = 10;
int *pN = &number;     // 取址
int rt = *pN;	       // 解引用

int * pt;	// 未初始化指针
*pt = 5; 	// ERROR：对未初始化指针解引用行为未定义
```

在函数中传递结构、联合或数组的指针比传递对象本身效率更高。

```c
struct book{
	int cost;
} bp;
struct book * pbook = &bp;
pbook->cost = 99;		// -> 访问结构成员
pbook->cost = (*pbook).cost = bp.cost
```

> **指针基本操作**

```c
#include <stdio.h>
int main(void)
{
	int urn[5] = { 100, 200, 300, 400, 500 };
	int* ptr1, * ptr2, * ptr3;
	ptr1 = urn;				// 把一个地址赋给指针
	ptr2 = &urn[2];			// 把一个地址赋给指针
	printf("pointer value, dereferenced pointer, pointer address : \n");
// 1. 解引用指针，以及获得指针的地址
	printf("ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);
	printf("ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", ptr2, *ptr2, &ptr2);
// 2. 指针加法
	ptr3 = ptr1 + 4;
	printf("\nadding an int to a pointer:\n");
	printf("ptr1 + 4 = %p, *(ptr1 + 4) = %d\n", ptr1 + 4, *(ptr1 + 4));
// 3. 递增指针
	ptr1++;
	printf("\nvalues after ptr1++:\n");
	printf("ptr1 = %p, *ptr1 = %d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);
// 4. 递减指针
	ptr2--;
	printf("\nvalues after ptr2--:\n");
	printf("ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", ptr2, *ptr2, &ptr2);
	--ptr1; // 恢复为初始值
	++ptr2; // 恢复为初始值
	printf("\nPointers reset to original values:\n");
	printf("ptr1 = %p, ptr2 = %p\n", ptr1, ptr2);
// 5. 一个指针减去另一个指针
	printf("\nsubtracting one pointer from another:\n");
	printf("ptr2 = %p, ptr1 = %p, ptr2 - ptr1 = %td\n", ptr2, ptr1, ptr2 - ptr1);
// 6. 一个指针减去一个整数
	printf("\nsubtracting an int from a pointer:\n");
	printf("ptr3 = %p, ptr3 - 2 = %p\n", ptr3, ptr3 - 2);

	return 0;
}
/*
	pointer value, dereferenced pointer, pointer address :
	ptr1 = 010FFC9C, *ptr1 = 100, &ptr1 = 010FFC90
	ptr2 = 010FFCA4, *ptr2 = 300, &ptr2 = 010FFC84

	adding an int to a pointer:
	ptr1 + 4 = 010FFCAC, *(ptr1 + 4) = 500

	values after ptr1++:
	ptr1 = 010FFCA0, *ptr1 = 200, &ptr1 = 010FFC90

	values after ptr2--:
	ptr2 = 010FFCA0, *ptr2 = 200, &ptr2 = 010FFC84

	Pointers reset to original values:
	ptr1 = 010FFC9C, ptr2 = 010FFCA4

	subtracting one pointer from another:
	ptr2 = 010FFCA4, ptr1 = 010FFC9C, ptr2 - ptr1 = 2

	subtracting an int from a pointer:
	ptr3 = 010FFCAC, ptr3 - 2 = 010FFCA4
*/
```



> **指针和数组的关系**

数组标识符被视为指向数组首元的指针。数组内相邻元素地址对应关系：`&arr[n+1] = &arr[n]+1`。`arr[n]` 相当于 `*(arr + n)` （其中 `arr = &arr[0]`）。

```c
int arr[10] = {99};
if (arr == &arr[0]) {       // arr 值等于 &arr[0]	
	printf("\n%d",*arr);	// 99
}

int *pArr = arr;  // 等价于
int *pArr = &arr[0];
```

处理数组的函数实际上用指针作为参数。对于 `int Arr[Size]` 数组，`*(Arr+i)` 与 `Arr[i]` 等价。指针表示法更接近于机器语言，编译时能够生成效率更高的代码。

```c
// 指向多维数组的指针
int main(void) {
	int(Arr[2])[3] = {		// 二维数组
		{1,2,3},
		{2,3,4}
	};
	int Arr1[] = { 1,2,3,4 };
	int* pr[2] = { Arr1, &Arr1[1] };	// pr 是一个包含两个指针元素的数组
	int(*pr1)[3] = Arr;				    // pr1 指向一个内含两个 int 类型值的数组

	for (size_t i = 0; i < 2; i++)
	{
		printf("%p\n", pr1[i]);
		printf("%p\n", Arr[i]);
	}
}

// 对于 Arr[n][m][i][l]... 数组
int Arr[a][b][c][d];
int(*pr)[b][c][d] = Arr;

Arr[0][0][0][0] = ****pr = pr[0][0][0][0];
```

>---
#### 2.8. String 字符串

字符串是以 `\0` 结尾的字符序列。UTF8 字符串以 `u8` 为前缀，`wchar_t` 以 `L` 为前缀，UTF16 以 `u` 为前缀，UTF32 以 `U` 为前缀。

```c
char8_t* s8 = u8"Hello";
char* s = "Hello";
wchar_t * ws = L"Hello";
char16_t * s16 = u"Hello"; 
char32_t * s32 = U"Hello";    
```

字符串拼接要求它们的前缀相同或没有前缀。

```c
// 字符串拼接
char* hi = "Hello " "World";   
char* mul = "Long strings can be bro\
ken into two or more pieces."   

"a""b"L"c", "a"L"b""c", L"a""b"L"c", L"a"L"b"L"c"
// 等同于
L"abc"
```

窄字符串实际是具有 `char` 的类型数组，宽字符串是具有 `wchar_t` 的类型数组。`'\0'` 自动追加到字符串末尾。编译器优化策略会将具有相同字符串值的单个副本置于可执行文件中。

```c
char *str1 = "Hello";
char *str2 = "Hello";

int main(void)
{
	printf("pStr1: %p\n",str1);
	printf("pStr2: %p\n",str2);
}
/*
pStr1: 0000000000404000
pStr2: 0000000000404000
*/
```

> **字符串值初始化字符数组**

可以使用字符串文本（或宽字符串文本）初始化字符（或宽字符）的数组。

```c
char s[] = "abc";
// 等同于
char s[]  = {'a', 'b', 'c', '\0'};
```

如果指定数组长度小于字符串长度，则会忽略多余字符。

```c
char s[3] = "abcd";
// 等同于
char s[3] = {'a', 'b', 'c'};
```

> **格式化输出**

格式转换说明符：

```powershell
%a，%A      浮点数、十六进制数和 P 计数法（C99，C11）
%c          单个字符
%d          有符号十进制数
%e，%E      浮点数，e计数法
%f          浮点数，十进制
%g，%G      自动选择%f 或 %e
%i          有符号十进制整数
%o          无符号八进制整数
%p          指针
%s          字符串
%u          无符号十进制整数
%x，%X      无符号十六进制整数，使用十六进制数 0f，0F
%%          打印一个百分数符号 %
```

转换说明修饰符：在 `%` 和转换字符之间插入修饰符可修饰基本的转换说明。

```c
标记        -、+、空格、#、0，可以不使用标记或使用多个标记
数字        表示最小字段宽度

.数字       精度：%e、%E、%f 转换表示小数位位数
                %g、%G 转换表示有效数字的最大位数
                %s 转换表示待打印字符的最大数量
                整型转换，表示待打印数字的最小位数
                只使用 . 表示其后紧随一个0, %.f 等同于 %.0f;

h           与整型转换说明一起使用，表示 (unsigned) short int
hh          与整型转换说明一起使用，表示 signed char 或 unsigned char
j           与整型，表示 intmax_t 和 uintmax_t 类型
l           与整型，表示 (unsigned) long int
ll          与整型，表式 (unsigned) long long int
L           与浮点型，表示 long double
t           与整型，表示 ptrdiff_t (两个指针差值)
z           与整型，表示 size_t 类型，为 sizeof 返回类型
			%zd 返回类型规定为无符号整数，不同系统中，可能使用 %u，%lu，%llu
```

格式化输出中的标记：
 
```c
-           待打印项左对齐
+           显示数值符号，符号为正显示 +，符号为负显示 -
空格        有符号值若为正，在值前面显示前导空格；负则显示减号；+ 覆盖标记空格
%o          显示八进制前缀, 结果以 0 开始
%#x，%#X    显示十六进制前缀, 结果以 0x、0X 开始
%#g，%#G	防止结果后面的 0 被删除(近似数)
0N          N 数值类型，用前导 0 代替空格填充字段宽度
整数        出现 - 左对齐标记或者指定精度，则忽略前导 0
```

格式化输出案例：

```c
#include <stdio.h>
#define PAGES 959
int main(void)
{
	// 字符宽度
    printf("*%d*\n", PAGES);			// *959*
    printf("*%2d*\n", PAGES);			// *959*
    printf("*%10d*\n", PAGES);			// *       959*
    printf("*%-10d*\n", PAGES);			// *959       *
	// 一些浮点型修饰符的组合
	const double RENT = 3852.99; 	
    printf("*%f*\n", RENT);			    // *3852.990000*
    printf("*%e*\n", RENT);			    // *3.852990e+03*
    printf("*%4.2f*\n", RENT);			// *3852.99*
    printf("*%3.1f*\n", RENT);			// *3853.0*
    printf("*%10.3f*\n", RENT);			// *  3852.990*
    printf("*%10.3E*\n", RENT);			// * 3.853E+03*
    printf("*%+4.2f*\n", RENT);			// *+3852.99*
    printf("*%010.2f*\n", RENT);		// *0003852.99*
	// 标记
	printf("%x %X %#x\n", 31, 31, 31);	// 1f 1F 0x1f
	printf("**%d**% d**% d**%+d**\n", 42, 42, -42, 42);	  // **42** 42**-42**+42**
	printf("**%5d**%5.3d**%05d**%05.3d**\n", 6, 6, 6, 6); // **    6**  006**00006**  006**
	
	// 字符串格式化输出
#define BLURB "Authentic imitation!"
	printf("[%2s]\n", BLURB);         // 最小2宽度
    printf("[%24s]\n", BLURB);        // 最小24宽度
	printf("[%24.5s]\n", BLURB);      // 最小24宽度, 5字符宽度
    printf("[%-24.5s]\n", BLURB);     // 左对齐,最小24宽度,5字符宽度
	/*
	    [Authentic imitation!]
        [    Authentic imitation!]
        [                   Authe]
        [Authe                   ]
	*/
}
```

转换说明参数传递机制。参数传递机制因实现而异：
- 就 `printf("%ld %ld %ld %ld\n", n1, n2, n3, n4)`，对于 `float` n1、n2，系统仍会将 `float (4B)` 转换成 `double (8B)` 储存在栈中，n3、n4 紧随压入栈中。
- `%ld` 转换说明，取参数读取栈中数据应读取 4 字节的 `long` 类型，但将 n1 的前半部分作为第一个参数，后半部分作为第二个参数。因此出现 `printf` 读错了字节导致转换说明出错。

```c
float n1= 1.0f, n2 = 2.0f;
long  n3 = 3L, n4 = 4L;
printf("%ld %ld %ld %ld\n",n1, n2, n3, n4); // 0 0 3 4
```

---
### 3. 类型声明与类型限定

#### 3.1. auto 类型推断

`auto` 常与其他存储类说明符一起出现，表示类型推断。

```c
static auto Hi = "Hello World";   // string
auto p = (struct {int x; } *)0;   // struct {int x;} * 
auto alignas (struct s *) x = 0;  // auto 与 alignas 组合
```

>---
#### 3.2. constexpr 常量表达式

`constexpr` 声明常量表达式；类型不能是原子类型、VM 类型、`volatile` 或 `restrict` 限定。文件范围 `constexpr` 表达式默认具有内部链接。

```cpp
constexpr int tele = 10086;
constexpr int T = tele;
struct s { void *p; };
constexpr struct s A = { nullptr };
```

>---
#### 3.3. static 内部链接声明

`static` 声明内部链接，表示仅在当前翻译单元内可见，具有静态存储期。

```c
static int num;           // 文件范围内部链接，静态存储期
int foo(){
    static int local_num = num;     // 块范围，静态存储期
}
```

>---
#### 3.4. extern 外部链接声明

`extern` 声明外部链接或外部引用。

```c
#include "some.h"
extern void foo(void);   // extern from some.h
extern int i;     		 // 引用声明
...
int i = 10;      		 // 定义
```

>---
#### 3.5. register 寄存器存储声明

`register` 声明寄存器变量，仅在函数域。不支持此语法时忽略此语法。无法获取寄存器变量的地址。

```c
void Func(register int v){	     // 参数
    register int num = 1;        // 局部变量
}
```

>---
#### 3.6. thread_local 线程存储声明（可选）

`thread_local` 声明线程存储期变量，不能是具有自动存储期。线程对象在启动线程时开始初始化，每个线程拥有其唯一副本。

```cpp
void foo(){
    thread_local static counter;  // 局部声明不能是自动存储期
}
```

>---
#### 3.7. typedef 类型别名

`typedef` 声明类型别名。

```c
typedef void fv(int);     // 函数类型
typedef void (*pfv)(int); // 函数指针类型

void (*signal(int, void(*) (int)))(int);
// 相当于
fv* signal(int, fv*);     // use fv
pfv signal(int, pfv);     // use pfv

typedef struct{     
	int count;
	float cost;
} book;                   // 匿名结构别名
book mbook = {.count = 10,.cost = 10* 1.5f};

typedef char* const ConstString;	// 指向常量字符串的指针类型
ConstString str = "HelloWorld";
typedef const char* ConstpStr;		// 指向字符串的常量指针类型
```

> *typedef 声明 VLA 数组*


`typedef` 在快范围内声明可变修改（VM）类型，例如可变长度数组（VLA）。

```c
void F(int n){
    typedef int Array[n];	
    n += 1;
    Array a; 				// a 的长度是 +=1 前的 n
    int b[n]; 				// a 和 b 长度不同
}
```

>---
#### 3.8. const 常量限定

`const` 限定对象不可修改。指向非 `const` 指针能隐式转换成相同或兼容的 `const` 指针。可以使用强制转换进行逆向转换。

```c
const int ci;
const int carri[size];
void Func(char* const c);  // 等价于
void Func(char c[const]);
typedef const char *C_String;  // typedef 和 const

int* p = 0;
const int* cp = p;  // int 隐式转换到 const int
p = (int*)cp;       // const int 强制转换到 int
```

`const` 限定指针时：

```c
// * 在 const 后，限定值
int const *p_ci;        // 指向整型常量的指针
const int *p_ci;        // 指向整型常量的指针
// * 在 const 前，限定指针
int* const cp_i;        // 指向整型的常量指针
// const 双限定
const int* const cp_ci; // 指向整型常量的常量指针
```

没有从 `T**` 到 `const T**` 的转换，但可以从 `T**` 到 `T* const *`。

```c
char *p = 0;
const char **cpp = &p; 	// ERROR： char* 与 const char* 不是兼容类型
char * const *pcp = &p; // 添加限定符（ char * 到 char *const ）
```

>---
#### 3.9. volatile 易变限定

`volatile` 易变对象可能由外部程序合法修改，一般用于硬件地址以及在其他程序或同时运行的线程中共享数据。`volatile` 禁用编译器优化策略。

```c
volatile int vol;
void f(double x[volatile], const double y[volatile]);
void f(double * volatile x, const double * volatile y);
typedef volatile int v_int;  
int *volatile pV1;
volatile int *pV2;
```

任何通过非 `volatile` 方式对易变对象尝试读写都会导致未定义行为。

```c
volatile int n = 10010; // volatile 限定类型
int* p = (int*)&n;
int val = *p;       // 未定义行为
// ok
volatile int vp = &n;
*vp = 10086
```

`volatile` 限定结构或联合，成员也为易变限定。`volatile` 限定数组类型，仅元素成员为易变限定。支持 `const` 和 `volatile` 同时限定，表明该项不能被自身程序以合法方式修改，但可能被异步进程修改。
 
```c
volatile const int loc;
const volatile int * ploc;
```
> 

>---
#### 3.10. restrict 指针访问约束限定

`restrict` 用于限定指针，表明该指针是访问数据对象的唯一有效方式。若对 `restrict` 指针使用了别名，则结果是不确定的。

```c
void Func(int* restrict n);
void Func(int n[restrict]);
// 用于函数形参，限定仅能从 restrict 指针访问数据
void test(int* restrict first, int* restrict second, int* val)
{
    *first += *val;
    *second += *val;
}
// 将 union 成员标记为 restrict 告诉编译器在任何作用域中只有 z.x 或 z.y 可被访问
union z
{
    int* restrict x;
    double* restrict y;
};
// typedef 和 restrict
typedef void * Vptr;
typedef restrict Vptr Pointer;


```

文件范围 `restrict` 指针对访问动态分配的全局数组很有用。防止空访问文件范围 `restrict` 指针。

```c
/* 文件范围 */
float * restrict a, * restrict b;
float c[100];

int init(int n) {
   float * t = malloc(2*n*sizeof(float));
   a = t;      // a 引用前半
   b = t + n;  // b 引用后半
}
// 编译器可以从 restrict 限定符推断 a 、 b 和 c 都没有潜在的别名引用
// 如果使用 a，b，c 中的一个访问对象，并且该对象在程序中的任何未知被修改，则
// 永远不会使用另外两个中的任何一个来访问它。
```

`restrict` 指针之间赋值的规则不区分函数调用和等效的嵌套块。除了一个例外，只有在嵌套块中声明的受限指针之间的 “外部到内部” 赋值才定义了行为。

```c
{
    int * restrict p1;
    int * restrict q1;
    p1 = q1; // undefined behavior
    {
        int * restrict p2 = p1; // valid
        int * restrict q2 = q1; // valid
        p1 = q2; // undefined behavior
        p2 = q2; // undefined behavior
    }
}
```

#### 3.11. _Atomic 原子限定（可选）

`_Atomic` 限定原子类型，类型不能是数组、函数、其他原子类型或限定类型。它可以与 `const`、`volatile` 及 `restrict` 混合使用。

```c
_Atomic type identifier
_Atomic(type) identifier

_Atomic const int *ptr;          // ptr 是指向 _Atomic const int 的指针
const _Atomic(int) *ptr;  
typedef _Atomic int atomic_int;  // typedef 和 _Atomic
```

> 原子类型解释说明：

原子类型的对象是仅有的免除数据竞争的对象，即它们可以被两个线程共时修改，或先被一个修改再被另一个读取。

每个原子对象都拥有关联于其自身的修改顺序，即对该对象的完整修改顺序（若从某个线程的视角来看，对于某原子对象 M 的修改 A 发生先于同一原子对象 M 的修改 B，则在 M 的修改顺序中 A 的出现先于 B）。

不同线程可能会观测到不同原子对象有相异的修改顺序，对于所有原子运算，保证有四种连贯：
  - **写写连贯**：若原子对象 M 的修改操作 A 先发生于 M 的修改操作 B，则 M 的修改顺序中 A 出现早于 B。
  - **读读连贯**：若原子对象 M 的值计算 A 先发生于 M 的值计算 B ，且从 M 上的副作用 X 求得 A 值，则 B 所计算得的值要么是 X 所存储的值，要么是 M 上的副效应 Y 所存储的值，其中 Y 在 M 的修改顺序中出现后于 X。
  - **读写连贯**：若原子对象 M 的值计算 A 先发生于 M 上的操作 B ，则从 M 上的副效应 X 求得 A 值，这里 X 在 M 的修改顺序中出现先于 B 。
  - **写读连贯**：若在原子对象 M 上的副效应 X 先发生于 M 的值计算 B ，则求值 B 从 X，或从在 M 的修改顺序中出现后于 X 的副效应 Y 求得其值。

原子属性仅对左值表达式有意义。左值到右值转换（模仿从原子区域到 CPU 寄存器的内存读取）会把原子性及其他限定符剥去。

```c
#include <stdio.h>
#include <threads.h>
#include <stdatomic.h>

atomic_int acnt;
int cnt;

int f(void* thr_data)
{
    for(int n = 0; n < 1000; ++n) {
        ++cnt;
        ++acnt;
        // 对于此例，宽松内存顺序是足够的，例如
        // atomic_fetch_add_explicit(&acnt, 1, memory_order_relaxed);
    }
    return 0;
}

int main(void)
{
    thrd_t thr[10];
    for(int n = 0; n < 10; ++n)
        thrd_create(&thr[n], f, NULL);
    for(int n = 0; n < 10; ++n)
        thrd_join(thr[n], NULL);

    printf("The atomic counter is %u\n", acnt);
    printf("The non-atomic counter is %u\n", cnt);
}
/* 可能的输出
	The atomic counter is 10000
	The non-atomic counter is 8644
*/
```


>---
#### 3.12. 复杂声明解释

抽象声明符是指没有标识符的声明符，由一个或多个指针、数组或函数修饰符组成。

```c
int             // 整型
int *           // 指针
int *[3]        // 指向 int 的 3 个指针组成的数组
int (*)[5]      // 指向 5 个 int 类型数组的指针
int (*)[*]      // 指向未指定数目的 int 类型的可变长度数组的指针
int *()         // 一个不带参数的函数，返回一个指向 int 的指针
int (*)(void)   // 指向不带参数并返回 int 的函数的指针
int (*const []) (unsigned int, ...)  
// 指向函数的未指定数目的常量指针的数组，每个函数都有一个参数，其类型是 unsigned int 以及未指定数目的其他参数，并返回一个 int
```

复杂声明符是由多个数组、指针或函数修饰符限定的标识，可以将数组、指针和函数修饰符的各种组合应用于单个标识符。通常利用 `typedef` 来简化声明。在解释复杂声明时，方括号和圆括号（标识符右侧的修饰符）优先于星号（标识符左侧的修饰符）。方括号和圆括号具有相同的优先级并且都是从左到右关联。

解释复杂声明符的一般步骤：
1. 从标识符开始并直接查找方括号或圆括号（如果有）的右侧。
2. 解释这些方括号或圆括号，然后查找星号的左侧。
3. 如果在任何阶段遇到一个右圆括号，请返回并将规则 1 和 2 应用于圆括号内的所有内容。
4. 应用类型说明符。

```C
char *( *(*var)() )[10];
 ^   ^  ^ ^ ^   ^    ^
 7   6  4 2 1   3    5

/*
  1. 标识符 var 声明为
  2. 指向 (以下内容) 的指针
  3. 返回 (以下内容) 的函数
  4. 指向 (以下内容) 的指针
  5. 包含 10 个元素的数组，这些元素分别为 (以下内容)
  6. 指向 (以下内容) 的指针
  7. char

解释为: 标识符 var 声明为 (指向 (返回 (指向 (包含 10 个元素的数组，这些元素分别为 (指向 (char) 的指针) ) 的指针) 的函数) 的指针)
*/
```

> 复杂声明举例

```c
int *var[5];				// 声明为指向 int 的指针数组 
int (*var)[5];				// 声明为指向 int 数组的指针 
long *var(long, long);		// 声明为返回 long 指针的函数 
long (*var)(long, long);	// 声明为指向返回 long 的函数指针

struct both{	// 声明为指向返回结构 both 的函数的指针数组
    int a;
    char b;
} (*var[5])(struct both, struct both);
struct both *var[5](struct both, struct both);	// 非法：声明函数数组

// 声明为指向常量指针的指针的二维数组，这些常量指针指向返回 unsigned int* 的函数
unsigned int* (*const *name[5][10])(void);

// 声明为返回指向包含 3 个 double 数组指针的函数，其形参是指向包含 3 个 double 数组的指针
double (*var(double(*)[3]))[3];

union sign{     // 声明为指向指针的指针二维数组，这些指针指向具有两个成员的联合的指针
     int x;
     unsigned y;
} **var[5][5];
union sign *(*var[5])[5];   // 声明为一个五元素指针数组，数组元素指向联合的五元素指针数组
```

---
### 4. 表达式与操作符

> **运算符与优先级**

| **Category** | **Operator**                                                                                         |
| :----------- | :--------------------------------------------------------------------------------------------------- |
| 基本表达式   | `x[y]`,`x.y`,`x->y`,`f(x)`,`a[x]`                                                                    |
| 一元         | `+x`,`-x`,`!x`,`&x`,`*p`,`~x`,`sizeof`,`alignof`,`typeof`                                            |
| 递增递减     | `x++`,`x--`,`++x`,`--x`                                                                              |
| 强制转换     | `(type)value`                                                                                        |
| 乘法         | `x * y`,`x / y`,`x % y`                                                                              |          |
| 加法         | `x + y`,`x - y`                                                                                      |
| 移位         | `x << y`, `x >> y`                                                                                   |
| 关系         | `x > y`,`x >= y`,`x < y`,`x <= y`                                                                    |
| 相等         | `x == y`,`x != y`                                                                                    |
| 位运算       | `x &y `,`x ^ y`,`x \| y`                                                                             |          |
| 条件逻辑     | `x && y`, `x \|\| y`                                                                                 | 支持短路 |
| 三目运算     | `cond ? <true> expr1 : <false> expr2`                                                                |          |
| 赋值         | `x = y`,`x += y`,`x -= y`,`x *= y`,`x /= y`,`x %= y`,`x &= y`,`x ^= y`,`x \|= y`,`x <<= y`,`x >>= y` |          |
| 逗号运算     | `(expr1, expr2)` 返回 expr2                                                                          |

> *浮点数比较*

浮点数的存储存在精度误差的问题。一个浮点数与 0.0 比较不能简单的使用 `==`，可以依靠 `EPSILON`（较小的正数）。如果正数 `d` < `EPSILON`，那么 `d` 和 `1.0` 相加被认为仍等于 `1.0`。

```c
#include <math.h>
#include <float.h>
/* 浮点数 D 与 0 作比较 */
if(fabs(D - 0.0) < DBL_EPSILON)
	puts("D 与 0.0 相等");
```

>---
#### 4.1. sizeof

`sizeof` 存储类型或对象的字节大小，操作数不能是函数类型或不完整类型。`sizeof` 一般常量表达式，除非它们是 VLA。

```c
size_t szo = sizeof(Obj); // or `sizeof Obj`
size_t szt = sizeof(<Type>);

size_t szInt = sizeof(int);
size_t szNum = sizeof 10086;  // or sizeof(10086)

// VLA
void Foo(int len) {
	typedef int Arr[len];
	printf("%d\n", sizeof(Arr));
}
```

>---
####  4.2. typeof, typeof_unqual

```c
typeof ( expression | type )
typeof_unqual ( expression | type )
```

`typeof_unqual` 运算的结果是非原子非限定类型，`typeof` 运算符保留原类型的所有限定符。*typeof* 不应用于位域成员。

```c
const _Atomic int purr = 0;
const int meow = 1;
const char* const animals[] = {
	"aardvark",
	"bluejay",
	"catte",
};
typeof_unqual(meow) main (void) {    // int main
	typeof_unqual(purr) plain_purr;            // int plain_purr;
	typeof(_Atomic typeof(meow)) atomic_meow;  // const _Atomic int atomic_meow;
	typeof(animals) animals_array;             // const char* const animals_array[3]; 
	typeof_unqual(animals) animals2_array;     // const char* animals2_array[3];

	struct S1 { int a; };
	struct S2 { typeof(struct S1) s; };
	typeof(struct S2) s = { 10 };    // s 是 struct S2 { struct S1 { int a; }; };
    s.s.a++;
    printf("%d", s.s.a); // 11
};
```

> *获取函数的返回类型*

```c
#include <stdio.h>
#include <stdlib.h>

double (*Func(double (*DArr)[3]))[3] {   // 复杂声明
	double(*Arr)[3] = (double(*)[3])malloc(3 * sizeof(double *));
	for (size_t i = 0; i < 2; i++)
		for (size_t j = 0; j < 3; j++)
			Arr[i][j] = DArr[i][j] + 10.0;
	return Arr;
}

int main(void) {
	static double arr[2][3] = {1.0, 2.1, 3.2, 1.1, 2.2, 3.3};
	double(*DArr)[3] = arr;
	typeof(Func(NULL)) rt;	// 反射获取函数的返回类型

	rt = Func(DArr);
	printf("%p\n", rt);

	for (size_t i = 0; i < 2; i++)
		printf("%p %.2f\n", rt[i], rt[i][0]);
	return 0;
}
```

> 对于 `typeof` VLA，`sizeof` 在运行时计算

```c
#include <stddef.h>

size_t vla_size(int n)
{
    typedef char vla_type[n + 3];
    vla_type b = {}; 			// VLA
    return sizeof(typeof_unqual(b));  // 运行时计算 
}
int main()
{
    return (int)vla_size(10); // return 13
}
```

>---
####  4.3. alignas, alignof

完整对象类型具有 **对齐要求**。`alignas/_Alignas` 为对象类型请求更为严格的对齐，`alignof` 以字节返回完整对象类型的对齐要求。**基本对齐** 是小于等于 `alignof(max_align_t)` 的有效对齐，**扩展对齐** 是大于 `alignof(max_align_t)` 的对齐表示。

类型 `char`、`signed char` 和 `unsigned char` 具有最弱的对齐要求。以下类型的对齐要求应为基本对齐：
- 所有原子、限定或非限定的基本类型、枚举类型、指针类型；
- 其元素类型具有基本对齐要求的所有数组类型；
- 指定为完整对象类型的所有类型；
- 其包含元素具有基本对齐要求的类型，并且其元素均不具有指定非基本对齐方式的所有结构或联合类型。

```c
#include <stdalign.h>
alignas(TYPE_SIZE) <type> <identifier>;
size_t sz = alignof(type);
```

`alignas` 不在 `typedef`、位域、函数、函数参数、`register` 声明中使用。指定值为 0 或幂为 2（如 1、2、4、8、16 等）的有效对齐，零对齐规范没有任何作用。`alignas` 不小于目标类型基本对齐。

`struct` 和 `union` 对齐方式与其成员的最大对齐方式相等。当声明中出现多个对齐说明符时，有效对齐是最严格的指定对齐。

```c
int main()
{
    alignas(0) alignas(4) alignas(16) struct Sample s;
    return alignof(s);  // 16
}
```

>---
#### 4.4. 类型转换

类型转换包含隐式或强制转换（`(type)value`）。任何标量转换为 `bool` 时，数值零、空指针或 `nullptr` 结果为 `false`。

```c
int ic = 'A';     	        // implicit
float f = (float)3.1415L;   // explicit
```

涉及任何指针的转换应通过显式强制转换指定。没有函数指针和对象指针（含 `void *` ）间的转换。整数和指针之间可以互相转换。

```c
// 检验对象表示是转型的合法使用
    double d = 3.14;
    printf("The double %.2f(%a) is: ", d, d);
    for(size_t n = 0; n < sizeof d; ++n)
        printf("0x%02x ", ((unsigned char*)&d)[n]);
/* Output：
	The double 3.14(0x1.91eb851eb851fp+1) is: 0x1f 0x85 0xeb 0x51 0xb8 0x1e 0x09 0x40
*/
    struct S {int x;} s;
//  (struct S)s; 	// 错误；非标量类型，尽管转型到相同类型什么都不做
    (void)s; 		// 转换任何类型到 void 都合法
```

>---
#### 4.5. 按位运算符

按位运算符用于整数类型，包括 `char`。

```c
// 按位取反: 1->0, 0->1
	~(10010101) = 01101010
// 按位与:  1&1=1, 0&0=0, 1&0=0
	11010110 & 01101011 = 01000000
// 按位或:  1|1=1, 0|1=1, 0|0=0
	10101110 | 01001010 = 11101110
// 按位异或: 1^1=0，0^1=1 0^0=0
	10101101 ^ 01011101 = 11110000
```

> *掩码操作*

按位与运算符常用于掩码（mask）。所谓掩码指的是一些设置为开（1）或关（0）的位组合。

1. 假定符号常量 MASK 为 2（00000010）。
2. ```flags &= MASK```：表示将 flags 除 1 号位以外的所有位都设置为 0（无论 flags 的一号位是 0 或 1，其他位都会变成 0）。
3. 把掩码中的 0 看作不透明，1 看作透明，表达式 ```flags & MASK``` 相当于用掩码覆盖在 flags 的位组合上，只有 MASK 为 1 的位才可见。

```powershell
# flags &= MASK >>>>>>> 将非 1 位清 0
	MASK  >>>  00000010  >>>  ______1_
	按位与         &
	flags >>>  10010110  >>>  10010110
	             掩码
	flags >>>  ______1_  >>>  00000010
```

> *打开位 (设置位)*

有时，需要打开一个值中的特定位，同时保持其他位不变。

```powershell
# flags |= MASK >>>>>>> 将 1 位设置为 1
	MASK  >>>  00000010  >>>  ______1_
	按位或	       |
	flags >>>  10101001  >>>  10101001
	            打开位
	flags >>>  ______1_  >>>  10101011
```

> *关闭位 (清空位)*

```powershell
# flags &= ~MASK >>>>>>> 将 1 位关闭为 0
	MASK  >>>  10110110
	按位取反       ~
	MASK  >>>  01001001  >>>  _1__1__1
	按位与         &
	flags >>>  00001111  >>>  00001111
	            关闭位
	flags >>>  0_00_00_  >>>  00001001
```

> *切换位*

切换位指的是打开已关闭的位，或关闭已打开的位。可以使用按位异或运算符（^）切换位。

```powershell
# flags ^= MASK >>>>>>> 将指定的位取反，0➡1，1➡0
	MASK  >>>  00110010  >>>  __11__1_
	按位异或       ^
	flags >>>  10101001  >>>  10101001
	            切换位
	flags >>>  __01__1_  >>>  10011011
```

> *检查位的值*

有时，需要检查某位的值。例如，flags 中 1 号位是否被设置为 1？。检查指定位时需要将其他无关的位掩码（flags & MASK）。

```c
if((flags & MASK) == MASK)
// 10110101 & 10000000 ?= 10000000
// flags 指定位的值不会被修改，与 MASK 对比指定位是否相等，可以获取到当前位的值
// 相等表示校验位为 1，否则为 0
```

>---
#### 4.6. 泛型选择

泛型选择根据表达式的类型选择一个值，常用于 `#define` 宏定义的一部分。

```c
// 泛型表达式
_Generic(assign-expr, generic-assoc-list)
// Example cbrt
#define cbrt(X) _Generic((X), 			      \
					     long double: cbrtl,  \
						 default: cbrt,		  \
						 float: cbrtf		  \
						 )(X)
// Example MYTYPE
#define MYTYPE(X) _Generic((X),
		int: "int",
		float : "float",
		double: "double",
		default: "other"
		)
int main(void)
{
	int d = 5;
	printf("%s\n", MYTYPE(d));       // d 是 int 类型
	printf("%s\n", MYTYPE(2.0*d));   // 2.0 * d 是 double 类型
	printf("%s\n", MYTYPE(3L));		 // 3L 是 long 类型
	printf("%s\n", MYTYPE(&d));	     // &d 的类型是 int *
}
```

>---
#### 4.7. 静态断言

```c
static_assert (integer-constant-expression, string-literal);
static_assert (integer-constant-expression);
```

如果常量表达式的值不等于 0，则断言成功。

```c
static_assert(sizeof(int) == 4, "Expecting 32 bit integers");
```

---
### 5. 语句
#### 5.1. 空语句

执行空语句时不会发生任何事件。通常作为 `do`、`for`、`if` 和 `while` 等语句的不执行主体出现。

```c
while(cond)
	;
```

>---
#### 5.2. 迭代语句

> while

```c
while(expression)
    statements
```

> for

```c
for( init-expr? ; cond-expr? ; iter-expr?) 
    statements
```

> do-while

```c
do 
	statements 
while(expression);
```

>---
#### 5.3. 条件控制语句

> if-else

```c
if(cond) 
	statements
else if(cond)
	statements
else
	statements
```

> switch

```c
switch(integer-expr){
    case integer-constexpr: 
		statements 
		<break;>?    // 允许贯穿
    [case-clause]+
	...
    default: 
		statements	
		break;
}
```

>---
#### 5.4. 跳转语句

> goto 

`goto` 在块范围中跳转到目标标签。

```c
int main(void){
    int i,j;
    for (i = 0; i < 100; i++){
        for ( j = 0 ;j < 50 ;j++){
            // ...
            if (cond)
                goto out;
			// ...
		}
    }
out:
    // ...
}
```

> continue

`continue` 在循环体中跳转到循环体的末尾。

```c
while(cond) {
	/* ... */
	continue;  // 相当于 goto contin;
	/* ... */
contin:
}
```

> break

`break` 在 `switch` 或最内层迭代语句中中断语句块执行。

```c
while(cond) {
	/* ... */
	break;  // 相当于 goto end;
	/* ... */
}
end:
```

> return

`return` 终止函数执行并将控制返回给其调用方。

```c
#define SUCCESS 0
int main(void){
	printf("Hello, World");
	return SUCCESS;
}
```

---
### 6. 函数

函数必须具有定义，应具有函数声明充当函数原型；包含函数声明时，必须在函数调用。函数的返回类型应为 `void` 或除数组、函数类型之外的完整对象类型。函数声明可以是 `extern` 外部引用和 `static` 内部链接。

```c
// 函数原型
extern double maximum(int, int, double[*][*]);    // 省略标识符
static double maximum(int n, int m, double a[n][m]);
double maximum(int n, int m, double a[*][*]);
double maximum(int n, int m, double a[][*]);
double maximum(int n, int m, double a[][m]);
double maximum(int n, int m, double (*a)[*]);
```

> **限定数组形参**

```c
/* 传入的数组要求至少拥有 10 个元素 */
void Function(double [static 10], const double [static 10]);
/* a 拥有类型 const int* （指向 const int 的指针） */
int f(const int a[20]);
/* a 拥有类型 const int* const （指向 const int 的 const 指针） */
int f(const int a[const 20]);
/* restrict 别名限定 */
void f(double a[static restrict 10], const double b[static restrict 10]);
```

>---
#### 6.1. 可变参数

`stdarg.h` 提供了宏方法用于访问可变参数列表和清理工作。`va_start` 初始化 `ap`。`va_end(ap)` 后 `ap` 不可用。`va_copy(ap2, ap1)` 复制 `ap1` 的状态给 `ap2`。

```c
// 有效声明
void foo(...);  // C23 起
void foo(int n, ...);
void foo(const char * s, int k, ...);

// 访问可变参数列表
double sum(int lim, ...) /* 设 lim 表明变参列表中参数的数量 */
{
	// a. 声明一个储存参数的对象
	va_list ap;
	// b. 把 ap 初始化为参数列表, lim 为参数数目
	va_start(ap, lim);
	// c. 访问参数列表的内容 va_arg(ap, 类型名)
	//---- 检索第 1 个参数
	double tic = va_arg(ap, double);
	//---- 检索第 2 个参数
	int toc = va_arg(ap, int);
	/* PS: 传入的参数类型必须与宏参数的类型相匹配 */
	// d. 宏完成清理工作
	va_end(ap); 	// 清理工作
	/* PS: 释放动态分配用于储存参数的内存 */
}
```

>---
#### 6.2. 内联函数

`inline` 声明内联函数。内联告知编译器对该函数的调用应尽可能快。函数调用都有一定的开销, 例如建立调用、传递参数、跳转到函数代码并返回等。编译器将内联函数的调用点替换为对函数体的执行，这可能会生成更大的可执行文件。

```c
inline static void _inline(){
	while(getchar() != '\n')
		continue;
}

void Fun(void){
	_inline();
}
// 类似于
void FunInline(void){
	while(getchar() != '\n')
		continue;
}
```

一般无法获取内联函数的地址。C 允许混合使用内部函数定义和外部函数定义（具有外部链接）。具有外部链接的内联函数可以产生外部定义。

```c
// 静态内联函数定义，内部链接
inline static void fun();
// 外部链接函数定义
void fun();
// 既充当内部内联函数, 又具有外部链接
[extern]? inline void fun();
```

>---
#### 6.3. 变长数组参数

VLA 可作为函数的参数。变长数组名实际上是一个指针。带变长数组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。

```c
void Func1(int size, int Arr[size]);
void Func2(int row, int col, int Arr[row][col]);
void Func3(int size, int(*pr)[size]);
void Func4(int, int, int Arr[*][*]);  // 省略模式

void Func5(int Arr[size], int size);  // 无效的顺序
```

>---
#### 6.4. 函数与指针

函数指针常用作函数参数。

```c
void ToUpper(char *);
void ToLower(char *);
int round(double);

void (*pFun)(char *);
pFun = ToUpper;
pFun = ToLower;
// pFun = round;    // ERR, 类型不一致
pFun("UPPER");      // 相当于 ToLower("UPPER");
```

函数指针作为参数

```c
void show(void (* fp)(char *), char * str);
```

---
### 7. 属性说明符

属性为各种源构造（如类型、对象、标识符或块）指定其他信息。对标准属性的支持由实现定义且可选，任何不支持的属性标记都将被忽略。

```c
[[attr]]
[[attr1, attr2, attr3(args)]]
[[属性前缀::attr(arg)]]
[[属性前缀::attr]]
/*
标准属性			例如 [[fallthrough]]
属性前缀::标识符	有命名空间的属性，例如 [[gnu::unused]]，C++
标准属性(实参列表)	有实参的标准属性
属性前缀::标识符(实参列表)
*/
```

>---
#### 7.1. 标准属性

标准属性中的标识符应为以下项之一：

```c
[[deprecated]]				
[[maybe_unused]]			
[[noreturn]]				
[[unsequenced]]
[[fallthrough]]
[[nodiscard]]
[[noreturn]]
[[reproducible]]            
```

属性令牌在属性列表中的显示顺序不重要，每个实现都应为属性前缀令牌中的属性前缀选择一个独特的名称。实现不应定义没有属性前缀的属性，除非它是 C 标准中指定的标准属性。

```c
// 假设实现选择属性前缀 hal 并提供名为 daisy 和 rosie 的特定属性。
[[deprecated, hal::daisy]] double nine1000(double);
[[deprecated]] [[hal::daisy]] double nine1000(double);
[[deprecated]] double nine1000 [[hal::daisy]] (double);
```

在语言的所有方面，指定为标识符 `attr` 的标准属性和形式为 `__attr__` 行为应相同。属性 `[[nodiscard]]` 和 `[[__nodiscard__]]` 等价。

```c
[[__deprecated__, __hal__::__daisy__]] double nine1000(double);
[[__deprecated__]] [[__hal__::__daisy__]] double nine1000(double);
[[__deprecated__]] double nine1000 [[__hal__::__daisy__]] (double);
```

以下两个声明是等效的，在同一属性列表中的排序并不重要。

```c
[[hal::daisy, hal::rosie]] double nine999(double);
[[hal::rosie, hal::daisy]] double nine999(double);
```

以下两个声明并不等价，因为不同属性列表的顺序可能会影响语义。

```c
[[hal::daisy]] [[hal::rosie]] double nine999(double);
[[hal::rosie]] [[hal::daisy]] double nine999(double);
```

>---
#### 7.2. nodiscard 弃值表达式警告

```c
[[nodiscard]]
[[__nodiscard__]]	(1)
[[nodiscard (字符串字面量)]]
[[__nodiscard__ (字符串字面量)]]
```

`nodiscard` 属性应用于函数、枚举、结构或联合类型的定义。
- 若从转型到 `void` 以外的弃值表达式（调用声明为 `nodiscard` 的函数，或调用返回声明 `nodiscard` 的结构体 / 联合体 / 枚举的函数）则鼓励编译器发出警告。
- 弃值表达式，返回值放弃接收。

```c
struct [[nodiscard]] S { int status; };
struct S returnStruct(){
	return (struct S){0};
}

[[nodiscard("No Discard")]] int Mrix(int a, int b){
	return a ^ b;
}

int main(void){
	returnStruct();   /* warning */
	int rt = Mrix(1,2);	/* legal */
}
```

>---

#### 7.3. deprecated 弃用

```c
[[deprecated]]
[[__deprecated__]]
[[deprecated (字符串字面值)]]
[[__deprecated__ (字符串字面值)]]
```

`deprecated` 属性可用于标记仍允许使用但出于某种原因不建议使用的名称和实体。

```c
struct [[deprecated]] S;              // 结构/联合
[[deprecated]] typedef S* PS;         // typedef 名称
[[deprecated]] int x;                 // 对象
union U { [[deprecated]] int n; };    // 结构/联合成员
[[deprecated]] void f(void);          // 函数
enum [[deprecated]] E {};             // 枚举
enum { A [[deprecated]], B [[deprecated]] = 42 };   // 枚举项
```

声明时未弃用的名称可被重声明为 `deprecated`。声明为 `deprecated` 的名称不能通过不带此属性地重声明而变为未弃用。“已弃用” 适用于过时、不安全、不安全或不适合用途的名称和实体。

```c
[[deprecated]]
void TriassicPeriod(void)
{
    puts("Triassic Period: [251.9 - 208.5] million years ago.");
}
[[deprecated("Use NeogenePeriod() instead.")]]
void JurassicPeriod(void)
{
    puts("Jurassic Period: [201.3 - 152.1] million years ago.");
}
 
int main(void)
{
    TriassicPeriod();
    JurassicPeriod();
}
/* 可能的输出
test.c: In function 'main':
test.c:16:5: warning: 'TriassicPeriod' is deprecated [-Wdeprecated-declarations]
   16 |     TriassicPeriod();
      |     ^~~~~~~~~~~~~~
test.c:4:6: note: declared here
    4 | void TriassicPeriod(void)
      |      ^~~~~~~~~~~~~~
test.c:17:5: warning: 'JurassicPeriod' is deprecated: Use NeogenePeriod() instead. [-Wdeprecated-declarations]
   17 |     JurassicPeriod();
      |     ^~~~~~~~~~~~~~
test.c:9:6: note: declared here
    9 | void JurassicPeriod(void)
      |      ^~~~~~~~~~~~~~
Triassic Period: [251.9 - 208.5] million years ago.
Jurassic Period: [201.3 - 152.1] million years ago.
*/
```

>---

#### 7.4. fallthrough 贯穿抑制警告

```c
[[fallthrough]]
[[__fallthrough__]]
```

仅可用于属性声明以创建直落声明（`[[fallthrough]];`）。直落声明仅可用于 `switch` 语句中，其中要遇到的下个块项（语句、声明或标号）是该 `switch` 语句的带 `case` 或 `default` 标号的语句。指示从前一标号直落是有意的，而在发生直落时给出警告的编译器不应诊断它。

```c
switch (n) {
    case 1:
    case 2:
        g();
        [[fallthrough]];
    case 3: 	// 贯穿时不警告
        h();
    case 4: 	// 编译器可在发生贯穿时警告
	    if(n < 3) {
            i();
            [[fallthrough]]; 	// OK
        }
        else {
            return;
        }
    case 5:
        while (false) {
            [[fallthrough]]; 	// 谬构：下一语句不是同一迭代的一部分
        }
    case 6:
        [[fallthrough]]; 		// 谬构：下一语句不是同一迭代的一部分
}
```

>---

#### 7.5. maybe_unused 抑制对未使用实体的警告

```c
[[maybe_unused]]
[[__maybe_unused__]]
```

`maybe_unused` 属性应应用于结构、联合、`typedef` 名称、对象、结构或联合成员、函数、枚举、枚举器或标签的声明。若编译器可以对未使用的实体发出警告，则对任何声明为 `maybe_unused` 的实体抑制该警告。

```c
struct [[maybe_unused]] S;              // 结构/联合
[[maybe_unused]] typedef S* PS;         // typedef 名称
[[maybe_unused]] int x;                 // 对象
union U { [[maybe_unused]] int n; };    // 结构/联合成员
[[maybe_unused]] void f(void);          // 函数
enum [[maybe_unused]] E {};             // 枚举
enum { A [[maybe_unused]], B [[maybe_unused]] = 42 };   // 枚举项
```

>---

#### 7.6. noreturn 函数不会返回

```c
[[noreturn]]
[[__noreturn__]]
```

指示函数不会返回。这个属性适用于函数名，指示函数不会由于执行返回语句或由于抵达函数体结尾而返回（它可以通过执行 `longjmp` 返回）。如果有此属性的函数实际返回，则其行为未定义。如果可以检测这种情况，建议编译器予以诊断。

实现应为使用 `noreturn` 属性声明的函数生成诊断消息，该函数似乎能够返回给其调用方。

```c
[[noreturn]] void f(void) {
    abort(); // ok
}
[[noreturn]] void g(int i) { 
    // causes undefined behavior if i <= 0
    if (i > 0) abort();
}
[[noreturn]] int h(void);
```

以下标准库函数均被声明带有 `noreturn` 属性：

```c
abort()
exit()
_Exit()
quick_exit()
thrd_exit()
longjmp()
```

>---

#### 7.7. unsequenced 和 reproducible 函数类型标准属性

函数类型的属性应应用于具有函数类型的类型说明符的函数声明符。相应的属性是函数类型的属性。这些属性适用于函数声明符或者具有函数类型的类型说明符。相应属性是函数类型的性质。这些属性区分读取操作（无状态和无关联）和写入操作（无效果、幂等和可重现）或两者的组合（未排序）

尽管在语义上附加到函数类型，但所描述的属性不是此类函数原型的一部分，并且删除此类属性的重新声明和转换是有效的，并构成兼容类型。相反，如果函数声明或具有该属性的类型的函数指针访问不具有断言属性的定义，则该行为是未定义的。

```c
[[ unsequenced ]]
[[ __unsequenced__ ]]

[[ reproducible ]]
[[ __reproducible__ ]]
```

`unsequenced` 指示函数无效果、幂等、无状态且无关联，即它是无序的。
`reproducible` 指示函数无效果且幂等，即它是可重现的。

这些属性为编译器优化的目的而存在：
- 如果函数 `reproducible` 可重现，则可将先后多次调用当做一次调用。
- 如果函数 `unsequenced` 无序，则可将先后多次调用当做一次调用，且这些调用可以并行化并任意重排。

```c
size_t hash(char const[static 32]) [[reproducible]];
bool tendency(signed char) [[unsequenced]];
```

> 无作用

如果函数调用过程中编入序列的任何存储操作，都是对某对象的同步于此次调用的修改，则该调用的执行是无作用的；如果这种存储操作还是可观察的，则对该对象的所有访问必须都基于函数的一个唯一指针形参进行。

> 幂等

对于某个求值 `E`，若 `E` 的第二次求值可以紧跟第一次求值编入序列而不改变结果值（如果有）或执行的可观察状态，则它是幂等的。

> 无状态

如果函数 `F` 或其所调用的任何函数中，具有静态或线程存储期的任意对象的定义均为 `const` 但无 `volatile` 限定，则 `F` 是无状态的。

> 无关联

对于函数 `F`，如果 `F` 的调用中可以通过并非该调用的形参的左值而观察到任何对象 `X`，而在同一次程序执行中所有对 `F` 的调用中，对 `X` 的所有访问都观察到相同的值，则 `F` 无关联；或者如果访问是通过某个指针形参进行，则应当有一个唯一的这种指针形参 `P`，使得对 `X` 的任何访问都应当是基于 `P` 的左值访问。

对象 `X` 由函数调用所观察的条件是：二者均同步，`X` 并非局部与此次调用，`X` 的生存期开始于函数调用之前，且此次调用中有对 `X` 的访问被排入序列；此次调用前所存储的 `X` 的最新值（如果有），被称为此次调用所观察到的 `X` 的值。

---
### 8. 预处理器与预处理指令

预处理器是将源文件的文本作为翻译的第一阶段操作的文本处理器。

```c
#define		#endif		#ifdef		#line
#elif		#error		#ifndef		#pragma
#else		#if			#include	#undef
```

C 和 C++ 程序包含一个或多个源文件。**翻译单元** 包含 `#include` 指定的头文件或其它源文件，但不包括由条件编译指令（如 ```#if``` ）删除的代码部分。编译后的翻译单元可作为单独的对象文件或对象代码库处理。然后，将这些单独的已翻译的翻译单元链接起来以构成可执行程序或动态链接库 DLL。

>---
#### 8.1. 空预处理指令

```c
//...
#     // 无作用
//...
```

>---
#### 8.2. 条件编译

预处理器支持有条件编译源文件的某些部分，由 `#if`、`#else`、`#elif`、`#ifdef`、`#ifndef`、`#elifdef`、`#elifndef` 与 `#endif` 指令支持。表达式可以含有形式 `defined` 的一元运算符：

```c
#if defined MACRO
#if !defined( MACRO )

#ifdef MACRO   	 相当于 #if defined MACRO
#ifndef MACRO    相当于 #if !defined MACRO
#elifdef MACRO   相当于 #elif defined MACRO
#elifndef MACRO  相当于 #elif !defined MACRO
```

在条件编译指令中，可以检查 `__has_include`、`__has_embed` 和 `__has_c_attribute` 特性。

```c
__has_include ( header-name ) 
__has_include ( header-name-tokens )

__has_embed ( header-name embed-parameter-sequence? ) 
__has_embed ( header-name-tokens pp-balanced-token-sequence? )

__has_c_attribute ( pp-tokens )
```

>---
#### 8.3. 源文件包含

```c
#include < h-char-sequence >		
#include " q-char-sequence "		
#include pp-tokens					

#include <stdio.h>
#include "some.h"
```

为了避免重复包含相同头文件或发生无限递归时，通常会使用头文件防护：

```c
#ifndef FOO_H_INCLUDED /* 唯一映射到此文件名的任何名字 */
#define FOO_H_INCLUDED
// 此文件的内容在此
#endif
// or
#pragma once
// 此文件的内容在此
```

> __has_include

```c
__has_include ( " q-char-sequence " )
__has_include ( < h-char-sequence > )

__has_include ( string-literal )
__has_include ( < h-pp-tokens > )	
```

搜索由每个包含 `__has_include` 表达式中的标识的头文件或源文件，如果搜索源文件成功，`__has_include` 表达式的计算结果为 1，如果搜索失败则为 0。`__has_include` 结果为 1 仅表示存在具有指定名字的头文件或源文件。它并不意味着当包含该头文件或源文件时，不会导致错误或能够包含任何有用之物。

```c
#if __has_include(<optional.h>)
	#include <optional.h>
	#define have_optional 1
#elif __has_include(<experimental/optional.h>)
	#include <experimental/optional.h>
	#define have_optional 1
	#define have_experimental_optional 1
#endif
#ifndef have_optional
	#define have_optional 0
#endif
```

>---

#### 8.4. 二进制资源包含

`#embed` 是用于在构建中包含（二进制）资源的预处理器指令，该资源可以作为一个给定的嵌入参数的二进制数据序列来处理。资源具有实现的资源宽度，除非由嵌入参数 `limit` 所修改。嵌入元素宽度等于 `CHAR_BIT`，或由某个由实现定义的参数所修改。资源宽度必须可被嵌入元素宽度整除，即 *资源宽度* % *嵌入元素宽度* = 0。

```c
#embed < h-char-sequence > embed-parameter-sequence?		
#embed " q-char-sequence " embed-parameter-sequence?		
#embed pp-tokens	

embed-parameter-sequence:
	limit, prefix, suffix, if_empty
```

`#embed` 指令旨在将资源中的二进制数据转换为一系列整数常量表达式，以尽可能保留资源位流的值。

```c
#include <stddef.h>
void have_you_any_wool(const unsigned char*, size_t);

int main (int, char*[]) {
	static const unsigned char baa_baa[] = {
		#embed "black_sheep.ico"
	};
	have_you_any_wool(baa_baa, sizeof(baa_baa));
	return 0;
}
```

> *limit*

嵌入参数 `limit` 在嵌入参数序列中最多可出现一次。`limit` 参数必须为非负数整数常量表达式 *E*。

```c
limit ( 常量表达式 )
__limit__ ( 常量表达式 )	
```

*资源宽度* 为：
- 如果 *E* = 0，则为 0；或
- max { *实现定义资源宽度*, *嵌入元素宽度* x *E* }。


```c
// 检查声音资源的前 4 个元素
#include <assert.h>

int main(int, char *[])
{
	static const char sound_signature[] = {
#embed <sdk/jump.wav> limit(2+2)  
	};
	static_assert((sizeof(sound_signature) / sizeof(*sound_signature)) == 4,
	"There should only be 4 elements in this array.");
	
	// verify PCM WAV resource
	assert(sound_signature[0] == ’R’);
	assert(sound_signature[1] == ’I’);
	assert(sound_signature[2] == ’F’);
	assert(sound_signature[3] == ’F’);
	assert(sizeof(sound_signature) == 4);
	return 0;
}
```

在 `CHAR_BIT` 大于 24 的环境中，资源可能没有足够的信息，这可能违反约束：

```c
int main (int, char*[]) {
	const unsigned char arr[] = {
#embed "24_bits.bin" limit(1) // may be a constraint violation, 资源宽度 = 1 x 24?
	};
	return 0;
}
```

某些实现接口的资源可能具有无限的数据流：

```c
int main (int, char*[]) {
	const unsigned char arr[] = {
embed </owo/uwurandom> limit(513)
	};
	return 0;
}
```

`limit` 参数可以帮助只处理该信息的一部分，并防止在处理此类数据时耗尽实现的内部资源。


> *suffix*

```c
suffix ( 预处理平衡记号序列? )
__suffix__ ( 预处理平衡记号序列? )
```

嵌入参数 `suffix` 在嵌入参数序列中最多可出现一次。它必须带有（可能为空的）实参子句。如果资源非空，则该参数子句的内容被置于紧跟该指令的展开之后。否则，它没有效果。


```c
// 添加到数组初始值设定项的额外元素
#include <string.h>
#ifndef SHADER_TARGET
	#define SHADER_TARGET "edith-impl.glsl"
#endif

extern char* null_term_shader_data;
void fill_in_data () {
	const char internal_data[] = {
#embed SHADER_TARGET \ 
	suffix(,)
	0 // 源序列后补一个 0 元素
	};
	strcpy(null_term_shader_data, internal_data);
}
```

> *prefix*

```c
prefix ( 预处理平衡记号序列? )
__prefix__ ( 预处理平衡记号序列? )
```

嵌入参数 `prefix` 在嵌入参数序列中最多可出现一次。它必须带有（可能为空的）实参子句。如果资源非空，则该参数子句的内容被置于紧接该指令的展开之前。否则，它没有效果。

```c
// 当资源不为空时，为其嵌入一个前缀和后缀的附加标记
#include <assert.h>
#include <string.h>

#ifndef SHADER_TARGET
	#define SHADER_TARGET "ches.glsl"
#endif

extern char* merp;
void init_data () {
	const char whl[] = {
#embed SHADER_TARGET \
	prefix(0xEF, 0xBB, 0xBF, ) /* UTF-8 BOM */ \
	suffix(,)
	0
	};
// always null terminated,
// contains BOM if not-empty
	int is_good = (sizeof(whl) == 1 && whl[0] == ’\0’)
		|| (whl[0] == ’\xEF’ && whl[1] == ’\xBB’
		&& whl[2] == ’\xBF’ && whl[sizeof(whl) - 1] == ’\0’);
	assert(is_good);
	strcpy(merp, whl);
}
```

> *if_empty*

```c
if_empty ( 预处理平衡记号序列? )	
__if_empty__( 预处理平衡记号序列? )	
```

嵌入参数 `if_empty` 在嵌入参数序列中最多可出现一次。它必须带有（可能为空的）实参子句。如果资源为空，则以该参数子句的内容替换该指令。否则，它没有效果。

```c
// 如果资源搜索成功，由于 limit(0) 这个资源总被视为空。这个程序总是返回 0
int main(){
	return 
#embed <some_resource> \
	limit(0) \			// 资源宽度计算为 0
	prefix(1) \			// 资源被视为空，前缀无效
	if_empty(0)			// 资源为空，使用序列 0 替代
	;
	// become: return 0;
}
```

> __has_embed

```c
__has_embed ( " q-char-sequence " embed-parameter-sequence? )
__has_embed ( < h-char-sequence > embed-parameter-sequence? )

__has_embed ( string-literal pp-balanced-token-sequence? )
__has_embed ( < h-pp-tokens > pp-balanced-token-sequence? )	
```

搜索由每个包含 `__has_embed` 表达式中的标识的资源，`__has_embed` 表达式的计算结果和以下预定义的宏相同：
- `__STDC_EMBED_NOT_FOUND__  0`：如果搜索资源失败，或者如果指定的嵌入参数序列中的任何嵌入参数不受 `#embed` 指令的实现支持；
- `__STDC_EMBED_FOUND__  1`：如果搜索资源成功，并且 `#embed` 指令的实现支持指定的嵌入参数序列中的所有嵌入参数，并且资源不为空；
- `__STDC_EMBED_EMPTY__  2`：如果搜索资源成功，并且 `#embed` 指令的实现支持指定的嵌入参数序列中的所有嵌入参数，并且资源为空。

`__has_embed` 可在 `#if` 和 `#elif` 的表达式中展开。它被 `#ifdef`、`#ifndef`、`#elifdef`、`#elifndef` 和 `defined` 当做已定义宏，但不能用在别处。

```c
int main () {
#if __has_embed ("bits.bin" clang::element_type(short))
	// load "short" values directly from memory
	short meow[] = {
#embed "bits.bin" clang::element_type(short)
	};
#else
	// no support for implementation-specifid
	// clang::element_type parameter
	unsigned char meow_bytes[] = {
#embed "bits.bin"
	};
	unsigned short meow[] = {
		/* parse meow_bytes into short values
		   by-hand! */
	};
#endif
	return 0;
}
```

可以使用 `__FILE__` 和 `__has_embed` 组合来检查是否支持由 `$embed` 指令嵌入参数的特定实现扩展。

```c
#if __has_embed(__FILE__ ext::token(0xB055))
	#define DESCRIPTION "Supports extended token embed parameter"
#else
	#define DESCRIPTION "Does not support extended token embed parameter"
#endif
```

以下用于检查特定实现定义的嵌入参数的支持，否则使用标准行为来产生相同的效果。

```c
void parse_into_s(short *ptr, unsigned char *ptr_bytes, unsigned long long size);
int main()
{
#if __has_embed("test.bin" ds9000::element_type(short))
    /* Implementation extension: create short integers from the */
    /* translation environment resource into */
    /* a sequence of integer constants */
    short meow[] = {
#embed "bits.bin" ds9000::element_type(short)
    };
#elif __has_embed("test.bin")
    /* no support for implementation-specific */
    /* ds9000::element_type(short) parameter */
    const unsigned char meow_bytes[] = {
#embed "bits.bin"
    };
    short meow[sizeof(meow_bytes) / sizeof(short)] = {};
    /* parse meow_bytes into short values by-hand! */
    parse_into_s(meow, meow_bytes, sizeof(meow_bytes));
#else
#error "cannot find test.bin resource"
#endif
    return (int)(meow[0] + meow[(sizeof(meow) / sizeof(*meow)) - 1]);
}
```

>---

#### 8.5. 宏

预处理器支持文本宏替换及类函数文本宏替换。

```c
// 仿对象宏
#define identifier replacement-list?
// 仿函数宏
#define identifier ( param-list ) replacement-list
#define identifier ( param-list, ... ) replacement-list
#define identifier ( ... ) replacement-list
// 取消宏定义
#undef identifier
```

`#define` 指令定义 *identifier* 为宏，预处理阶段每个宏定义均替换为 *replacement-list* 替换列表。`#undef` 取消宏定义 *identifier*。

```c
#define Some_Macro

#ifdef Same_Macro
	#undef Same_Macro
#endif
```

仿对象宏将所定义的标识符的每次出现替换为替换列表。

```c
#define MINSIZE 512
int * CreateArray(int [static MINSIZE]);
// 翻译阶段替换为
int * CreateArray(int [static 512]);
```

仿函数宏将所定义的 *标识符* 的每次出现替换为 *替换列表*，其额外接受一定数量的参数。定义有可变参数的仿函数宏，能用 `__VA_ARGS__` 访问可变参数。*替换列表* 可包含标记序列 `__VA_OPT__( content )`，标记序列在 `__VA_ARGS__` 非空时，将替换为 *content*，否则将展开为空。。

```c
#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)
F(a, b, c) // 替换为 f(0, a, b, c)
F()        // 替换为 f(0)

#define G(X, ...) f(0, X __VA_OPT__(,) __VA_ARGS__)
G(a, b, c) // 替换为 f(0, a, b, c)
G(a, )     // 替换为 f(0, a)
G(a)       // 替换为 f(0, a)

#define SDEF(sname, ...) S sname __VA_OPT__(= { __VA_ARGS__ })
SDEF(foo);       // 替换为 S foo;
SDEF(bar, 1, 2); // 替换为 S bar = { 1, 2 };
```

> *字符串化运算符 `#`*

在仿函数宏中，`#` 对 *替换列表* 字符串化并做形参替换，例如对于替换列表 `X`，`#X` 替换为 `"X"`。

```c
#define PSQR(x) printf("The square of " #x " is %d.\n",((x)*(x)))

int main(void){
	int y = 5;
	PSQR(y);
	PSQR(2 + 4);
}
// The square of y is 25.
// The square of 2 + 4 is 36.

#define Show(x) puts(#x);
Show("\123");   // 展开为 puts("\"\\123\"");
```

`#` 出现在 `__VA_ARGS__` 之前时，将整个展开后的 `__VA_ARGS__` 放入引号：

```c
#define Showlist(...) puts(#__VA_ARGS__)
Showlist();            // 展开成 puts("")
Showlist(1, "x", int); // 展开成 puts("1, \"x\", int")
```

> *连接运算符 `##`*

`##` 运算符把两个记号组合成一个记号。

```c
#include <stdio.h>
#define XNAME(n) x ## n   // 表示将 x 与 n 组合成一个记号
#define PRINT_XN(n) printf("x" #n " = %d\n", x ## n);

int main(void)
{
	int XNAME(1) = 14; 	// 变成 int x1 = 14;
	int XNAME(2) = 20; 	// 变成 int x2 = 20;
	int x3 = 30;

	PRINT_XN(1); // 变成 printf("x1 = %d\n", x1);
	PRINT_XN(2); // 变成 printf("x2 = %d\n", x2);
	PRINT_XN(3); // 变成 printf("x3 = %d\n", x3);
	return 0;
}
/*
	PRINT_XN() 宏用 # 运算符组合字符串
	## 运算符把记号组合为一个新的标识符。
*/
```

>---
#### 8.6. 文件名与行信息

```c
#line digit-sequence		
#line digit-sequence " s-char-sequence "
#line pp-tokens
```

`#line digit-sequence` 将当前行更改为 *digit-sequence* 行号。`#line digit-sequence " s-char-sequence "` 将当前预处理器文件名更改为 *s-char-sequence* 文件名。

```c
#include <assert.h>
#define FNAME "test.c"
int main(void)
{
#line 777 FNAME
        assert(2+2 == 5);
}
// test: test.c:777: int main(): Assertion `2+2 == 5' failed.
```

编译器常使用行号和可选文件名来引用它在编译过程中发现的错误。

```c
// line_directive.c
#include <stdio.h>

int main()
{
    printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
#line 10
    printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
#line 20 "hello.c"
    printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
    printf( "This code is on line %d, in file %s\n", __LINE__, __FILE__ );
}
/* Output
	This code is on line 6, in file line_directive.c
	This code is on line 10, in file line_directive.c
	This code is on line 20, in file hello.c
	This code is on line 21, in file hello.c
*/
```

> *`#line` 和 `__LINE__` 与 `__FILE__`*

当给定的断言失败，断言将使用预定义宏 `__LINE__` ，并 `__FILE__` 打印有关源文件的错误消息。

```c
#include <assert.h>
#line 10086 "test.c"
	assert(1 > 2);
// Assertion failed: 1 > 2, file test.c, line 10086
```

>---

#### 8.7. 诊断

```c
#error " s-char-sequence "
#error pp-tokens

#warning " s-char-sequence "
#warning pp-tokens
```

`#error` 和 `#warning` 指令使实现产生一个诊断消息。`#error` 会终止编译，但 `#warning` 不影响程序的合法性并编译继续。

```c
#if __STDC__ != 1
#error "Not a standard compliant compiler"
#endif
 
#if __STDC_VERSION__ >= 202311L
#warning "Using #warning as a standard feature"
#endif
 
#include <stdio.h>
int main (void){
    printf("The compiler used conforms to the ISO C Standard !!");
}
```

>---

#### 8.8. 实现定义行为控制

```c
#pragma pp-tokens
_Pragma ( "s-char-sequence" )
```

`#pragma` 指令控制编译器的实现指定行为，如禁用编译器警告或更改对齐要求等。忽略任何不被识别的语用。Pragma 指令指定特定于计算机或特定于操作系统的编译器功能。

```c
_Pragma("nonstandardtreatmenttypeB on");
// 等价于
#pragma nonstandardtreatmenttypeB on
```

如果预处理标记 `STDC` 紧跟在指令中的 `pragma` 之后（在任何宏替换之前），则不会对指令执行宏替换，并且指令应具有以下形式之一

```c
#pragma STDC FP_CONTRACT on-off-switch        
#pragma STDC FENV_ACCESS on-off-switch
#pragma STDC CX_LIMITED_RANGE on-off-switch

// on-off-switch: one of
	ON
	OFF
	DEFAULT

#pragma STDC FENV_ROUND direction

// direction: one of
	FE_DOWNWARD
	FE_TONEAREST
	FE_TONEARESTFROMZERO
	FE_TOWARDZERO
	FE_UPWARD
	FE_DYNAMIC

#pragma STDC FENV_DEC_ROUND dec-direction

// dec-direction: one of
	FE_DEC_DOWNWARD
	FE_DEC_TONEAREST
	FE_DEC_TONEARESTFROMZERO
	FE_DEC_TOWARDZERO
	FE_DEC_UPWARD
	FE_DEC_DYNAMIC
```

- `FENV_ACCESS OFF` 默认是关闭，表示编译器程序将访问或修改浮点环境这意味着禁用可能推翻标志测试和模式更改（例如，全局共用子表达式删除、代码移动，及常量折叠）的优化。
- `FP_CONTRACT ON` 允许缩略浮点表达式，即忽略舍入错误和浮点异常的优化，被观察成表达式以如同书写方式准确求值。
- `CX_LIMITED_RANGE OFF` 告知编译器复数的乘法、除法，及绝对值可以用简化的数学公式，不考虑中间溢出的可能性。
- `FENV_ROUND` 浮点舍入方式。
- `FENV_DEC_ROUND` 十进制浮点舍入方式。

> *非标准语用*

```c
#pragma once		// 当某个头文件中包含它时，指示编译器只对其分析一次

#pragma pack		// 控制后继定义的结构体和联合体的最大对齐系数
#pragma pack(integer)          // 设置当前对齐为值 integer
#pragma pack()                 // 恢复默认对齐
#pragma pack(push)             // 推入当前对齐到内部栈
#pragma pack(push, integer)    // 推入当前对齐到内部栈并设置对齐为 integer
#pragma pack(pop)              // 从内部栈弹出栈顶对齐值并恢复当前对齐为该值

#pragma unpack()     // 取消上次设定的对齐系数
```

>---
####  8.9. 预定义宏

下列宏名称在任意翻译单元中均被预定义：

| Macro                                                                          | Description                                                                                                                        |
| :----------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------- |
| `__STDC__`                                                                     | 展开成整数常量 1。此宏是用以指示遵从标准的实现                                                                                     |
| `__STDC_VERSION__`                                                             | 展开成 `long` 类型的整数常量，其值随着 C 标准的每个版本递增                                                                        |
| `__STDC_HOSTED__`                                                              | 若实现有宿主（在操作系统下运行），则展开成整数常量 1，若为自立的（不在操作系统中运行）则展开成 ​0                                  |
| `__FILE__`                                                                     | 展开成当前文件名，为字符串字面量，可用 `#line` 指令更改                                                                            |
| `​__LINE__`                                                                    | 展开成源文件行号，为整数常量，可用 #line 指令更改                                                                                  |
| `__DATE__`                                                                     | 展开成翻译的日期，格式为 `"Mmm dd yyyy"` 的字符串字面量。月份名如同以 `asctime` 生成，而若月之日期小于 10 则 `"dd"` 的首字符为空格 |
| `__TIME__`                                                                     | 展开成翻译的时间，格式为 `"hh:mm:ss"` 的字符串字面量，如同 `asctime()` 所生成                                                      |
| `__STDC_UTF_16__`                                                              | 扩展为 1 以指出 `char16_t` 使用 UTF-16 编码                                                                                        |
| `__STDC_UTF_32__`                                                              | 扩展为 1 以指出 `char32_t` 使用 UTF-32 编码                                                                                        |
| `__STDC_EMBED_NOT_FOUND__`>---`__STDC_EMBED_FOUND__`>---`__STDC_EMBED_EMPTY__` | 分别扩展为 ​0​、1 和 2                                                                                                             |
  
实现可能预定义下列额外宏名：

| Macro                        | Description                                                                                                         |
| :--------------------------- | :------------------------------------------------------------------------------------------------------------------ |
| `__STDC_ISO_10646__`         | 若 wchar_t 使用 Unicode，则展开成形式为 yyyymmL 的整数常量，日期指示受支持的 Unicode 最近版本                       |
| `__STDC_IEC_559__`           | 若支持 IEC 60559 则展开成 1 (弃用) (C23 起)                                                                         |
| `__STDC_IEC_559_COMPLEX__`   | 若支持 IEC 60559 复数算术则展开成 1 (弃用) (C23 起)                                                                 |
| `__STDC_UTF_16__`            | 若 `char16_t` 使用 UTF-16 则展开成 1                                                                                |
| `__STDC_UTF_32__`            | 若 `char32_t` 使用 UTF-32 则展开成 1                                                                                |
| `__STDC_MB_MIGHT_NEQ_WC__`   | 若 `'x' == L'x'` 可能对基础字符集的成员为 `false` 则展开成 1，例如在基于 EBCDIC 的，`wchar_t` 使用 Unicode 的系统上 |
| `__STDC_ANALYZABLE__`        | 若支持可分析性则展开成 1                                                                                            |
| `__STDC_LIB_EXT1__`          | 若支持边界检查接口则展开成整数常量 201112L                                                                          |
| `__STDC_NO_ATOMICS__`        | 若不支持原子类型和原子操作库则展开成 1                                                                              |
| `__STDC_NO_COMPLEX__`        | 若不支持复数类型和复数运算库则展开成 1                                                                              |
| `__STDC_NO_THREADS__`        | 若不支持多线程则展开成 1                                                                                            |
| `__STDC_NO_VLA__`            | 若不支持自动存储期的 (C23 起) 非常量长度数组及可变修改类型 (C23 前) 则展开成 1                                      |
| `__STDC_IEC_60559_BFP__`     | 若支持 IEC 60559 二进制浮点算术则展开成 202311L                                                                     |
| `__STDC_IEC_60559_DFP__`     | 若支持 IEC 60559 十进制浮点算术则展开成 202311L                                                                     |
| `__STDC_IEC_60559_COMPLEX__` | 若支持 IEC 60559 复数算术则展开成 202311L                                                                           |
| `__STDC_IEC_60559_TYPES__`   | 若支持 IEC 60559 互换可扩展类型则展开成 202311L                                                                     |

这些宏的值（除了 `__FILE__` 和 `__LINE__`）在整个翻译单元中保持常量。尝试重定义或解除定义这些宏导致未定义行为。

>---

#### 8.10. 预定义变量

预定义变量 `__func__` 不是预处理器宏，`__func__` 替换为当前函数名称。

```c
void example(){
    printf("%s\n", __func__);
}
// prints "example"
```

---
### 9. Annex
#### 9.1. 流与文件

> Stream（流）

流（stream）是输入与输出设备的抽象，无论是从终端或磁带机等物理设备输入和输出，还是从结构化存储设备支持的文件输入和输出，都映射为逻辑数据流，用来统一各种的输入与输出概念。有两种概念的映射：文本流和二进制流。

- **文本流** 是由行组成的有序字符序列。可能必须在输入与输出时添加、修改或删除字符，以符合 OS 中的文本表示（例如 Win 上的 C 流在输出时将 `\n` 转换为 `\r\n`，而输入时将 `\r\n` 转换为 `\n`）。若需要保证从文本流读入的数据和先前写入该流的数据相等，必须满足：
  - 数据仅由打印字符和控制字符（`\t`，`\n`）组成；
  - 没有空格字符紧接在换行字符之前（` \n`）；
  - 最后一个字符是换行符 `\n`。

+ **二进制流** 是一个有序的字符序列。在相同的实现下，从二进制流读入的数据应该与早先写进该流的数据比较相等。这样的流可以在流的末尾附加上不确定数目的实现定义的空字符。

每个流都有一个方向。在流与外部文件关联后，在对其执行任何操作之前，流没有方向。一旦将宽字符输入输出函数应用于没有方向的流，该流就成为宽方向流。一旦将字节输入输出函数应用于没有方向的流，该流就会成为面向字节的流。只有调用 `freopen` 或 `fwide` 函数才能改变流的方向，如果成功调用 `freopen`，则会消除任何定向。

字节输入输出函数不能应用于面向宽的流，宽字符输入输出函数不能应用于面向字节的流。其余的流操作不影响流的方向，也不受流方向的影响，除了：
  - 二进制宽定向流具有文本流和二进制流的文件定位限制；
  - 对于面向宽的流，在成功调用文件定位函数（在文件结束之前留下文件位置指示符）之后，宽字符输出函数可以覆盖部分多字节字符；之后任何超出写入字节的文件内容从此可能不包含有效的多字节字符。

每个面向宽的流都有一个关联的 `mbstate_t` 对象，用于存储流的当前解析状态。对 `fgetpos` 的成功调用将这个 `mbstate_t` 对象的值的表示存储为 `fpos_t` 对象值的一部分。稍后使用相同的存储的 `fpos_t` 值成功调用 `fsetpos` 将恢复相关的 `mbstate_t` 对象的值以及在受控流中的位置。

每个流都有一个相关的锁，用于防止多个执行线程访问同一流时的数据竞争，并限制多个线程执行的流操作的交错。一次只有一个线程可以持有这个锁。锁是可重入的：一个线程可以在给定时间多次持有锁。所有读、写、定位或查询流位置的函数在访问流之前都会锁定流。当访问完成时，它们释放与流关联的锁。

> Files（文件）

通过打开文件，流与外部文件（可能是物理设备）相关联。如果一个文件可以支持定位请求，那么与流关联的文件位置指示器定位在文件的开始，除非文件以追加模式打开。文件位置指示器由随后的读取、写入和定位请求等维护，以保证指示器在文件中的有序前进。

当流 *无缓冲* 时，字符将从源端或目标端尽快出现，字符可能会作为一个块被累积和传输到主机环境或从主机环境传输出去。当流 *全缓冲* 时，在缓冲区被填满时，字符将作为一个块传输到主机环境或从主机环境传输出去。当流 *行缓冲* 时，在遇到换行符时，字符将作为块传输到主机环境或从主机环境传输出去。此外，在缓冲区被填满时、或者是在未缓冲的流上请求输入时、或者在需要从主机环境传输字符的行缓冲流上请求输入时，字符将作为块传输到主机环境中。

可以通过关闭文件来解除文件与控制流的关联。输出流在与文件解除关联之前被刷新，任何未写入的缓冲区内容都被传输到主机环境。`FILE` 对象的生存期在相关文件（包括标准文本流）关闭时结束。该文件可能随后由相同或另一个程序执行重新打开，并回收或修改其内容。如果 `main` 函数返回到它的原始调用方，或者如果 `exit` 函数被调用，则在程序终止之前正确关闭所有打开的文件。其他终止程序（例如调用 `abort` 函数）的途径不需要正确关闭所有文件。

在程序启动时，三个文本流是预定义的，并且已经打开：标准输入（`stdin`）、标准输出（`stdout`）和标准错误（`stderr`）。在最初打开时，标准错误流未被完全缓冲；当且仅当标准输入和标准输出流可以被确定为不引用交互式设备时，该流才被完全缓冲。 

打开其他（非临时）文件的函数需要一个文件名，文件名是一个字符串。虽然文本和二进制宽面向流在概念上都是宽字符序列，但与宽面向流相关的外部文件是多字节字符序列。文件中的多字节编码可能包含嵌入的空字节（与程序内部使用的有效多字节编码不同），文件也不必以初始移位状态开始或结束。此外，用于多字节字符的编码在文件之间可能不同。这种编码的性质和选择都是由实现定义的。

宽字符输入函数从流中读取多字节字符，并将其转换为宽字符，就像连续调用 `fgetwc` 函数一样。每次转换都像调用 `mbrtowc` 函数一样发生，转换状态由流自己的 `mbstate_t` 对象描述。字节输入函数从流中读取字符，就像连续调用 `fgetc` 函数一样。字符输出函数将宽字符转换为多字节字符，并将其写入流，就像连续调用 `fputwc` 函数一样。每次转换都像调用 `wcrtomb` 函数一样发生，转换状态由流自己的 `mbstate_t` 对象描述。字节输出函数将字符写入流，就像连续调用 `fputc` 函数一样。

在某些情况下，一些字节输入输出函数还执行多字节字符和宽字符之间的转换。如果提供给底层 `mbrtowc` 函数的字符序列没有形成有效的（通用的）多字节字符，或者传递给底层 `wcrtomb` 的代码值不对应于有效的（通用的）多字节字符，则会发生编码错误。当且仅当编码错误发生时，宽字符输入输出函数和字节输入输出函数将宏 `EILSEQ` 的值存储在 `errno` 中。

> *fopen-like* 函数

```c
FILE *fopen(const char *restrict filename, const char *restrict mode);
```

`fopen` 函数中，参数 `mode` 的格式字符串：
  - `"r"` 表示打开文件以读取，`"a"` 表示打开或创建文件以末尾写入，`"w"` 表示打开清空或创建文件并从头写入；
  - 附加二进制访问标签 `"b"` 表示使用二进制模式（默认使用文本模式，仅在 Windows 上生效）。
  - 附加更新模式标签 `"+"` 表示文件打开时可以在相关的流上进行读取和写入。但是如果不调用 `fflush` 或文件定位函数时，输出不能直接跟在输入后面；如果不调用文件定位函数，输入不能直接跟在输出后面。
  - 附加排他模式标签 `"x"` 可以可选地后附到 `"w"` 或 `"w+"` 指定符，表示文件存在或无法创建时，强制函数是失败。
  - 附加默认 `fopen` 许可标签 `"u"` 可以可选地前附到 `"w"` 或 `"a"` 指定符，表示启用默认的 `fopen` 许可。一般使用 `fopen` 时，文件以 `"w"` 或 `"a"` 创建的文件的文件许可是禁止任何其他用户访问它（独占模式）。

`"r"` 读取模式： 
  - `"r"`：打开文本文件并从头读取（文本模式打开读取）
  - `"rb"`：打开二进制文件并从头读取（二进制模式打开读取）
  - `"r+"`：打开文本文件并从头进行读写更新（文本模式打开读写更新）
  - `"r+b"/"rb+"`：打开二进制文件并从头进行读写更新（二进制模式打开读写更新）

`"a"` 追加模式：
  - `"a"`：打开或创建文本文件，以便在文件末尾写入（文本模式创建或打开写入）
  - `"ab"`：打开或创建二进制文件，以便在文件末尾写入（二进制模式创建或打开写入）
  - `"a+"`：打开或创建文本文件，以便在文件末尾读写更新（文本模式创建或打开读写更新）
  - `"a+b"\"ab+"`：打开或创建二进制文件，以便在文件末尾读写更新（二进制模式创建或打开读写更新）

`"w"` 文件访问模式：
  - `"w"`：截断为零长度或创建用于写入的文本文件（文本模式创建或打开写入）
  - `"wb"`：截断为零长度或创建用于写入的二进制文件（二进制模式创建或打开写入）
  - `"w+"`：截断为零长度或创建用于读写更新的文本文件（文本模式创建或打开读写更新）
  - `"w+b"/"wb+"`：截断为零长度或创建用于读写更新的二进制文件（二进制模式创建或打开读写更新）

`"wx` 文件访问模式： 
  - `"wx"`：创建文本文件以写入，文件存在则失败（文本模式创建写入）
  - `"wbx"`：创建二进制文件以写入，文件存在则失败（二进制模式创建写入）
  - `"w+x"`：创建文本文件以读写更新，文件存在则失败（文本模式创建读写更新）
  - `"w+bx"/"wb+x"`：创建二进制文件以读写更新，文件存在则失败（二进制模式创建读写更新）

如果文件不存在或无法读取，则以读取模式（`mode` 参数中的第一个字符为 “`'r'`”）打开文件将失败。当打开时，当且仅当可以确定流不引用交互式设备时，流被完全缓冲。流的错误和文件结束指示符将被清除。

```c
#include <stdio.h>
void test_fopen()
{
#define m_filename "myfile.txt"
    FILE *my_file;
    if (!fopen_s(&my_file, m_filename, "a")) // 追加写入
    {
        fprintf(my_file, "Hello world");
        fclose(my_file);
    }
    // 程序结束时会自动 fflush
}
```

>---
#### 9.2. 格式化输出

*print-like* 函数参数 `format`，由普通多字节和若干的 *转换说明符* 构成。每个格式规范由字符 `%` 表示，在 `%` 之后，可以出现：
  - 修改转换规范的零个或多个 **标志**（任何顺序）；
  - **可选的最小字符宽度**。转换值的字符少于字符宽度时用空格填充，字符宽度采用星号或者非负十进制整数的形式；
  - **可选的精度**。即给出 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换要出现的最小位数，`a`、`A`、`e`、`E`、`f`、`F` 转换要出现在小数点后的位数，`g`、`G` 转换的最大有效位数，`s` 转换要写入的最大字节数。其中精度采用句点 `.` 后跟星号或可选的非负十进制整数（只指定句点表示精度为 0）。如果精度与其他的转换说明符一起出现则行为未定义；
  - **可选的长度修饰符**，用于指定实参的大小；
  - **指定要应用的转换类型的转换说明符**。

字符的精度或宽度，都可以用 `*` 表示。此时需要提供一个 `int` 参数提供对应的数值，此时会插入一个宽度或精度参数到该转换说明符对应格式参数的位置之前。宽度提供负数表示左对齐的字符宽度；精度提供负数则精度将被忽略。

```c
printf("%*d", -5, 10);   // - 表示左对齐, 5 指定 %*d 的字符宽度至少为 5, 10 对应 "%d"
```

> 标志字符（flags）：

+ `-`：要求转换后的结果在字段内左对齐（未指定时右对齐），如 `"%-d"`、`"%-.2f"`、`"%-10s"`；

- `+`：数值转换结果显示符号字符，未指定时数值时仅在负值时显示符号，如 `"%+lu"`；

+ ` `：空格，表示带符号转换不产生字符时，在结果前加一个空格（同时出现空格和 `+`，则忽略空格），如 `% d`；

- `#`：结果转换为替代模式：
  - 对于 `o` 转换，当且仅当必要时，它会增加精度，以强制结果的第一位为零，如果值和精度都为 0，则打印单个 0（`"%#o",9` = `"011"`，`"%#o",0` = `0`）；
  - 对于 `b` 转换，非零结果的前缀为 `0b`；
  - 对于可选的 `B` 转换，非零结果的前缀为 `0B`。
  - 对于 `x` （或 `"X"`） 转换，非零结果带有 `"0x"` （或 `"0X"`） 前缀；
  - 对于 `a`，`A`，`e`，`E`，`f`、`F`、`g`、`G` 转换，转换浮点数的结果总是包含一个小数点符号（通常，只有当小数点字符后面有一个数字时，它才会出现在这些转换的结果中。）。
  - 对于其他转换则行为未定义；

+ `0`：对于 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X`、`a`、`A`、`e`、`E`、`f`、`F`、`g`、`G` 转换，除非转换无穷大或 NaN，否则使用前导零（在任何符号或基数指示之后）用于填充字段宽度，而不是用空格填充。同时出现 `-` 和 `0` 则忽略前导零。对于 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 指定精度时，忽略前导零。对于其他的转换则行为未定义。

> 长度修饰符（length modifier）：

- `hh`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `signed char` 或 `unsigned char` 参数（参数将根据整数提升进行提升，但其值应在打印前转换为 `signed char` 或 `unsigned char`）；对于 `hhn` 适用于 `signed char` 类型的指针参数。 

+ `h`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `signed short` 或 `unsigned short` 参数；对于 `hn` 则适用于 `signed short` 类型的指针参数。 

- `l`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `signed long` 或 `unsigned long` 参数；对于 `ln` 则应用 `signed long` 类型的指针参数；`lc` 则应用 `wint_t` 参数；`ls` 应用 `wchar_t` 类型的指针参数；对于浮点数的转换说明符则没有效果。

+ `ll`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `signed long long` 或 `unsigned long long` 参数；对于 `lln` 则应用 `signed long long` 类型的指针参数。 

- `j`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `intmax_t` 或 `uintmax_t` 参数；对于 `jn` 则应用 `intmax_t` 类型的指针参数。 

+ `z`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `size_t` 或相应的有符号整数参数；对于 `zn` 则应用 `size_t` 类型的指针参数。 

- `t`：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符适用于 `ptrdiff_t` 或相应的无符号整数参数；对于 `tn` 则应用 `ptrdiff_t` 类型的指针参数。 

+ `w`*N*：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符应用于具有特定宽度的整数参数，其中 *N* 是不带前导零的十进制正整数（参数将根据整数提升进行提升，但其值应转换为未提升的类型）；对于 `w`*N*`n` 则应用指向具有 *N* 位宽度的整数类型参数的指针。应支持 `stdint.h` 头文件中定义的所有最小宽度整数类型和精确宽度整数类型。

- *`wf`*N：指定 `b`、`B`、`d`、`i`、`o`、`u`、`x`、`X` 转换说明符应用于最快最小宽度的整数参数，其中 *N* 是不带前导零的十进制正整数（参数将根据整数提升进行提升，但其值应转换为未提升的类型）；对于 `wf`*N*`n` 则应用指向具有 *N* 位宽度的最快最小整数类型参数的指针。应支持 `stdint.h` 头文件中定义的所有最快最小宽度整数类型和精确宽度整数类型。

+ `L`：指定 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 转换说明符应用 `long double` 类型参数。

- `H`：指定 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 转换说明符应用 `_Decimal32` 类型参数。

+ `D`：指定 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 转换说明符应用 `_Decimal64` 类型参数。

- `DD`：指定 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 转换说明符应用 `_Decimal128` 类型参数。

+ 如果长度修饰符与其他转换符一起出现，则行为未定义。

> 转换说明符：

- `d`、`i`：`int` 参数转换成有符号十进制整数 *[-]dddd* 形式。`%.*d` 精度指定要显示的最小位数，如果转换的位数不足则以前导零进行扩展（默认精度为 1，转换精度为 0 的零值 `%.d, 0` 结果是没有字符）。

+ `b`、`B`、`o`、`u`、`x`、`X`：`unsigned int` 参数分别转换形式为 *dddd* 的无符号二进制 `b` 或 `B`、无符号八进制 `o`、无符号十进制 `u`、无符号十六进制 `x` 或 `X`。精度指定要显示的最小位数，不足位数则以前导 0 填充。默认精度为 1。转换精度为零的零值的结果是没有字符。说明符 `B` 是可选的。

- `f`、`F`：表示浮点数的 `double` 转换为十进制 *[-]ddd.ddd* 形式。精度指定要显示的小数位数，未指定时默认精度为 6，舍入方式是四舍五入。若精度为 0 且未指定 `#` 标志，则不显示小数点字符。对于无穷大，则显示 `[-]inf` 或 `[-]infinity`；NaN 则显示为 `[-]nan` 或 `[-]nan(n-char-sequence)` 则是实现定义的。`F` 则分别显示为 `INF`、`INFINITY`、`NAN`。

+ `e`、`E`：表示浮点数的 `double` 转换为十进制 *[-]d.ddd±dd* 形式。精度指定要显示的小数位数，未指定时默认精度为 6，舍入方式为四舍五入。若精度为 0 且未指定 `#` 标志，则不显示小数点字符。`E` 则表示 `e[±dd]` 替换为 `E[±dd]`。指数总是至少包含两位数字，位数不足用零补齐。

- `g`、`G`：表示浮点数的 `double` 根据值和精度自动转换为 `e` 或 `f` 的样式。指定 $P$ 表示为精度，若精度未指定时 $P$ 为 6，精度为 0 时 $P$ 为 1。若带 `E` 的转换会有指数 $X$：若 $P$ > $X$ >= -4，转换为 `f` 的样式及精度 $P$ - 1 - $E$；否则为 `e` 风格及精度 $P$ - 1。除非使用 `#` 标志，否则将从结果的小数部分中删除任何尾随零，如果没有剩余的小数部分，则将删除小数点字符。

+ `a`、`A`：表示浮点数的 `double` 转换为十六进制 P 计数法下的 *[-]0xh.hhhp±d* 形式。精度指定要显示的小数位数，若精度为 0 且未指定 `#` 标志，则不显示小数点字符。若参数是正规化的浮点值，则首位数非 0。若值为 0，则指数为 0。指数总是至少包含一位数字。

- `c`：没有长度修饰符 `l` 则转换 `int` 参数为 `unsigned char`，并写入结果字符。若使用 `l` 修饰，则 `wint_t` 参数就像由一个没有精度的 `%ls` 转换规范和一个指向 `wchar_t[2]` 双元素数组的初始元素的参数进行转换，第一个元素包含指向 `lc` 转换规范的 `wint_t` 参数，第二个元素包含一个空宽字符。

+ `s`：没有长度修饰符 `l` 则实参是指向字符类型数组的指针，数组中的字符写到空终止符 `\0`。精度指定写入字符的最大数目。未指定精度或精度大于数组的大小，则数组必须包含空终止符。若使用了长度修饰符 `l` 则参数必须是指向 `wchar_t` 数组。

- `p`：实参是指向 `void` 的指针。指针的值以实现定义的方式转换为一系列打印字符。

+ `n`：实参应该是一个指向有符号整数的指针 `int *`，该指针表示调用 `fprintf` 到目前为止写入输出流的字符数。该转换符不会转换任何类型，但是会占用一个格式参数（必须是 `int *`），并且会将当前位置的字符数结果被写入到参数中。转换规范中不可包含任何标志，宽度，精度。
- `%`：`%%` 打印一个 `"%"` 百分号。没有参数被转换。

对于 `e`、`E`、`f`、`F`、`g` 和 `G` 转换，有效十进制位数的数量最多是对应类型的 `T_DECIMAL_DIG`（如 `FLT_DECIMAL_DIG`）的最大值 *M*，那么结果应该是正确的四舍五入。如果有效十进制位数的数量多于 *M*，但是源值可以用 *M* 数字精确地表示，那么结果应该是带末尾零的精确表示。否则，源值被两个相邻的十进制字符串 *L < U* 包围，其中字符串 *L* 和 *U* 都有 *M* 位有效数字；所得到的十进制字符串 *D* 的值应满足 *L ≤ D ≤ U*，并附带一个额外的规定，即误差应具有当前舍入方向的正确符号。

> *格式转换案例*

```c
#include <stdio.h>
 
int main(void)
{
    printf("%s", "Strings:\n");
    const char s[] = "Hello";
    printf("\t.%10s.\n\t.%-10s.\n\t.%*s.\n", s, s, 10, s);
 
    printf("Characters:\t%c %%\n", 65);
 
    printf("%s", "Integers\n");
    printf("Decimal:\t%i %d %.6i %i %.0i %+i %u\n", 1, 2, 3, 0, 0, 4, -1);
    printf("Hexadecimal:\t%x %x %X %#x\n", 5, 10, 10, 6);
    printf("Octal:\t%o %#o %#o\n", 10, 10, 4);
 
    printf("%s", "Floating point\n");
    printf("Rounding:\t%f %.0f %.32f\n", 1.5, 1.5, 1.3);
    printf("Padding:\t%05.2f %.2f %5.2f\n", 1.5, 1.5, 1.5);
    printf("Scientific:\t%E %e\n", 1.5, 1.5);
    printf("Hexadecimal:\t%a %A\n", 1.5, 1.5);
}
/*
Strings:
    .     Hello.
    .Hello     .
    .     Hello.
Characters:     A %
Integers
Decimal:        1 2 000003 0  +4 4294967295
Hexadecimal:    5 a A 0x6
Octal:          12 012 04
Floating point
Rounding:       1.500000 2 1.30000000000000004440892098500626
Padding:        01.50 1.50  1.50
Scientific:     1.500000E+00 1.500000e+00
Hexadecimal:    0x1.8p+0 0X1.8P+0
*/
```

> *十进制浮点数格式化输出*

```c
int main(){
	_Decimal32 x = 6543.00DF; // (+1, 654300, -2)
	fprintf(stdout, "%Ha\n", x);  	  // 6543.00		
	fprintf(stdout, "%.6Ha\n", x);	  // 6543.00
	fprintf(stdout, "%.5Ha\n", x);	  // 6543.0
	fprintf(stdout, "%.4Ha\n", x);	  // 6543
	fprintf(stdout, "%.3Ha\n", x);	  // 6.54e+3
	fprintf(stdout, "%.2Ha\n", x);	  // 6.5e+3
	fprintf(stdout, "%.1Ha\n", x);	  // 7e+3
	fprintf(stdout, "%.0Ha\n", x);	  // 6543.00
}
```

>---
#### 9.3. 格式化输入

*scanf-like* 函数参数 `format` 指定可接受的输入序列以及如何将它们转换为赋值，并使用后续对应参数作为指向对象的指针来接收转换后的输入。格式字符串由下列内容组成：
  - **非空白多字节字符**，除了 `%`：每个格式字符串中的这种字符处理来自输入流的准确同一字符，或若它与流的下个字符比较不相等则导致函数失败。
  - **空白符**：任何格式字符串中的单个空白符处理所有来自输入的可用连续空白符（符合 `isspace` 规定）。格式字符串中 `"\n"`、`" "`、`"\t\t"` 或其他空白无区别。
  - **转换规范**：转换规范由字符 `%` 表示，在 `%` 之后，依次出现以下内容：
    - 可选的赋值抑制字符 `*`；
    - 可选的大于零的十进制整数，指定最大字符宽度（如不提供宽度，`%s`、`%[` 可能会导致缓冲区溢出）；
    - 可选的长度修饰符，指定接收对象的类型大小；
    - 指定要应用的转换类型的转换说明符。

格式输入函数会依次执行该 `format` 格式的每个指令。当所有的指令都被执行完，或其中一个指令失败时函数返回。失败被描述为输入失败（编码错误或输入字符不可用）或匹配失败（不适当的输入）。空白字符不被读取，除非有指令匹配。

> 长度修饰符： 	

- `hh`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `signed char` 或 `unsigned char` 的指针参数。

+ `h`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `signed short` 或 `unsigned short` 的指针参数。

- `l`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 适用于指向 `long int` 或 `unsigned long` 的指针参数；指定 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 适用于指向 `double` 的指针参数；指定的 `c`、`s` 或 `[` 转换说明符应用于指向 `wchar_t` 的指针参数。

+ `ll`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `long long` 或 `unsigned long long` 的指针参数。

- `j`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `intmax_t` 或 `uintmax_t` 的指针参数。

+ `z`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `size_t` 或相应的有符号整数类型的指针参数。

- `t`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `ptrdiff_t` 或相应的无符号整数类型的指针参数。

+ `w`*N*：指定的 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 转换说明符应用于指向具有特定宽度的整数的指针参数，其中 *N* 是不带前导零的十进制正整数。

- `wf`*N*：指定的 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 转换说明符应用于指向具有特定宽度的最快最小宽度整数的指针参数，其中 *N* 是不带前导零的十进制正整数。

+ `L`：指定的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 应用于指向 `long double` 的指针参数。

- `H`：指定的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 应用于指向 `_Decimal32` 的指针参数。

+ `D`：指定的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 应用于指向 `_Decimal64` 的指针参数。

- `DD`：指定的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 应用于指向 `_Decimal128` 的指针参数。

> 转换说明符：

- `d`：匹配一个可选的有符号十进制整数，对应的实参是一个指向 `int` 的指针，除非指定了长度修饰符。

+ `b`：匹配一个可选的有符号二进制整数，对应的实参是一个指向 `unsigned int` 的指针，除非指定了长度修饰符。

- `i`：匹配一个可选的有符号整数，对应的实参是一个指向 `int` 的指针，除非指定了长度修饰符。

+ `o`：匹配一个可选的有符号八进制整数，对应的实参是一个指向 `unsigned int` 的指针，除非指定了长度修饰符。

- `u`：匹配一个可选的有符号十进制整数，对应的实参是一个指向 `unsigned int` 的指针，除非指定了长度修饰符。

+ `x`：匹配一个可选的有符号十六进制整数，对应的实参是一个指向 `unsigned int` 的指针，除非指定了长度修饰符。

- `a`、`e`、`f`、`g`：匹配可选的有符号浮点数、infinity、NaN。对应的实参是一个指向 `float` 的指针，除非指定了长度修饰符。

+ `c`：匹配正好指定字段宽度的字符序列（未指定字段宽度则为 1）。
  + 若没有长度修饰符，对应的参数是一个足够容纳字符序列的指向 `char`、`signed char`、`unsigned char` 或 `void` 的指针。不会添加空终止符。
  + 若存在 `l` 修饰，则输入应该是一个从初始移位状态开始的多字节字符序列，每个多字节字符被转换为宽字符，对应的实参应该是指向 `wchar_t` 数组初始元素的指针。不会添加宽空终止符。

- `s`：匹配非空白字符序列。
  - 若没有长度修饰，对应的参数是一个足够大的指向 `char`、`signed char`、`unsigned char` 或 `void` 的指针，该数组可以容纳字符序列和一个空终止符（null 字符被自动添加）。
  - 若存在 `l` 则输入应该是一个从初始移位状态开始的多字节字符序列，每个多字节被转换为宽字符，对应的实参应该是指向 `wchar_t` 数组初始元素的指针，宽空终止符会被自动添加。

+ `[`：匹配一组预期字符（扫描集）的非空字符序列。
  + 若没有长度修饰，对应的参数是一个足够大的指向 `char`、`signed char`、`unsigned char` 或 `void` 的指针，该数组可以容纳字符序列和一个空终止符（null 字符被自动添加）。
  + 若存在 `l` 则输入应该是一个从初始移位状态开始的多字节字符序列，每个多字节被转换为宽字符。对应的实参应该是指向 `wchar_t` 数组初始元素的指针，宽空终止符会被自动添加。
  + 若集合的首字符是 `^`，则匹配所有不在集合中的字符。若集合以 `]` 或 `]^` 开始，则 `]` 字符包含在集合中。`-` 可以指示范围（如 `[0-9]`）。

- `p`：匹配定义一个指针的实现定义的字符序列。该序列集应与 `fprinf` 的 `%p` 转换可能产生的序列集相同。对应的实参是指向指向 `void` 的指针的指针（`void **`）。如果输入项是在同一程序执行期间较早转换的值，则结果指针应与该值相等；否则 `%p` 转换的行为未定义。

+ `n`：返回已读取的字符数，且不消耗任何输入。相应的参数应是有符号整数类型的指针。执行 `%n` 指令不会增加 `scanf` 系列函数执行完成时返回的赋值计数。如果转换规范包括禁止赋值的字符或字段宽度，则行为未定义。

- `%%`：匹配单个字符 `'%'`。

+ 转换说明符 `A`、`E`、`F`、`G` 和 `X` 也是有效的，其行为分别与 `a`、`e`、`f`、`g` 和 `x` 相同。

> *格式转换案例*

```c
#define _CRT_SECURE_NO_WARNINGS 1 // 0
#include <stdio.h>
#include <stddef.h>
#include <locale.h>

int main(void)
{
	int i, j;
	float x, y;
	char str1[10], str2[4];
	wchar_t warr[2];
	setlocale(LC_ALL, "en_US.utf8");

	char input[] = "25 54.32E-1 Thompson 56789 0123 56ß水";
	/* 按下列分析：
	   %d ：整数
	   %f ：浮点值
	   %9s ：最多有 9 个非空白符的字符串
	   %2d ： 2 位的整数（数位 5 和 6 ）
	   %f ：浮点值（数位 7 、 8 、 9）
	   %*d ：不存储于任何位置的整数
	   ' ' ：所有连续空白符
	   %3[0-9] ：至多有 3 个十进制数字的字符串（数位 5 和 6 ）
	   %2lc ：二个宽字符，使用多字节到宽转换  */
	int ret = sscanf(input, "%d%f%9s%2d%f%*d %3[0-9]%2lc",
		&i, &x, str1, &j, &y, str2, warr);

	printf("Converted %d fields:\ni = %d\nx = %f\nstr1 = %s\n"
		"j = %d\ny = %f\nstr2 = %s\n"
		"warr[0] = U+%x warr[1] = U+%x\n",
		ret, i, x, str1, j, y, str2, warr[0], warr[1]);

	int n = sscanf_s(input, "%d%f%s", &i, &x, str1, (unsigned)sizeof(str1));
	// 写 25 到 i ， 5.432 到 x ， 9 个字节 "thompson\0" 到 str1 ，和 3 到 n 。
}
```

>---
#### 9.4. 时间格式化输出

```c
size_t strftime( char* restrict str, size_t count, const char* restrict format, const struct tm* restrict tp );
```

`strftime` 按照格式 `format`，转换给定 `tp` 的日期和时间信息为字符串。`format` 中每个转换符都应替换为以下描述的适当字符。适当的字符应该使用当前语言环境的 `LC_TIME` 类别以及 `timeptr` 指向的分解时间结构的零个或多个成员的值来确定。

```c
//=== 符号类
"%%"      // 符号 "%"
"%n"      // 换行符 "\n"
"%t"      // 水平制表符 "\t"

//===  year  年  (tm_year)
"%y"      // 写年的末两位数字 [00,99].
"%Y"      // 以四位十进制写年, 1997.
"%Ey"     // 将年写作本地环境的替用时期 %EC 的偏移 (本地环境依赖).
"%EY"     // 依据区域设置, 以完整替用方式写年, 例如在 ja_JP 环境中, 以 "平成23年" 取代 "2011年". 
"%Oy"     // 以替用数字系统写年的末 2 位数字, 例如在 ja_JP 环境中以 "十一" 取代 "11".
"%C"      // 写年的首两位数字 [00,99].
"%EC"     // 依据区域设置, 以替用表示写年份基底 (时期)，例如 ja_JP 中的 "平成".
"%g"      // 写基于 ISO 8601 的年后两位 [00,99]，包含指定星期.  (tm_year,tm_wday,tm_yday)
"%G"      // 写基于 ISO 8601 的年, 包含指定星期.  (tm_year,tm_wday,tm_yday)

//=== month  月  (tm_mon)
"%b"      // 写缩略月名, 例如 Oct.
"%Ob"     // 替换为区域设置的缩写替代月份名称
"%h"      // 相当于 b.
"%B"      // 写完整月名, 例如 October.
"%OB"     // 依据区域设置, 以替用表示写完整月名.
"%m"      // 将月写作十进制数, [01,12].
"%Om"     // 依据区域设置, 以替用数字系统写月, 例如 ja_JP 本地环境中 "十二" 取代 "12".

//=== weekday 星期  (tm_year,tm_wday,tm_yday)
"%U"      // 以十进制数写年的星期, 星期日是星期的首日, [00,53].
"%OU"     // 依据区域设置, 以替用数值系统写如同用 %U 的年的星期, 例如 "五十二" 在 ja_JP 中取代 "52".
"%W"      // 以十进制数写年的星期, 星期一是星期的首日, [00,53].
"%OW"     // 依据区域设置, 以替用数值系统写如同用 %W 的年的第星期, 例如 "五十二" 在 ja_JP 中取代 "52".
"%V"      // 写 ISO 8601 的年的星期, [00,53].
"%OV"     // 依据区域设置, 以替用数值系统写如同用 %V 的年的星期, 例如 "五十二" 在 ja_JP 中取代 "52".

//=== day of year/month 年/月之日  (tm_mday)
"%j"      // 以十进制数写年的第几日, [001,366].  (tm_yday) 
"%d"      // 以十进制数写月的第几日, [01,31].
"%Od"     // 依据区域设置, 以替用数字系统写零基的月的第几日, 例如 ja_JP 中 "二十七" 取代 "27", 单字符前加空格 (" 1").
"%e"      // 以十进制数写月的第几日, [01,31]. 单数字前加空格.
"%Oe"     // 依据区域设置, 以替用数字系统写一基的月的第几日, 例如 ja_JP 中 "二十七" 取代 "27", 单字符前加空格.

//=== day of week  星期之日  (tm_wday)
"%a"      // 写缩略的星期日期名, 例如 Fri.  
"%A"      // 写完整的星期日期名, 例如 Friday.
"%w"      // 以十进制数写星期日期, 其中星期日是 0, [0,6].
"%Ow"     // 依据区域设置, 用替用数字系统写星期日期, 其中星期日是 0. 例如 ja_JP 中 "二" 取代 "2".
"%u"      // 十进制数写星期日期, 其中星期一是 1, [1-7] (ISO 8601 格式).
"%Ou"     // 依据区域设置, 用替用数字系统写星期日期, 其中星期一是 1. 例如 ja_JP 中 "二' 取代 "2".

//=== hour/min/sec  时,分,秒  (tm_hour), (tm_min), (tm_sec)
"%H"      // 以十进制数写时, 24 小时制 [00-23].
"%OH"     // 依据区域设置, 以替用数字系统写 24 小时制的时, 例如 ja_JP 中 "十八" 取代 "18".
"%I"      // 以十进制数写时, 12 小时制 [01,12].
"%OI"     // 依据区域设置, 以替用数字系统写 12 小时制的时, 例如 ja_JP 中 "六" 取代 "6".
"%M"      // 以十进制数写分[00,59].
"%OM"     // 依据区域设置, 以替用数字系统写分, 例如 ja_JP 中 "二十五" 取代 "25".
"%S"      // 以十进制数写秒 [00,640]. 
"%OS"     // 依据区域设置, 以替用数字系统写秒, 例如 ja_JP 中 "二十四" 取代 "24".

//===== others
"%c"      // 写标准日期时间字符串, 例如 Sun Oct 17 04:41:13 2010.  (All)
"%Ec"     // 依据区域设置, 写替用日期时间字符串, 例如 ja_JP 中 "平成23年" 取代 "2011年".  (All)
"%x"      // 写本地化的日期表示.
"%Ex"     // 依据区域设置, 写替用日期表示, 例如 ja_JP 中 "平成23年" 取代 "2011年".  (All)
"%X"      // 写本地化的时间表示, 例如 18:40:20 或 6:40:20 PM.  (All)
"%EX"     // 依据区域设置, 写替用时间表示.  (All)
"%D"      // 等价于 "%m/%d/%y". (tm_mon, tm_mday, tm_year)
"%F"      // 等价于 "%Y-%m-%d", ISO 8601 日期格式.  (tm_mon, tm_mday, tm_year)
"%r"      // 写本地化的 12 小时制时间.  (tm_hour, tm_min, tm_sec)
"%R"      // 等价于 "%H:%M".  (tm_hour, tm_min)
"%T"      // 等价于 "%H:%M:%S", ISO 8601 时间格式.  (tm_hour, tm_min, tm_sec)
"%p"      // 写本地化的 a.m. 或 p.m.  (tm_hour)
"%z"      // 以 ISO 8601 格式（例如 -0430 ）写距 UTC 的偏移，或者倘若时区信息不可用则不写字符.  (tm_isdst)
"%Z"      // 写依赖本地环境的时区名或缩写，或者若时区信息不可用则不写字符.  (tm_isdst)
```

在 `"C"` 的区域设置中，`E` 和 `O` 被忽略，以下说明符的替换字符串为：

```c
"%a"      // %A 的前三个字符
"%A"      // "Sunday", "Monday", . . . , "Saturday" 之一
"%b"      // %B 的前三个字符
"%B"      // "January", "February", . . . , "December" 之一	
"%c"      // 相当于 "%a %b %e %T %Y"
"%p"      // "AM" 或 "PM" 之一
"%r"      // 相当于 "%I:%M:%S %p"
"%x"      // 相当于 "%m/%d/%y"
"%X"      // 相当于 "%T"
"%Z"      // 实现定义。
```

> strftime

```c
#include <stdio.h>
#include <time.h>
#include <locale.h>

int main(void)
{
    char buff[70];
    struct tm timer;
    time_t time_l = time(NULL);
    localtime_s(&timer, &time_l);

    setlocale(LC_TIME, "zh_CN.utf8");
    if (strftime(buff, sizeof buff, "[Native format]= %A %c", &timer))
        puts(buff); // [Native format]= 星期一 2000/1/1 0:00:00

    setlocale(LC_TIME, "en_us.utf8");
    if (strftime(buff, sizeof buff, "[USA format] = %A %c", &timer))
        puts(buff); // [USA format] = Monday 1/1/2000 0:00:00 AM
}
```

>---
#### 9.5. 原子操作

`stdatomic.h` 提供原子操作、互斥、条件变量的内建支持。

> 多线程执行和数据竞争

在没有定义 `__STDC_NO_THREADS__` 宏的宿主环境中，程序可以并发运行多个执行线程（或线程）。线程 *T* 在特定点上可见的对象的值是该对象的初始值、*T* 存储在该对象中的值或另一个线程存储在该对象中的值。如果其中一个表达式计算修改内存位置，而另一个表达式计算读取或修改相同的内存位置，则两个表达式计算会发生冲突。

`stdatomic.h` 库定义了原子操作，`threads.h` 定义了对互斥锁的操作，这些操作被特别标识为同步操作。对一个或多个内存位置的同步操作可以是 *获取操作*、*释放操作*、*获取和释放操作* 或 *消耗操作*。没有关联内存位置的同步操作是一个屏障（*fence*），可以是 *获取屏障*、*释放屏障*，或 *获取和释放屏障*。此外，还有不属于同步操作的 *宽松原子操作*，以及具有特殊特征的 *原子读-修改-写操作*。

例如，获取互斥锁的调用将对组成互斥锁的位置执行获取操作。相应地，释放相同互斥锁的调用将在这些相同的位置执行释放操作。非正式地，对 *A* 执行释放操作会强制其他内存位置上先前的副作用对稍后对 *A* 执行获取或消耗操作的其他线程可见。宽松的原子操作不包括在同步操作中，尽管与同步操作一样，它们不会导致数据争用。

对特定原子对象 *M* 的所有修改都以某种特定的总顺序发生，称为 *M* 的修改顺序。如果 *A* 和 *B* 是原子对象 *M* 的修改，并且 *A* 发生在 *B* 之前，那么 *A* 应按照 *M* 的修改顺序在 *B* 之前。每个原子对象都有单独的顺序。以原子对象 *M* 上的释放操作 *A* 为首的释放序列是 *M* 修改顺序中副作用的最大连续子序列，其中第一个操作是 *A*，每个后续操作要么由执行释放的同一线程执行，要么是 *原子读-修改-写操作*。

某些库调用与另一个线程执行的其他库调用同步（“*synchronizes with*”）。对对象 *M* 执行释放操作的原子操作 *A* 与对 *M* 执行获取操作的原子操作 *B* 同步，并读取以 *A* 为首的释放序列中任何副作用写入的值。同步操作定义了何时读取另一个值。对于原子变量，对给定互斥锁的所有操作都以单一的总顺序发生，每个获取互斥锁都会 “读取” 上一次释放互斥锁时 “写入的值”。

如果满足下列条件，则求值 *A* 依赖于（*carries a dependency*，“*synchronizes with*” 关系的子集）求值 *B*：
- *A* 的值用作 *B* 的操作数，除非：
  - *B* 是 `kill_dependency` 宏的调用，
  - *A* 是 `&&` 或 `||` 运算符的左操作数；
  - *A* 是 `? :` 运算符的左操作数，或，
  - *A* 是 `,` 运算符的左操作数。
- 或，*A* 写入标量对象或位域 *M*，*B* 从 *M* 中读取 *A* 写入的值，并且 *A* 顺序在 *B* 之前，或
- 对于某些求值 *X*，*A* 对 *X* 有依赖，*X* 对 *B* 有依赖。

如果满足以下条件，则求值 *A* “*dependency-ordered before*” 求值 *B*（类似于 “*synchronizes with*”，但是使用 *释放 / 消耗* 来代替 *释放 / 获取*）：
- 求值 *A* 对原子对象 *M* 执行释放操作，在另一个线程中，求值 *B* 对 *M* 执行消耗操作，并读取在释放序列中以求值 *A* 为首的任何副作用写入的值，或者；
- 对于某些求值 *X*，求值 *A* “*dependency-ordered before*” 求值 *X*，并且 *X* 对 *B* 有依赖关系。

如果求值 *A* “*synchronizes with*” 求值 *B*，或求值 *A* “*dependency-ordered before*” 求值 *B*，或对于下列的某些求值 *X*，则求值 *A* “*inter-thread happens before*” 求值 *B* ：
- *A* “*synchronizes with*” *X*，*X* “*sequenced before*” *B*；
- *A* “*sequenced before*” *X*，且 *X* “*inter-thread happens before*” *B*；
- *A* “*inter-thread happens before*” *X*，且 *X* “*inter-thread happens before*” *B*。

“*inter-thread happens before*” 关系描述了 “*sequenced before*”、“*synchronizes with*” 和 “*dependency-ordered before*” 关系的任意串联，但有两个例外。
- 第一个例外是，串联不允许以 “*dependency-ordered before*” 后跟 “*sequenced before*” 结尾。造成此限制的原因是，参与 “*dependency-ordered before*” 关系的消耗操作仅针对此消耗操作具有依赖关系的操作提供排序。此限制仅适用于以此类串联结尾的原因是，任何后续发布操作都将为先前的消费操作提供所需的排序。
- 第二个例外是，串联不允许完全由 “*sequenced before*” 组成。这种限制的原因，一是允许 “*inter-thread happens before*” 被传递地关闭，二是 “*happens before*” 关系提供了完全由 “*sequenced before*” 组成的关系。

如果求值 *A* “*sequenced before*” 求值 *B*，或 *A* “*inter-thread happens before*” *B*，则求值 *A* “*happens before*” 求值 *B*。实现应确保没有程序执行在 “*happens before*” 关系的循环中。

对象 *M* 的可见副作用（“*visible side effect*”）*A* 相对 *M* 的值的计算过程 *B* 应满足：*A* *happens before* *B*；且 *X* 对 *M* 没有其他副作用，因此 *A* *happens before* *X*，*X* *happens before* *B*。由求值 *B* 确定的非原子标量对象 *M* 的值应为可见副作用 *A* 存储的值。

如果对非原子对象的副作用存在歧义，则存在数据争用，并且行为未定义。这说明对普通变量的运算不会明显地重新排序。如果没有数据争用，这是无法检测到的，但可以确保数据争用以及对原子的使用有适当的限制，与简单交错（顺序一致）执行中的数据争用相对应。由求值 *B* 确定的原子对象 *M* 的值应为修改 *M* 的某个副作用 *A* 存储的值，其中 *B* 在 *A* 之前不会发生。

***写-写一致性*** (***write-write coherence***)：如果修改原子对象 *M* 的操作 *A* 发生在修改 *M* 的操作 *B* 之前，则 *A* 在 *M* 的修改顺序上应早于 *B*。

***读-读一致性*** (***read-read coherence***)：如果原子对象 *M* 的值计算 *A* 发生在 *M* 的值计算 *B* 之前，并且 *A* 从 *M* 上的副作用 *X* 中获取其值，则 *B* 计算的值应为 *X* 存储的值或副作用 *Y* 在 *M* 上存储的值，其中 *Y* 按照 *M* 的修改顺序跟随 *X*。

***读-写一致性*** (***read-write coherence***)：如果原子对象 *M* 的值计算 *A* 发生在对 *M* 的操作 *B* 之前，则 *A* 应从 *M* 上的副作用 *X* 中获取其值，其中 *X* 在 *M* 的修改顺序中先于 *B*。

***写-读一致性*** (***write-read coherence***)：如果原子对象 *M* 上的副作用 *X* 发生在 *M* 的值计算 *B* 之前，则求值 *B* 应从 *X* 或沿 *M* 的修改顺序跟随 *X* 的副作用 *Y* 中获取其值。

如果程序在不同的线程中包含两个冲突的操作，其中至少有一个不是原子的，并且都没有先于另一个发生，则程序的执行包含数据争用。任何此类数据争用都会导致未定义行为。

> 顺序与一致性


```c
typedef enum{
    memory_order_relaxed = __ATOMIC_RELAXED,
    memory_order_consume = __ATOMIC_CONSUME,
    memory_order_acquire = __ATOMIC_ACQUIRE,
    memory_order_release = __ATOMIC_RELEASE,
    memory_order_acq_rel = __ATOMIC_ACQ_REL,
    memory_order_seq_cst = __ATOMIC_SEQ_CST
} memory_order;
```
枚举类型 `memory_order` 指定上节定义的常规（非原子）内存同步操作，并提供可能的操作排序。它的枚举常量如下：
  - `memory_order_relaxed`	无需排序（宽松顺序）。
  - `memory_order_consume`	加载操作将充当内存位置上的消耗操作。
  - `memory_order_acquire`	加载操作将充当内存位置上的获取操作。
  - `memory_order_release`	存储操作将充当内存位置上的释放操作。
  - `memory_order_acq_rel`	将 `memory_order_acquire` 和 `memory_order_release` 结合。
  - `memory_order_seq_cst`	将 `memory_order_acquire` 和 `memory_order_release` 结合。标记为 `memory_order_seq_cst` 的内存访问必须顺序一致。

对于 `memory_order_relaxed`，无操作排序内存。

对于 `memory_order_release`、`memory_order_acq_rel` 和 `memory_order_seq_cst`，存储操作对受影响的内存位置执行释放操作。

对于 `memory_order_acquire`、`memory_order_acq_rel` 和 `memory_order_seq_cst`，加载操作对受影响的内存位置执行获取操作。

对于 `memory_order_consume`，加载操作对受影响的内存位置执行消耗操作。

所有 `memory_order_seq_cst` 操作上应该有一个单一的总排序 *S*，与所有受影响位置的 “*happens before*” 顺序和修改顺序一致，以便每个从原子对象 *M* 加载值的 `memory_order_seq_cst` 操作 *B* 都会观察到以下值之一：
- 在 *S* 排序中的操作 *B* 之前，观察到对 *M* 进行最后一次修改操作 *A* 的结果（如果存在），或者
- 如果 *A* 存在，则观察到对 *M* 进行某些修改的结果，该修改不是 `memory_order_seq_cst`，且在 *A* 之前不会发生，或者
- 如果 *A* 不存在，则观察到对 *M* 进行某些操作（非 `memory_order_seq_cst`）的结果。

虽然没有明确要求 *S* 包含锁定操作，但它始终可以扩展到包含锁定和解锁操作的顺序，因为这些操作之间的排序已经包含在 “*happens before*” 排序中。

指定 `memory_order_relaxed` 的原子运算仅在内存排序方面有所放宽。实现仍然保证对特定原子对象的任何给定原子访问相对于对该对象的所有其他原子访问是不可分割的。

对于读取原子对象 *M* 值的原子操作 *B*，如果存在一个 `memory_order_seq_cst` 屏障 *X* *sequenced before* *B*，则 *B* 要么观察到 *M* 在 *X* 之前以单一总排序 *S* 的最后一次 `memory_order_seq_cst` 的修改，要么观察到 *M* 自身的修改顺序的最近一次修改。

对于原子对象 *M* 上的原子运算 *A* 和 *B*，其中 *A* 修改 *M* 并且 *B* 取其值，如果有一个 `memory_order_seq_cst` 屏障 *X*，使得在单一总排序 *S* 上，*A* “*sequenced before*” *X* 且 *B* 紧随 *X* 之后，则 *B* 要么是观察到 *A* 副作用，要么观察到 *M* 自身的修改顺序的最近一次修改。

对于原子对象 *M* 的原子修改 *A* 和原子修改 *B*，如果满足以下条件，则在 *M* 的修改顺序中，*B* 发生在 *A* 之后：
- 存在一个 `memory_order_seq_cst` 屏障 *X*，使得在单一总排序 *S* 上，*A* “*sequenced before*” *X*，且 *X* 先于 *B*；或
- 存在一个 `memory_order_seq_cst` 屏障 *Y*，使得在单一总排序 *S* 上，*Y* “*sequenced before*” *B*，且 *A* 先于 *X*；或
- 存在 `memory_order_seq_cst` 屏障 *X* 和 *Y*，使得在单一总排序 *S* 上，*A* “*sequenced before*” *X*，*Y* “*sequenced before*” *B*，且 *X* 先于 *Y*。

原子 *读-修改-写操作* 应始终读取与 *读-修改-写操作* 关联的写入之前存储的最后一个值（按修改顺序）。

原子存储应仅存储通过有限程序求值序列，从常量和程序输入值中计算得出的值，以便每个求值都可以观察存储的有序列中最后一个先前赋值计算的对象值。按此序列进行求值的顺序如下：
- 如果求值 *B* 观察到 *A* 在不同线程中计算的值，则 *B* 不会在 *A* 之前发生。
- 如果序列中包含求值 *A*，则还包括分配给同一对象并在 *A* 之前发生的所有求值。

实现应使原子存储在合理的时间内对原子加载可见。

> Fences（屏障）

屏障可以有获取语义、释放语义、或两者都有。具有获取语义的屏障称为 *获取屏障*；具有释放语义的屏障称为 *释放屏障*。

对于释放屏障 *A* 与获取屏障 *B*，如果存在原子操作 *X* 和 *Y*，且两者都对某个原子对象 *M* 进行操作，并使得 *A* *sequenced before* *X*，*X* 修改 *M*，*Y* *sequenced before* *B* 且 *Y* 读取由 *X* 写入的值或由假定的释放序列 *X*（如果它是释放操作）中的任何副作用写入的值，则释放屏障 *A* 与获取屏障 *B* 同步。

对于释放屏障 *A* 与原子操作 *B*，原子操作 *B* 对原子对象 *M* 执行获取操作，如果存在原子操作 *X*，使得 *A* *sequenced before* *X*，*X* 修改 *M*，*B* 读取由 *X* 写入的值或由假定的释放序列 *X*（如果它是释放操作）中的任何副作用写入的值，则释放屏障 *A* 与原子操作 *B* 同步。

对于原子操作 *A* 和释放屏障 *B*，原子操作 *A* 在原子对象 *M* 上执行释放操作，如果在 *M* 上存在某俄歇原子操作 *X*，使得 *X* *sequenced before* *B*，并且 *X* 读取由 *A* 写入的值或由以 *A* 为首的释放序列中的任何副作用写入的值，则原子操作 *A* 与释放屏障 *B* 同步。

```c
void atomic_thread_fence(memory_order order);
```

根据 `order` 的值，该操作 `atomic_thread_fence(order)`：
- `memory_order_relaxed`，没有效果；
- `memory_order_acquire` 或 `memory_order_consume`，是一个获取屏障；
- `memory_order_release`，是一个释放屏障；
- `memory_order_acq_rel`，是兼具释放和获取语义的屏障；
- `memory_order_seq_cst`，是顺序一致的释放和获取语义的屏障。

```c
void atomic_signal_fence(memory_order order);
```

`atomic_signal_fence` 等效于 `atomic_thread_fence(order)`，不同之处在于生成的排序约束仅在线程和在同一线程中执行的信号处理程序之间建立。`atomic_signal_fence` 函数可用于指定线程执行的操作对信号处理程序可见的顺序。

---