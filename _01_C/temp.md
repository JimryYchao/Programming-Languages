#### 10.4. 格式化输入

*scanf-like* 函数参数 `format` 指定可接受的输入序列以及如何将它们转换为赋值，并使用后续对应参数作为指向对象的指针来接收转换后的输入。格式字符串由下列内容组成：
  - **非空白多字节字符**，除了 `%`：每个格式字符串中的这种字符处理来自输入流的准确同一字符，或若它与流的下个字符比较不相等则导致函数失败。
  - **空白符**：任何格式字符串中的单个空白符处理所有来自输入的可用连续空白符（符合 `isspace` 规定）。格式字符串中 `"\n"`、`" "`、`"\t\t"` 或其他空白无区别。
  - **转换规范**：转换规范由字符 `%` 表示，在 `%` 之后，依次出现以下内容：
    - 可选的赋值抑制字符 `*`；
    - 可选的大于零的十进制整数，指定最大字符宽度（如不提供宽度，`%s`、`%[` 可能会导致缓冲区溢出）；
    - 可选的长度修饰符，指定接收对象的类型大小；
    - 指定要应用的转换类型的转换说明符。

格式输入函数会依次执行该 `format` 格式的每个指令。当所有的指令都被执行完，或其中一个指令失败时函数返回。失败被描述为输入失败（编码错误或输入字符不可用）或匹配失败（不适当的输入）。空白字符不被读取，除非有指令匹配。

> 长度修饰符： 	

- `hh`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `signed char` 或 `unsigned char` 的指针参数。

+ `h`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `signed short` 或 `unsigned short` 的指针参数。

- `l`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 适用于指向 `long int` 或 `unsigned long` 的指针参数；指定 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 适用于指向 `double` 的指针参数；指定的 `c`、`s` 或 `[` 转换说明符应用于指向 `wchar_t` 的指针参数。

+ `ll`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `long long` 或 `unsigned long long` 的指针参数。

- `j`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `intmax_t` 或 `uintmax_t` 的指针参数。

+ `z`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `size_t` 或相应的有符号整数类型的指针参数。

- `t`：指定 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 应用于指向 `ptrdiff_t` 或相应的无符号整数类型的指针参数。

+ `w`*N*：指定的 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 转换说明符应用于指向具有特定宽度的整数的指针参数，其中 *N* 是不带前导零的十进制正整数。

- `wf`*N*：指定的 `b`、`d`、`i`、`o`、`u`、`x`、`X` 或 `n` 转换说明符应用于指向具有特定宽度的最快最小宽度整数的指针参数，其中 *N* 是不带前导零的十进制正整数。

+ `L`：指定的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 应用于指向 `long double` 的指针参数。

- `H`：指定的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 应用于指向 `_Decimal32` 的指针参数。

+ `D`：指定的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 应用于指向 `_Decimal64` 的指针参数。

- `DD`：指定的 `a`、`A`、`e`、`E`、`f`、`F`、`g` 或 `G` 应用于指向 `_Decimal128` 的指针参数。

> 转换说明符：

- `d`：匹配一个可选的有符号十进制整数，对应的实参是一个指向 `int` 的指针，除非指定了长度修饰符。

+ `b`：匹配一个可选的有符号二进制整数，对应的实参是一个指向 `unsigned int` 的指针，除非指定了长度修饰符。

- `i`：匹配一个可选的有符号整数，对应的实参是一个指向 `int` 的指针，除非指定了长度修饰符。

+ `o`：匹配一个可选的有符号八进制整数，对应的实参是一个指向 `unsigned int` 的指针，除非指定了长度修饰符。

- `u`：匹配一个可选的有符号十进制整数，对应的实参是一个指向 `unsigned int` 的指针，除非指定了长度修饰符。

+ `x`：匹配一个可选的有符号十六进制整数，对应的实参是一个指向 `unsigned int` 的指针，除非指定了长度修饰符。

- `a`、`e`、`f`、`g`：匹配可选的有符号浮点数、infinity、NaN。对应的实参是一个指向 `float` 的指针，除非指定了长度修饰符。

+ `c`：匹配正好指定字段宽度的字符序列（未指定字段宽度则为 1）。
  + 若没有长度修饰符，对应的参数是一个足够容纳字符序列的指向 `char`、`signed char`、`unsigned char` 或 `void` 的指针。不会添加空终止符。
  + 若存在 `l` 修饰，则输入应该是一个从初始移位状态开始的多字节字符序列，每个多字节字符被转换为宽字符，对应的实参应该是指向 `wchar_t` 数组初始元素的指针。不会添加宽空终止符。

- `s`：匹配非空白字符序列。
  - 若没有长度修饰，对应的参数是一个足够大的指向 `char`、`signed char`、`unsigned char` 或 `void` 的指针，该数组可以容纳字符序列和一个空终止符（null 字符被自动添加）。
  - 若存在 `l` 则输入应该是一个从初始移位状态开始的多字节字符序列，每个多字节被转换为宽字符，对应的实参应该是指向 `wchar_t` 数组初始元素的指针，宽空终止符会被自动添加。

+ `[`：匹配一组预期字符（扫描集）的非空字符序列。
  + 若没有长度修饰，对应的参数是一个足够大的指向 `char`、`signed char`、`unsigned char` 或 `void` 的指针，该数组可以容纳字符序列和一个空终止符（null 字符被自动添加）。
  + 若存在 `l` 则输入应该是一个从初始移位状态开始的多字节字符序列，每个多字节被转换为宽字符。对应的实参应该是指向 `wchar_t` 数组初始元素的指针，宽空终止符会被自动添加。
  + 若集合的首字符是 `^`，则匹配所有不在集合中的字符。若集合以 `]` 或 `]^` 开始，则 `]` 字符包含在集合中。`-` 可以指示范围（如 `[0-9]`）。

- `p`：匹配定义一个指针的实现定义的字符序列。该序列集应与 `fprinf` 的 `%p` 转换可能产生的序列集相同。对应的实参是指向指向 `void` 的指针的指针（`void **`）。如果输入项是在同一程序执行期间较早转换的值，则结果指针应与该值相等；否则 `%p` 转换的行为未定义。

+ `n`：返回已读取的字符数，且不消耗任何输入。相应的参数应是有符号整数类型的指针。执行 `%n` 指令不会增加 `scanf` 系列函数执行完成时返回的赋值计数。如果转换规范包括禁止赋值的字符或字段宽度，则行为未定义。

- `%%`：匹配单个字符 `'%'`。

+ 转换说明符 `A`、`E`、`F`、`G` 和 `X` 也是有效的，其行为分别与 `a`、`e`、`f`、`g` 和 `x` 相同。

> *格式转换案例*

```c
#define _CRT_SECURE_NO_WARNINGS 1 // 0
#include <stdio.h>
#include <stddef.h>
#include <locale.h>

int main(void)
{
	int i, j;
	float x, y;
	char str1[10], str2[4];
	wchar_t warr[2];
	setlocale(LC_ALL, "en_US.utf8");

	char input[] = "25 54.32E-1 Thompson 56789 0123 56ß水";
	/* 按下列分析：
	   %d ：整数
	   %f ：浮点值
	   %9s ：最多有 9 个非空白符的字符串
	   %2d ： 2 位的整数（数位 5 和 6 ）
	   %f ：浮点值（数位 7 、 8 、 9）
	   %*d ：不存储于任何位置的整数
	   ' ' ：所有连续空白符
	   %3[0-9] ：至多有 3 个十进制数字的字符串（数位 5 和 6 ）
	   %2lc ：二个宽字符，使用多字节到宽转换  */
	int ret = sscanf(input, "%d%f%9s%2d%f%*d %3[0-9]%2lc",
		&i, &x, str1, &j, &y, str2, warr);

	printf("Converted %d fields:\ni = %d\nx = %f\nstr1 = %s\n"
		"j = %d\ny = %f\nstr2 = %s\n"
		"warr[0] = U+%x warr[1] = U+%x\n",
		ret, i, x, str1, j, y, str2, warr[0], warr[1]);

	int n = sscanf_s(input, "%d%f%s", &i, &x, str1, (unsigned)sizeof(str1));
	// 写 25 到 i ， 5.432 到 x ， 9 个字节 "thompson\0" 到 str1 ，和 3 到 n 。
}
```