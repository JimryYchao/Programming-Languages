## C# 规范摘要 

### 1. 基本概念

#### 1.1. 程序结构

C# 中的组织结构中包括程序、命名空间、类型、成员和程序集（`*.exe` 或 `*.dll`）。程序集包含中间语言（IL）指令的可执行代码和元数据符号信息。加载程序集时，CLR 公共语言运行时的 JIT 即时编译器将 IL 代码编译为本机代码。


```csharp
using System;
namespace MyNamespace{
    interface IMyInterface;
    delegate void MyDelegate();
    enum MyEnum;
    struct MyStruct;   // MyNamespace.MyStruct
    namespace NestedNamespace{
        struct MyStruct;  // MyNamespace.NestedNamespace.MyStruct
    }
    class MyClass{
        class MyInnnerClass;
        static void Main(string[] args){ // EnterPoint 
            //Your program starts here...
            Console.WriteLine("Hello world!");
        }
    }
}
```

> 入口函数 **Main**

`Main` 可选包含 `string[] args`。程序名称不被视为 `args` 数组的首元，但它是 `Environment.GetCommandLineArgs()` 首元。

```csharp
class Program
{
    static void Main(string[] args)
    {
        if (args.Length > 0)
            Console.WriteLine("args[0] = " + args[0]);
        var env_args = Environment.GetCommandLineArgs();
        Console.WriteLine("env_args[0] = " + env_args[0]);   // maybe  Program.dll
    }
}
```

有效的 `Main` 函数签名：

```csharp
public static void Main();
public static int Main();
public static void Main(string[] args);
public static int Main(string[] args);
// 异步 Main
public static async Task Main();
public static async Task<int> Main();
public static async Task Main(string[] args);
public static async Task<int> Main(string[] args);
```

> **顶级语句**

编译器为顶级语句自动生成 `Main`。

```csharp
global using System;
Console.WriteLine("Hello World! {0}", Environment.GetCommandLineArgs()[0]);
```

顶级语句中可以使用 `await` 和 `return`，编译器为其生成正确的 `Main`。

```csharp
static void $<Main>(string[] args){}                // 非异步无返回
static int $<Main>(string[] args){}                 // 包含 return
static async Task $<Main>(string[] args){}          // 包含 await
static async Task<int> $<Main>(string[] args){}     // 包含 await 和 return
```

>---
#### 1.3. 词汇元素

> **标准关键字**

| token                                                                                                                                                                                                                    | description        |
| :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------- |
| `void`,`bool`,`char`,`string`,`object`,`dynamic`<br>`sbyte`,`short`,`int`,`long`,`byte`,`ushort`,`uint`,`ulong`<br>`nint`,`nuint`,`float`,`double`,`decimal`,<br>`enum`,`struct`,`class`,`record`,`interface`,`delegate` | 类型声明           |
| `null`,`true`,`false`                                                                                                                                                                                                    | 文本值             |
| `namespace`,`using`,`global`,`using static`,`extern alias`                                                                                                                                                               | 命名空间           |
| `where`,`new`,`default`,`notnull`,`unmanaged`,`allows ref struct`                                                                                                                                                        | 泛型约束           |
| `private`,`protected`,`public`,`internal`,`file`                                                                                                                                                                         | 访问性限制         |
| `abstract`,`override`,`virtual`,`sealed`,`event`,`record`,`async`,`require`<br>`const`,`volatile`,`readonly`,`event`,`extern`,`unsafe`,<br>`in`(逆变),`new`(成员),`out`(协变),`scoped`(作用域)                           | 声明修饰符         |
| `ref`,`out`,`ref readonly`,`in`,`params`                                                                                                                                                                                 | 参数修饰符         |
| `base`,`this`                                                                                                                                                                                                            | 访问关键字         |
| `add`,`remove`,`get`,`set`,`value`,`field`,`init`                                                                                                                                                                        | 访问器             |
| `operator`,`explicit`,`implicit`                                                                                                                                                                                         | 用户定义运算和转换 |
| `new`,`stackalloc`,`default`,`sizeof`,`typeof`,`nameof`,<br>`is`,`as`,`await`,`with`                                                                                                                                     | 表达式             |
| `var`,`is`,`switch`,`and`,`or`,`not`                                                                                                                                                                                     | 模式匹配与类型推断 |
| `while`,`do`,`for`,`foreach`                                                                                                                                                                                             | 迭代语句           |
| `if`,`else`,`switch`,`case`,`default`,`when`                                                                                                                                                                             | 条件语句           |
| `goto`,`continue`,`break`,`return`                                                                                                                                                                                       | 跳转语句           |
| `throw`,`try`,`catch`,`finally`,`when`                                                                                                                                                                                   | 异常处理           |
| `checked`,`unchecked`                                                                                                                                                                                                    | 溢出检查           |
| `using`,`lock`,`fixed`,`yield`                                                                                                                                                                                           | 其他语句           |
| `extension`                                                                                                                                                                                                              | 成员拓展           |
| `from`,`where`,`select`,`group`,`into`,`orderby`,`join`,<br>`let`,`in`,`on`,`equals`,`by`,`ascending`,`descending`                                                                                                       | 查询关键字         |

> **操作符**

```csharp
{    }    [    ]    (    )    .    ->   ,    :    ;  
+    -    *    /    %    &    |    ^    !    ~    =   
+=   -=   *=   /=   %=   &=   |=   ^=   ~=   ?    ??     
<    <=   >    >=   !=   ==   ++   --   &&   ||   ??=
..   ?.   ?[]  >>   <<   >>=  <<=  >>>  >>>= 
```

>---
#### 1.4. 类型定义

C# 是强类型语言，包含值类型（*stack*）和引用类型（*heap*）。值类型包括简单类型、枚举、结构、元组和可空值类型等；引用类型包括类、接口、数组和委托类型等。托管（*managed*）对象在托管堆上分配内存，变量只保留对象引用。CLR 自动执行内存管理和垃圾回收。

> NET 内置类型

| 内置类型  | 描述                 | 相应的 NET 类型  |
| :-------- | :------------------- | :--------------- |
| `bool`    | 布尔类型             | `System.Boolean` |
| `char`    | UTF-16 码位          | `System.Char`    |
| `byte`    | 8 位无符号整数       | `System.Byte`    |
| `short`   | 16 位有符号整数      | `System.Int16`   |
| `int`     | 32 位有符号整数      | `System.Int32`   |
| `long`    | 64 位有符号整数      | `System.Int64`   |
| `sbyte`   | 8 位有符号整数       | `System.SByte`   |
| `ushort`  | 16 位无符号整数      | `System.UInt16`  |
| `uint`    | 32 位无符号整数      | `System.UInt32`  |
| `ulong`   | 64 位无符号整数      | `System.UInt64`  |
| `nint`    | 本机大小的有符号整数 | `System.IntPtr`  |
| `nuint`   | 本机大小的无符号整数 | `System.UIntPtr` |
| `float`   | 32 位单精度浮点类型  | `System.Single`  |
| `double`  | 64 位双精度浮点类型  | `System.Double`  |
| `decimal` | 十进制浮点类型       | `System.Decimal` |
| `object`  | 类型系统基类         | `System.Object`  |
| `string`  | 字符串类型           | `System.String`  |
| `T[]`     | 数组类型             | `System.Array`   |

> 用户定义类型

用户定义类型：`class`,`struct`,`interface`,`enum`,`delegate`,`record struct`,`record class`。

```csharp
class MyClass;
struct MyStruct;
interface IMyInterface;
enum MyEnum;
delegate void MyDelegate();
record MyRecordClass;
record struct MyRecordStruct;
```

用户定义类型可以具有成员，成员可以是静态或实例成员：

| Type        | Members                                                                    |
| :---------- | :------------------------------------------------------------------------- |
| `interface` | 静态字段、常量、方法、属性、索引器、事件、静态构造函数、运算符、嵌套类型   |
| `class`     | 字段、常量、方法、属性、索引器、事件、构造函数、运算符、析构函数、嵌套类型 |
| `struct`    | 字段、常量、方法、属性、索引器、事件、构造函数、运算符、嵌套类型           |
| `record`    | 记录可以是 `record class` 或 `record struct`                               |
| `delegate`  | 引用一组方法的数据结构，派生自 `System.Delegate`                           |
| `enum`      | 一组具有基础整型命名常量的值类型                                           |
| 嵌套类型    | 任意的用户定义类型                                                         |

> 非托管类型

非托管类型（`unmanaged` 约束）：`sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`nint`、`nuint`、`char`、`float`、`double`、`decimal`、`bool`、枚举类型、指针类型、非托管结构类型。

```csharp
// T 为非指针、不可空的非托管类型
public struct S<T> where T : unmanaged;  
```

> 通用类型系统

NET 类型系统支持继承。所有类型（除了指针和 `ref struct`）的最终基类都是 `object`，这样的统一类型层次结构称为通用类型系统（CTS）。*装箱和拆箱* 提供值类型和引用类型之间互相转换的桥梁。

装箱是值类型到引用类型的隐式转换，拆箱是从引用类型提取值到值类型的显式转换。可以利用 `is` 测试装箱类型。

```csharp
string str = "Hello World";
object obj = str;     // implicit
string s_str = (string)str;  

int num = 10010;
obj = num;      // implicit boxing
if(obj is int)
    int i = (int)box  // unboxing
```

>---
#### 1.5. 访问性限制

命名空间全局可见，类型和类型成员可具有访问性限制，基类成员的访问性从派生继承。`new` 修饰成员隐藏同名继承成员。

```csharp
class Base {
    public int Value;
}
class Derived : Base {
    public new double Value { get; set; }   // 隐藏 base.Value
}
```

可访问性设置：

  - `private`：私有，仅限于包含类型。
  - `protected`：受保护，限于包含类型、派生类型。
  - `public`：公共，访问不受限制。
  - `internal`：仅限于当前程序集。
  - `private protected`：仅限于包含类型、当前程序集的派生类型。
  - `protected internal`：仅限于当前程序集、包容类型、派生类型。
  - `file`：当前编译单元可见，仅修饰顶级类型。

成员可访问性由自身和包含类型的可访问性结合确定：
| 成员所属    | 默认访问性 | 可声明访问性                                                                            |
| :---------- | :--------- | :-------------------------------------------------------------------------------------- |
| 顶级类型    | `internal` | `internal`、`public`                                                                    |
| `interface` | `public`   | `public`、`internal`、`protected`、`protected internal`、`private`、`private protected` |
| `class`     | `private`  | `public`、`internal`、`protected`、`protected internal`、`private`、`private protected` |
| `struct`    | `private`  | `public`、`internal`、`private`                                                         |
| `enum`      | `public`   | 无法添加访问限定符                                                                      |


>---
#### 变量

变量类别：静态变量、实例变量、数组元素、值参数、输入参数、引用参数、输出参数和局部变量。`default` 表达式用于零初始化。`ref` 创建变量引用。支持弃元 `_`。

`bool`、`char`、`byte`、`sbyte`、`short`、`ushort`、`int`、`uint` 及其对应枚举、`float`、`nint`、`unint` 和引用类型的读取和写入是原子的；`long`、`ulong`、`double`、`decimal` 和用户定义类型的读写不能保证为原子性。

```csharp
class Sample
{
    static int x;  // 静态变量 
    private int y; // 实例变量
    void Fun(
        int[] v,   // v[0] 数组元素
        int a,     // 值参数
        in int b,  // 输入参数
        ref int c, // 引用参数
        out int d) // 输出参数
    {
        int i = 10;  // 局部变量
        scoped ref 
        d = a + c++ + b;
    }
}
```


---
### 2. 命名空间

命名空间 `namespace` 对程序元素进行逻辑分组。每个程序元素在其名称空间单一定义。`global::` 表示全局命名空间。

```csharp
class A;                 // A; global::A
namespace X {            // X; global::X
    class B {            // X.B; global::X.B
        class C;         // X.B.C
    }
}
namespace X.Y {          // X.Y
    class D<S, T> {      // X.Y.D<,>
        class E;         // X.Y.D<,>.E
        class E<U>;      // X.Y.D<,>.E<>
    }
}
```

>---
#### 2.1. using

`using` 指令引入命名空间；`using static` 静态导入类型成员；`using Id = T` 创建别名；`global using` 表示全局指令。

```csharp
global using System;                      // 全局引入
global using Generic = System.Collections.Generic;    // 命名空间别名
using static System.Math;                 // 静态导入
using Vector = (double x, double y);      // 元组别名，全局
using unsafe Pfunc = delegate*<(double x, double y), double>;   // 函数指针别名

static double Magnitude(Vector v) => Sqrt(v.x * v.x + v.y * v.y); 
unsafe
{
    // 委托调用
    Func<Vector, double> f = Magnitude;
    f(new Vector(3, 4));  // 5
    // 指针调用
    Pfunc pf = &Magnitude;
    pf(new Vector(3, 4));     // 5
}
```

>---
#### 2.2. extern alias

`extern alias` 外部引用程序集别名，以区别多个程序集中具有相同完全限定名称的类型。在项目设置中导入 `grid.dll` 和 `grid20.dll` 的引用并创建别名为 “GridV1” 和 “GridV2”：

```csharp
extern alias GridV1;  
extern alias GridV2;
// using 别名创建
using Sample_V1 = GridV1::Namespace.Sample;
using Sample_V2 = GridV2::Namespace.Sample;
```

---
### 内置类型
#### 简单值类型

| Type                           | Description             |
| :----------------------------- | :---------------------- |
| `bool`                         | 布尔，`true` 和 `false` |
| `char`                         | 字符，Unicode-16 码位   |
| `sbyte`,`short`,`int`,`long`   | 有符号整数              |
| `byte`,`ushort`,`uint`,`ulong` | 无符号整数              |
| `nint`,`nuint`                 | 本机大小整数            |
| `float`,`double`               | 标准浮点数              |
| `decimal`                      | 十进制浮点数            |
| `enum <id>: <int>`             | 枚举                    |
| `(T1,T2,...Tn)`                | 元组                    |

> **字符字面值**

```csharp
// 字面值
char c = 'H';     // UTF16
char c_x = '\x65';         // \x 十六进制转义
char c_u = '\u00ff';       // \u hhhh 十六进制转义
char c_U = '\U000000FF';   // \U HHHHHHHH 十六进制转义
// 转义字符
'\'','\"','\\','\0','\a','\b','\f','\n','\r','\t','\v'
'\e'    // ESC  
```

> **整数字面值**

```csharp
// 后缀
0u,0U    		// 无符号整数
0l,0L    		// long
// 其他进制表示
0b1010,0B0101          // 二进制
0x123abc,0X987DEF      // 十六进制 
// 分隔符
1_2__3___4____5_____6______7_______8________9;   // 支持任意数目的数字分隔符
```

> **浮点字面值**

```csharp
3.14f,2.71F           // float
0.1,3.14d,2.71D  	  // double
3.14m,2.71M           // decimal
1.2345E15,9.8e2;      // E计数法
```

`decimal` 表示 128 位十进制数，可以精确表示 0.1，与标准浮点类型仅支持强制转换，过大过小运算会引发溢出异常，标准浮点运算不会产生异常。

```csharp
float f = 3.1415f;
decimal df = (decimal)f;    // 强制转换
```

>---
#### 4.2. 枚举类型

枚举为 `int`，与其基础类型之间存在显式转换。其他整数类型可以是 `byte`、`sbyte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`。

```csharp
public enum Season : byte
{
    Unknown = 0,
    Spring = 1, Summer, Autumn, Winter
}
public static class EnumExt
{
    public static T ToEnum<T>(this int eVal) where T : Enum => (T)Enum.ToObject(typeof(T), eVal);
    public static bool IsEnum_t<T>(this int eVal) where T : Enum => Enum.IsDefined(typeof(T), eVal);
    static void Main()
    {
        var e = 1.ToEnum<Season>();   // Summer
        bool ok = (-1).IsEnum_t<Season>();  // False
        Season s = (Season)1;     // 强制转换
    }
}
```

>---
#### 4.3. 元组类型

元组定义为 `(T1 t1, ... , Tn tn)`，n ≥ 2，元素名 `t1, t2, ..., tn` 或 <code>Item<em> N</em></code>（默认）。

```csharp
using Point = (int x, int y);

Point p1 = (1, 2);      // 元组表达式
Point p2 = new (1, 2);
Point p3 = ValueTuple.Create(1, 2);
Point p4 = new ValueTuple<int, int>(1, 2);  

Console.WriteLine(p1.Item1);  // 默认，等价于 p.x
Console.WriteLine(p1.y);     
```

元组可用于模拟多值返回，支持弃元 `_`。

```csharp
static (int, int, int) GetRandomPoint() {
    Random rand = new Random(DateTime.Now.Millisecond);
    return (rand.Next(-128, 128), rand.Next(-128, 128), rand.Next(-128, 128));
}

var (X, Y, _) = GetRandomPoint();   // 析构元组
Console.WriteLine("The Point2D = ({0},{1})", X, Y);
```

> **元组解构**

在 `struct`、`class`、`record`、`interface` 中声明解构函数 `Deconstruct` 或扩展方法，拥有至少两个 `out` 参数，可重载。主构造函数记录默认生成一个 `Deconstruct` 方法。

```csharp
// 解构位置记录
record Person(string firstName, string lastName);  // Deconstruct 隐式生成
var (fname, lname) = new Person("Hello", "World");

// 为 class 定义解构函数
class Person(string FirstName, string LastName) {
    public void Deconstruct(out string firstName, out string lastName)
        => (firstName, lastName) = (FirstName, LastName);
}
var (fname, lname) = new Person("Hello", "World"); // 元组解构
```

遍历 `Dictionary` 时，每个元素都是 `KeyValuePair<TKey,TValue>`，内置解构函数。

```csharp
Dictionary<string, int> snapshotCommitMap = new(StringComparer.OrdinalIgnoreCase)
{
    ["https://github.com/dotnet/docs"] = 16_465,
    ["https://github.com/dotnet/runtime"] = 114_223,
    ["https://github.com/dotnet/installer"] = 22_436,
    ["https://github.com/dotnet/roslyn"] = 79_484,
    ["https://github.com/dotnet/aspnetcore"] = 48_386
};
foreach (var (repo, commitCount) in snapshotCommitMap)
    Console.WriteLine($"The {repo} repository had {commitCount:N0} commits as of November 10th, 2021.");
```

>---
#### 字符串类型

`string` 表示一串不可变 Unicode 码位序列（UTF16）。

```csharp
string str = "Hello " + "World!";    // 拼接
for (int i = 0; i < str.Length; i++)
  Console.Write(str[i] + " ");
```

> **内插字符串**

`$` 内插字符串中的内插表达式（`{expr}`）替换为表达式结果的字符串形式。`{{` 和 `}}` 表示为 `"{"` 和 `"}"`。

```csharp
$"{<interpolationExpression>[,<alignment>][:<formatString>]}"
// - interpolationExpression     生成需要设置格式的结果的表达式
// - alignment                   常数，定义对齐和宽度，- 表示左对齐
// - formatString                受表达式结果类型支持的格式字符串

$"|{"Left",-7}|{"Right",7}|";  // |Left   |  Right|
$"{{{Math.PI,20}}}";           // {   3.141592653589793}
$"{{{Math.PI,20:F3}}}";        // {               3.142}
string message = $"The usage policy for {safetyScore} is {
    safetyScore switch
    {
        > 90 => "Unlimited usage",
        > 80 => "General usage, with daily safety check",
        > 70 => "Issues must be addressed within 1 week",
        > 50 => "Issues must be addressed within 1 day",
        _ => "Issues must be addressed before continued use",
    }}";
```

> **逐字字符串**

`@` 逐字字符串按原义表示，`""` 表示 `"`。

```csharp
@"c:\documents\files\u0066.txt";  
"c:\\documents\\files\\u0066.txt";
// c:\documents\files\u0066.txt

$@"{{{Math.PI,20}}} is ""default formatting of the pi number""";
// {   3.141592653589793} is "default formatting of the pi number"
```

> **原始字符串**

原始字符串首尾由 `"""` (至少三个) 作为引导序列。多行字符串的引导序列单独一行，尾引导序列的左侧决定了整体字符串的行缩进位置。

```csharp
var line = """This is a single line""";
var multi = """
    This is a multi-line
        string literal with the second line indented.
""";
Console.WriteLine(multi);
/* 
    This is a multi-line
        string literal with the second line indented.
|<--- 行缩进位置
*/
```

原始字符串支持内插，表达式 `{}` 数目由 `$` 数目决定。

```csharp
string value = "text";
var str =
    $$"""
    {
        "Summary": {{value}},
        "length": {{value.Length}}
    }
    """;
/* OUTPUT
{
    "Summary": text,
    "length": 4
}
*/
```

> **UTF8 字符串**

UTF8 字符串以 `u8` 作为后缀，存储为 `ReadOnlySpan<byte>` 对象，不支持内插。

```csharp
// u8 to u16
ReadOnlySpan<byte> strU8 = @"Hello world!"u8;
string strU16 = Encoding.UTF8.GetString(strU8);
// u16 to u8
string str = "Hello world!";
ReadOnlySpan<byte> bytes = Encoding.UTF8.GetBytes(str);
// u8 + u8
ReadOnlySpan<byte> s = "Hello"u8 + " World"u8;
```

>---
#### 数组类型

数组是单一类型元素的编号序列。多维数组的每个维度都有一个相关联的长度。

```csharp
// 几种声明数组的形式
int[] arr1 = new int[10];        // 零初始化
int[] arr2 = { 0, 1, 2, 3 };     // 初始化器
int[] arr3 = new int[] { 1, 2, 3 };
int[] arr4 = new int[3] { 1, 2, 3 };
int[] arr5 = new[] { 1, 2, 3 };
int[] arr6 = [10, 20, 30];       // 集合表达式
// 多维数组的声明
int[] a1 = new int[10];          // 一维数组
int[,] a2 = new int[10, 5];      // 二维数组
int[,,] a3 = new int[10, 5, 2];  // 三维数组
// 匿名类型的数组
var arr = new[] {
    new{ name = "Hello", Id = 1 },
    new{ name = "World", Id = 2 },
    new{ name = "Empty", Id = 3 },
};
```

> **交错数组**

交错数组的元素类型可以是数组类型。

```csharp
int[][] pascals = 
{
    new int[] {1},
    new int[] {1, 1},
    new int[] {1, 2, 1},
    new int[] {1, 3, 3, 1}
};
```

> **数组和泛型集合接口**

单维数组 `T[]` 实现了 `IList<T>` 和 `IReadOnlyList<T>` 接口。若 `S` 到 `T` 存在引用隐式转换，则 `S[]` 也可以隐式转换（协变）为 `IList<T>` 或 `IReadOnlyList<T>`。

```csharp
string[] hi = { "H", "e", "l", "l", "o" };
IList<object> o = hi;   // 协变 string -> object
```

---
### 7. 结构类型

结构可以实现接口，不支持继承。默认生成一个公共无参实例构造函数；数据成员具有初始值时，需要提供一个实例构造函数。

```csharp
public struct Coords(double x, double y)   // 主构造函数
{
    public double X => x;
    public double Y => y;
    // 重写 System.ValueType.ToString
    public override string ToString() => $"({X}, {Y})";   
} 
```

>---
#### 7.1. readonly struct

`readonly` 只读结构表明对象值不可变，数据成员只读限定。

```csharp
readonly struct Sample(string first, string last)
{
    public readonly string FirstName = first;
    public readonly string LastName = last;
    public readonly string Name => FirstName + " " + LastName;
}
```

>---
#### 7.2. ref struct

`ref struct` 在执行堆栈（*stack*）上分配，有以下限制：
  - 可以实现接口，或作为泛型的类型参数（`allows ref struct`）。
  - 不能是类或非 `ref struct` 成员类型，不能是数组或元组元素。
  - 在异步方法和迭代器中，访问局部变量的 *ref-like* 不能跨 `await` 边界。

`ref` 字段只在 `ref struct`，默认为 `null`。`ref` 字段不能引用 `ref struct`。`readonly` 限定 `ref` 字段：
- `readonly ref` 引用只读。
- `ref readonly` 引用对象值只读。
- `readonly ref readonly` 引用和值只读。

```csharp
ref struct RS(ref int rv)
{
    private ref int Value = ref rv;
    public ref int GetValue()
    {
        if (System.Runtime.CompilerServices.Unsafe.IsNullRef(ref Value))   // 检查空引用
            throw new InvalidOperationException();
        return ref Value;
    }
}
```

>---
#### 7.3. 固定大小的缓冲区

在结构中，`fixed` 创建固定大小缓冲区，数组类型为 `bool`、`byte`、`char`、`short`、`int`、`long`、`sbyte`、`ushort`、`uint`、`ulong`、`float` 或 `double`。
  
```csharp
internal struct Buffer {
    public unsafe fixed int Data[10];    // sizeof(int) * 10
}
```

与固定缓冲区不同的是，`stackalloc` 数组在 CLR 中自动启用缓冲区溢出检测功能。

```csharp
unsafe {
    int* pSafe = stackalloc int[10];
    for (int i = 0; i < 100; i++)
        *(pSafe + i) = i;             // 缓冲区溢出检查

    Buffer buf = default;
    for (int i = 0; i < 100; i++)
        *(buf.Data + i) = i;          // 不执行溢出检查，存在堆栈溢出风险
}
```

>---
#### 7.4. 内联数组

内联数组（`InlineArrayAttribute`）是 *N* 个具有唯一字段（非指针）的非记录结构组成的连续块，支持范围和索引运算。

```csharp
[System.Runtime.CompilerServices.InlineArray(10)]    // 内联数组
public struct Buffer<T> {
    private T Elem;
}
// 类似于固定缓冲区
public struct _Buffer{
    public unsafe fixed int buffer[10];  // 类似于 Buffer<int>
}

var buffer = new Buffer<int>();
for (int i = 0; i < 10; i++)
    buffer[i] = i;   // use like a array
```

---
### 8. 类类型

`class` 支持单一继承。NET 预定义类在 C# 中具有特殊含义：
- `System.Object`：最终基类。
- `System.String`：字符串类型。
- `System.ValueType`：值类型基类。
- `System.Enum`：枚举基类。
- `System.Array`：数组基类。
- `System.Delegate`：委托基类。
- `System.Exception`：异常基类。
- `System.Attribute`：特性基类。

```csharp
class MyClass {
    // 构造函数
    static MyClass() { }     // 静态构造函数
    public MyClass() { S_OnDestroy = static delegate { Console.WriteLine("MyClass Destroyed"); }; }
    // 数据类
    event OnDestroy S_OnDestroy;              // 事件
    public const string Version = "0.0.1";    // 常量
    private readonly static MyClass s_default = new MyClass();   // 字段，静态
    // 函数类
    public static MyClass Default => s_default;      // 属性
    public int this[int index] => index;             // 索引器
    public Data CreateData(byte[] data, int id) => new Data(data, id);   // 实例方法
    public static Data DefaultData() => new Data();  // 静态方法
    ~MyClass() => S_OnDestroy?.Invoke();             // 析构函数
    // 运算符
    public static bool operator ==(MyClass left, MyClass right) => left.Equals(right);
    public static bool operator !=(MyClass left, MyClass right) => !left.Equals(right);
    // 嵌套类型
    delegate void OnDestroy();               // 委托
    public enum Day { workDay, weekDay }     // 枚举
    public interface INested { }             // 接口
    sealed class NestedClass : INested { }   // 嵌入类
    struct NestedStruct : INested { }        // 嵌入结构
    public readonly record struct Data(byte[] data, int gui);   // 嵌入记录
}
class Sample {
    static void Main(string[] args) {
        MyClass.Data d1 = MyClass.Default.CreateData("Hello"u8.ToArray(), "Hello".GetHashCode());
    }
}
```

>---
#### 8.1. 抽象与封装

抽象类无法直接实例化，由派生提供实现；类可以声明 `abstract` 纯虚函数成员（抽象类）或 `virtual` 虚函数成员，由派生重写（`override`）；`sealed` 封装实体防止继承。

```csharp
abstract class BaseSample {
    public abstract void Debug(string mess);
    public abstract int Value { get; }
    public virtual void Error(string mess) => Debug(mess);
}
internal class Sample : BaseSample {
    // 抽象实现
    public override void Debug(string mess) => Console.WriteLine(mess);
    public override int Value { get; } = 10086;
    // 重写并密封
    public sealed override void Error(string mess) => base.Error("ERROR : " + mess);
}
```

>---
#### 8.2. 静态类

`static` 静态类无法实例化，仅包含静态成员；可以声明扩展方法或扩展成员：

```csharp
public static class EnumExt {
    // 扩展方法
    public static bool IsEnum_t<T>(this int eVal) where T : Enum
        => Enum.IsDefined(typeof(T), eVal);    // 检查 enum 是否关联整数值
    // 扩展成员
    extension (int i) {
        public T? ToEnum<T>() where T : Enum 
            => (T)Enum.ToObject(typeof(T), i);
    }
}
```

---
### 11. 委托类型

委托用于封装一组方法调用列表，委托的调用转换为依次调用绑定的方法组。在构造委托时，编译器会为委托生成：
- `Invoke` 方法，与委托签名相同，用于同步调用；
- `BeginInvoke` 和 `EndInvoke`（NET Framework），用于异步调用：
  - `BeginInvoke` 除具有 `Invoke` 相同位置的参数外，还有两个额外的参数（`System.AsyncCallback` 和 `System.Object`）。返回 `System.IAsyncResult`。
  - `EndInvoke` 返回类型和委托的返回类型相同。委托签名中包含输出参数 `out`，则在 `EndInvoke` 中包含这些 `out` 参数；它还有一个额外的和 `BeginInvoke` 方法的返回值类型相同的参数 `System.IAsyncResult`。

```csharp
// 委托的定义
delegate void SampleDelegate(int action);
// 编译器为委托类型生成
sealed class SampleDelegate : System.MulticastDelegate
{
    public SampleDelegate(object obj, nint method);
    public virtual void Invoke(int action);
    public virtual IAsyncResult BeginInvoke(int action, AsyncCallback callback, object obj);
    public virtual void EndInvoke(IAsyncResult asyncResult);
}
```

预定义的委托类型包含 `Action`、`Func`、`Predicate` 。委托通过 `+` / `+=` 组合其他委托或方法；`-` / `-=` 用于删除组件（优先匹配最后一个），无法删除匿名函数。

```csharp
void Print(string mess) => Console.WriteLine("Function : " + mess);

Action<string> MessagePrint = null;
MessagePrint += Print;  // add 方法
MessagePrint += delegate (string mess){  // add 匿名方法
    Console.WriteLine("Delegate : " + mess);
};
MessagePrint += message => Console.WriteLine("Lambda : " + message);   // add lambda 表达式

// 委托调用
MessagePrint?.Invoke("Hello World!"); // 等价：MessagePrint("Hello World!"); 
```

> **委托异步调用** (NET Framework)

在异步模式下，委托调用方继续执行而不等待委托返回。`BeginInvoke` 和 `EndInvoke` 执行委托异步调用。异步委托可以抛出异常，并通过 `EndInvoke` 传播到调用方。

```csharp
// 预定义
SampleDelegate dele = delegate (int x)
{
    Thread.Sleep(1000);
    Console.WriteLine(x);
};
delegate void SampleDelegate(int action);
```

通过两种方式来等待异步计算结果：
- 一是通过调用 `BeginInvoke` 返回的结果对象 `System.IAsyncResult`，通过 `EndInvoke` 检查结果值以获取方法调用的当前状态，并在完成计算时返回结果。

    ```csharp
    var rt = dele.BeginInvoke(10010, null, dele);
    dele.EndInvoke(rt);  // maybe have a return
    ```

- 二是通过传递给 `BeginInvoke` 的 `System.AsyncCallback` 作为异步回调。传递回调委托的值与 `BeginInvoke` 返回的值相同。

    ```csharp
    dele.BeginInvoke(10010, (rt) => dele.EndInvoke(rt), dele);
    ```

>---
#### 11.1. 匿名函数

匿名函数（`delegate` 表达式或 Lambda）可以转换为兼容委托或表达式树。支持 `static`、`async`、`scoped`、弃元（两个参数以上）。支持闭包。

```csharp
// delegate 匿名方法表达式
var f = async? delegate [( <parameters>? )] { <statements> };

var fun = static delegate (scoped ref int x) { return x + 1; };        
Func<int, int> fun2 = static delegate { return 1 + 1; };        // static
var fun3 = async delegate (int sec){ await Task.Delay(sec); };  // async

// Lambda 表达式
var f = async? <return_type>? ( input_parameters? ) => expression / { <statements> };

Func<int, int> Square = x => x * x;
var Sum = static int (ref int x, int y = 0) => x + y;  // 指定返回，默认参数
var Iterator = async (IAsyncEnumerable<int> arr) => {
    await foreach (var item in arr)
        use(item);
};
```

---
### 9. 类型成员

#### 9.1. 常量

```csharp
using Vector = (double x, double y);
class Sample {
    const double MATH_PI = 3.1415926535;
    static readonly Vector Origin = (0, 0);   // 只读静态，类似于常量
}
```

>---
#### 9.2. 字段

字段在调用对象或类型之前初始化。`volatile` 声明易变字段；`readonly` 只读字段在初始化器、构造函数或 `init` 中设定值；`required` 指定必填字段；`ref` 声明引用字段（`ref struct`）。

```csharp
class Sample
{
    readonly static int UID;        // 静态字段，只读
    public required string Name;    // 必填字段
    volatile int value;             // 易变字段
    ref struct RefSample {
        ref Sample RS;              // 引用字段
    }
}
```

`required` 字段在创建实例时执行初始化。`required` 类型不满足 `new()` 泛型约束。

```csharp
class Student
{
    public required string Name;   
    public required int Age;
}
Student p = new() { Name = "Tom", Age = 12 }; // 初始化设定项
```

>---
#### 9.3. 方法 

方法支持重载和继承，可以 `return ref/ref readonly`。`readonly` 方法在结构中声明，不修改 `this` 的状态。

```csharp
class Sample
{
    public int value;
    struct RefSample(Sample s)
    {
        public int GetValue() => s.value;                 // 副本返回
        public ref int GetRefValue() => ref s.value;      // 变量引用返回
        public ref readonly int GetRefReadonlyValue() => ref s.value;  // 只读变量引用返回
    }
        // readonly 方法
        public readonly int GetROValue() {
            //this.s_value = 100;  // err
            return s.value;
        }
}
```

> **方法参数**

参数可以是值传递或引用传递。引用参数不用于异步或迭代器方法。

```csharp
void FunA(int v, string s);          // 值传递
void FunB(in int v, ref int v2, ref readonly int v3, out int v4,);   // 引用传递
```

`params` 参数可以是数组或集合类型：`Span<T>`、`ReadOnlySpan<T>`、`IEnumerable<T>`、`IReadOnlyCollection<T>`、`IReadOnlyList<T>`、`ICollection<T>`、`IList<T>`。用户定义类型需要包含一个 `Add` 方法。

```csharp
class List<T>(params System.Collections.Generic.List<T> values) : IEnumerable<T>
{
    private System.Collections.Generic.List<T> datas = values;
    public IEnumerator<T> GetEnumerator() => datas.GetEnumerator();
    public void Add(T v) => datas.Add(v);
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}
class Sample
{
    static void PrintList<T>(params List<T> args)
    {
        if (args != null)
            Console.WriteLine(string.Join(',', args));
    }
    static void Main(string[] args)
    {
        PrintList(1, 2, 3, 4, 5);
    }
}
```

可选参数具有默认值，置于一般参数之后。`OptionalAttribute` 特性参数可选且无需默认值；`DefaultParameterValueAttribute` 为 `OptionalAttribute` 参数提供默认值。

```csharp
void FunA(int reqV, string? opStr = "", int opV = default) { }
void FunB(int reqV, [Optional] string? optStr, [Optional, DefaultParameterValue("DEFAULT_PARAM_VALUE")] string? defaultOptStr)
{
    Console.WriteLine($"optional str is null: {optStr == null}");
    // Output: optional str is null: True
    Console.WriteLine($"default optional str is : {defaultOptStr}");
    // Output: default optional str is : DEFAULT_PARAM_VALUE
}
```

位置参数按顺序传递；命名参数任意顺序传递，位于位置实参之后。

```csharp
void Fun(string s1, int i, string s2) { }

// 位置参数
Fun("Hello", 10086, "World");
// 命名参数
Fun(i: 10086, s1: "Hello", s2: "World");
Fun(s1: "Hello", s2: "World", i: 10086);
Fun(s2: "World", s1: "Hello", i: 10086);   
```

引用传递的 *ref-likes* 参数可以设置为 `scoped` 或 `[UnscopedRef]`，以限制引用参数的作用域范围为 *current method*、*calling method* 或 *return only*。例如 `scoped ref value` 参数无法通过 `return ref` 返回给调用方，它的安全转义限定为 *current method*。 

```csharp
ref readonly int GetValue(ref int rv, scoped ref int srv) {
    // return ref srv;   // 作用域限定为当前方法
    return ref rv;
}
```

> **方法重载**

方法支持重载，编译器利用重载决策来匹配最优。对于方法签名，`object` / `dynamic` 和 `T[]` / `params T[]` 被视为是相同的。

```csharp
void Fun(int num);
void Fun(ref int num);
// void Fun(in int num);         // 与 ref 不构成重载
void Fun(int num, string str); 
void Fun(int[] arr);
// void Fun(params int[] arr);   // 与 int[] 不构成重载
```

`OverloadResolutionPriority` 指定重载决策的优先级，默认为 0。

```csharp
class Sample
{
    // 重载
    public static void Fun(string str) => Console.WriteLine("Fun(str) : " + str);
    [OverloadResolutionPriority(priority: 1)]  // 提高优先级
    public static void Fun(object obj) => Console.WriteLine($"Fun(obj) : " + obj);
}

Sample.Fun("Hi");  // Fun(obj) : Hi
```

> **方法继承**

```csharp
abstract class Base
{
    public abstract void FunA(string s);   // 纯虚方法
    public virtual void FunB(string s)     // 虚方法
        => Console.WriteLine("Base: " + s);
}
class Derived : Base
{
    // 抽象实现
    public override void FunA(string s) => base.FunB(s);
    // 密封重写
    public sealed override void FunB(string s)
        => Console.WriteLine("Derived: " + s);
}
```

> **外部方法**

`extern` 引用外部方法。例如导入 `Interop` 服务非托管代码。

```csharp
using System.Runtime.InteropServices;
class ExternTest
{
    [DllImport("User32.dll", CharSet = CharSet.Unicode)]
    public static extern int MessageBox(IntPtr h, string m, string c, int type);

    static int Main()
    {
        string? myString;
        do
        {
            Console.Write("Enter your message: ");
            myString = Console.ReadLine();
        } while (string.IsNullOrEmpty(myString));
        return MessageBox((IntPtr)0, myString, "My Message Box", 0);
    }
}
```

> **局部函数**

在函数范围内声明局部函数，无法重载。局部方法可以是 `async`、`unsafe`、`static`、`extern static`。`Conditional` 特性标记的局部方法只能是 `static`。

```csharp
static string GetText(string path, string filename)
{
    var reader = File.OpenText($"{appendPathSeparator(path)}{filename}");
    var text = reader.ReadToEnd();
    return text;
    // 局部函数
    static string appendPathSeparator(string filepath)   
        => filepath.EndsWith(@"\") ? filepath : filepath + @"\";
}
```

非静态的局部函数和匿名函数、Lambda 表达式中支持闭包。

```csharp
class Sample
{
    static Func<int> GetCounter(int delta)
    {
        int count = 0 - delta;
        int counter() => count += delta;
        return counter;
    }
    static void Main(string[] args)
    {
        var c = Sample.GetCounter(2);
        for (int i = 0; i < 10; i++)
            Console.Write(c.Invoke() + ",");   // 0,2,4,6,8,10,12,14,16,18
    }
}
```

> **扩展方法**

扩展方法在顶级静态类中声明；值类型 `this` 可以限定为 `in` / `ref`，`struct` 约束的 `this` 可以限定为 `ref`。

```csharp
public static class Ext
{
    // 返回变量的类型名称
    [return: MaybeNull]
    public static string TypeName<T>(this T type) => type?.GetType().Name;
    // 返回实参变量的标识符
    public static string Identifier<T>(this T parameter,
        [CallerArgumentExpression("parameter")] string parameterName = "unknown")
        => parameterName.ToString();
}

int number = 0;
Console.WriteLine(100.TypeName());        // Int32
Console.WriteLine(number.Identifier());   // number
```

> **异步方法**

TODO

<!-- - 异步方法的返回类型是 `Task`、`Task<R>`、`ValueTask`、`ValueTask<R>`，启动异步的 `async` 方法可以返回 `void`。

`await expr` 中 `expr` 具有一个 `A GetAwaiter()` 可访问的非泛型实例或扩展方法，并且返回类型 `A` 必须满足：
- `A` 实现接口 `System.Runtime.CompilerServices.INotifyCompletion`。
- `A` 有一个可访问、可读的 `bool` 类型的实例属性 `IsCompleted`。
- `A` 有一个可访问的无参非泛型实例方法 `GetResult`。 

`GetAwaiter` 为当前等待的异步任务获取一个 `Awaiter`。`IsCompleted` 确定任务是否完成。`INotifyCompletion.OnCompleted` 为 `Task` 任务注册一个 `continuation` “延续” 的委托类型，并在 `Task` 任务完成后调用。`GetResult` 在任务完成后获得异步操作结果。

> **await 求值顺序**

对于表达式 `await E`：
- 计算 `(E).GetAwaiter()` 获取一个 `Awaiter` 类型的等待器 `A`。
- 通过检查 `(A).IsCompleted` 获取当前任务完成状态的 `bool` 值 `b`。
- 如果 `b` 为 `false`，则求值取决于 `A` 是否实现 `System.Runtime.CompilerServices.ICriticalNotifyCompletion` 接口。定义 `r` 为 `resumption` 恢复委托：
  - 当 `a` 未实现 `ICriticalNotifyCompletion` 接口，则求值 `((a) as INotifyCompletion).OnCompleted(r)`。
  - 当 `a` 实现了 `ICriticalNotifyCompletion` 接口，则求值 `((a) as ICriticalNotifyCompletion).UnsafeOnCompleted(r)`。
  - 然后暂停执行，并将控制权返回给当前异步方法的调用者。
- 立即调用（若 `b` 为 `true`）或稍后调用（`b` 为 `false`）恢复委托，以调用 `(a).GetResult()` 求值，若返回一个值，则它就是 `await` 表达式的结果，否则没有返回值。

方法 `OnCompleted` 和 `UnsafeOnCompleted` 的实现应该使恢复委托 `r` 最多被调用一次。否则，封闭异步函数的行为是未定义的。 -->


>---
#### 9.4. 属性

属性可以具有访问器 `get`、`set` / `init`（仅实例，仅调用一次），支持继承，支持 `ref`、`readonly`、`required`。编译器为自动属性生成后台隐藏关联字段。

访问器可以具有比属性更强的访问限制。`value` 指代 `set` 赋值，`field` 指代默认关联字段。

```csharp
class Person
{
    public string? Name { get; init => field = value?.Trim() ?? ""; } = "";   // 初始值设定
    public int Age { get; set => field = value > 0 ? value : 0; } 
}
```

只读 `get` 属性可在构造函数中初始化；`init` 属性在初始化器、`with`、构造函数、或其他 `init` 中初始化。

```csharp
Person p = new() { Name = "   Hello", Age = 10 };  // 初始化器
```

> **`ref`**

`ref` 属性按引用返回，不支持自动实现。

```csharp
class Sample
{
    int _value;
    public ref int Value => ref _value;
}
```

> **`readonly`**

`readonly` 属性（仅结构）或 `readonly get` 无法修改 `this`。`init` 不受 `readonly` 限制。

```csharp
struct Sample
{
    public readonly int UID { 
        get; 
        private init => field = this.GetHashCode();
    }
    public int Counter { 
        readonly get => field; 
        set => field = (field = value) < 100 ? field : 0; 
    }
}
```

> **`required`**

`required` 属性在对象初始化时设定值。派生无法取消基类 `required` 限定，但可以添加 `required` 限定。

```csharp
class Base
{
    public virtual required string Name { get; init => field = "Base"; }
    public virtual int ID { get; set; }
}
class Derived : Base
{
    public override required string Name { get; init => field = "Derived"; }
    public override required int ID { get; set; }  // 额外附加 required 限定
}
```

>---
#### 9.5. 索引器

索引器可以像数组一样进行索引，支持重载和继承。后台生成关联 `Item` 属性，可由 `IndexerNameAttribute` 更改。支持 `ref` 或 `readonly` 限定，`ref` 索引器无 `set` / `init`。

```csharp
struct Sample<T>(T[] arr)
{
    [IndexerName("__Item")]
    public ref T this[int i] => ref arr[i];
    // readonly                     this 只读
    // ref readonly                 返回元素只读
    // readonly ref readonly        this 只读，返回元素只读

    [IndexerName("__Item")]  
    public string this[string s]   // 重载
    {
        get => throw new NotImplementedException();
        set => throw new NotImplementedException();
    }
}
```

> **索引和范围的隐式支持**

定义类型中包含属性 `int Length {get;}` 和索引器 `this[int]`，且无 `this[System.Index]` 和 `this[System.Range]` 时，类型对象则隐式支持索引运算；包含方法 `public TResult[] Slice(int start, int length)`，则隐式支持范围运算。

```csharp
class NumberArray(params int[] Numbers)
{
    // 支持索引 ^
    public int Length => Numbers.Length;
    public int this[int index] => Numbers[index];  
    // 支持范围 .. ；不要显式调用
    public int[] Slice(int start, int length) => Numbers[start..(start + length)];
}

var arr = new NumberArray(1, 2, 3, 4, 5, 6);
_ = arr[^1]; // 6
_ = string.Join(",", arr[1..4]);  // 2,3,4
```

>---
#### 9.6. 事件

事件是 *sender* 能够向所有相关组件广播已发生事情的一种方式。任意的组件都可以订阅（`+=`）和取消（`-=`）事件。事件建立在委托基础之上。事件的触发只能由包含实体内部引发。字段形式的事件自动合成 `remove` 和 `add` 访问器。

```csharp
class Sample
{
    // public event EventHandler<string> MyEvent;  // 字段形式
    private EventHandler<string> myEvent;
    public event EventHandler<string> MyEvent    // 访问器形式
    {
        add => myEvent += value;
        remove => myEvent -= value;
    }
    // 内部引发
    public void Greeting(string mess) 
        => myEvent?.Invoke(this, mess);
}

Sample s = new Sample();
s.MyEvent += (o, e) => Console.WriteLine($"{o} MyEvent Invoke >>> {e}");
s.Greeting("Hello, World"); // Sample MyEvent Invoke >>> Hello, World
```

> **异步事件订阅**

事件订阅异步方法时，只能订阅 `async void` 方法。

```csharp
class Worker
{
    public EventHandler<string> StartWorking;
    public void Greeting(string mess) => StartWorking?.Invoke(this, mess);

    public static async Task DoWorkAsync(string mess)
       => await Task.Run(() => Console.WriteLine(mess));

    static void Main(string[] args)
    {
        Worker worker = new Worker();
        worker.StartWorking += async (sender, mess) =>    // async void
        {
            try {
                await DoWorkAsync(mess);
            }
            catch (Exception e) {
                Console.WriteLine($"Async task failure: {e.ToString()}");
            }
        };

        worker.Greeting("Hello");
        worker.Greeting("World");
        Thread.Sleep(1000); 
    }
}
```

> *委托与事件的区别*

委托和事件均通过调用仅在运行时绑定的方法组来进行组件之间的通信，都支持单播和多播方式。程序设计基于方法回调时常使用委托；程序在不调用任何订阅方并完成其所有工作时常使用事件。

>---
#### 9.7. 重载运算符

类或结构可重载运算符，至少有一个参数是包含类型 `T` 或 `T?`。可重载的运算符有：

- 算数运算符：一元 `++`、`--`、`+`、`-` 和二元 `*`、`/`、`%`、`+`、`-` 算术运算符。
- 逻辑运算符：一元 `!` 和二元 `&`、`|`、`^`。
- 比较运算符：二元 `<` 和 `>`、`<=` 和 `>=`、`==` 和 `!=`。
- 位运算：一元 `~` 和二元 `&`、`|`、`^`。
- 移位运算符：二元 `<<`、`>>`、`>>>`。
- 一元 `true` 和 `false` 运算符，返回 `bool` 类型。若用户类型同时定义了逻辑二元 `&` 或 `|` 运算符重载，则可以使用相应的条件逻辑运算符 `&&` 或 `||`。

```csharp
readonly record struct Point(int X, int Y)
{
    // 一元运算符重载
    public static Point operator +(Point p) => new(+p.X, +p.Y);
    public static Point operator -(Point p) => new(-p.X, -p.Y);
    // 二元运算符重载
    public static Point operator +(Point l, Point r) => new(l.X + r.X, l.Y + r.Y);
    public static Point operator -(Point l, Point r) => new(l.X - r.X, l.Y - r.Y);
}
```

> `checked` 用户定义算数运算符

可以使用 `checked` 关键字定义算数运算符的溢出检查版本，同时需要定义非 `checked` 版本。

```csharp
readonly record struct Point(int X, int Y) 
{
    public static Point operator checked +(Point l, Point r) => checked(new Point(l.X + l.X, r.Y + r.Y));
    public static Point operator +(Point l, Point r) => new(l.X + r.X, l.Y + r.Y);
}
```

> 用户定义类型转换

`implicit` 和 `explicit` 用于定义（非接口之间的）隐式转换或显式转换运算。如果两个类型之间存在预定义的转换，则忽略这些类型之间的任何用户定义转换。

```csharp
struct Point
{
    public int X;
    public int Y;
    public static implicit operator (int X, int Y)(Point p) => (p.X, p.Y);   
    public static explicit operator Point((int X, int Y) p) => new() { X = p.X, Y = p.Y };  
}
Point p = (Point)(1, 2);   // 元组 -> Point
(int, int) val = p;        // Point -> 元组
```

> 用户定义条件逻辑运算符

若用户定义类型已包含 `|` 或 `&` 运算符重载，可以定义 `true` 和 `false` 的运算符重载，以支持该类型条件逻辑运算 `||` 或 `&&`。`|` 或 `&` 运算符参数和返回类型都是包含类型 `T`。

```csharp
public struct LaunchStatus(int status) {
    public static readonly LaunchStatus Green = new LaunchStatus(0);
    public static readonly LaunchStatus Yellow = new LaunchStatus(1);
    public static readonly LaunchStatus Red = new LaunchStatus(2);
    private int Status => status;
    public static bool operator false(LaunchStatus x) => x == Red;
    public static bool operator true(LaunchStatus x) => x == Green || x == Yellow;
    public static LaunchStatus operator &(LaunchStatus x, LaunchStatus y) {
        if (x == Red || y == Red || (x == Yellow && y == Yellow))
            return Red;
        if (x == Yellow || y == Yellow)
            return Yellow;
        return Green;
    }
    public static bool operator ==(LaunchStatus x, LaunchStatus y) => x.Status == y.Status;
    public static bool operator !=(LaunchStatus x, LaunchStatus y) => !(x == y);
    public override bool Equals(object obj) => obj is LaunchStatus other && this == other;
    public override int GetHashCode() => status;
}
public class LaunchStatusTest {
    static LaunchStatus GetFuelLaunchStatus() {
        Console.WriteLine("Getting fuel launch status...");
        return LaunchStatus.Red;
    }
    static LaunchStatus GetNavigationLaunchStatus() {
        Console.WriteLine("Getting navigation launch status...");
        return LaunchStatus.Yellow;
    }
    static void Main() {
        LaunchStatus okToLaunch = GetFuelLaunchStatus() && GetNavigationLaunchStatus();
        Console.WriteLine(okToLaunch ? "Ready to go!" : "Wait!");
    }
    /* output:
        Getting fuel launch status...
        Wait!
    */
}
```

>---
#### 9.8. 构造函数

实例构造函数支持重载但无法继承；静态构造函数初始化类型状态。构造派生类时，沿继承树从 `object` 开始依次调用基类的实例构造函数和静态构造函数（仅调用一次）。默认生成一个公共无参构造函数（非抽象类）。实例构造函数可以显式引用 `this` 或 `base` 的实例构造函数。
 
```csharp
class Sample
{
    static Sample() => Console.WriteLine("Static Sample");
    public Sample() => Console.WriteLine("Sample()");
    public Sample(string str) : base() { }   
}
```

> **主构造函数**

可以在类、结构和记录中声明主构造函数。非记录的主构造函数参数自动实现为私有字段。记录的主构造函数参数合成为公共自动属性，其中 `record class` 为 `P{ get; init; }`，`record struct` 为 `P{ get; set; }`。

```csharp
record SampleRecord(int val, string Name) {
    public int val { get; set; } = val;
}
class SampleClass(int val) {
    public int val { get; } = val;
}
```

> **复制构造函数**

`record` 隐式生成复制构造函数。`with` 表达式自动调用它的复制构造函数。可以显式创建复制构造函数：

```csharp
record Sample(int[] Arr) {
    // 显式定义复制构造函数
    protected Sample(Sample s) {
        Arr = new int[s.Arr.Length];
        Array.Copy(s.Arr, Arr, Arr.Length);
    }
}

Sample sa = new ([1, 2, 3, 4, 5]);
Sample sa_copy = sa with {};    
```

> **静态构造函数**

静态构造函数在类、结构、记录或接口中声明，在首次调用类型时仅调用一次；接口静态构造函数在首次使用接口任意静态成员时被调用。

静态构造函数中引发异常时，类型在程序生存期内均将保持未初始化，后续任意调用都会引发 `TypeInitializationException`。

```csharp
interface ISample {
    static ISample() => Console.WriteLine("ISample Called");
    static int Value;
}
class Sample:ISample {
    static Sample() => Console.WriteLine("Sample Called");
}

ISample s = new Sample();  // Sample Called
ISample.Value = 10086;     // ISample Called
```

>---
#### 9.9. 析构函数

析构函数在类中定义，不能继承，由垃圾回收器调用。析构函数可以在实例符合终结条件后的任何时间执行，在任何线程上执行。当实例终结时按派生顺序调用析构函数。可以调用 `GC.Collect` 手动进行垃圾回收。

```csharp
class Destroyer {
    public override string ToString() => GetType().Name;
    ~Destroyer() => Console.WriteLine($"The {ToString()} finalizer is executing.");
}
```

拥有析构函数的类型，编译器自动合成 `Finalize()`，并隐式调用基类上的 `Finalize()`。

```csharp
public class Destroyer {
    public override string ToString() => GetType().Name;
    ~Destroyer() => Console.WriteLine($"The {ToString()} finalizer is executing.");
    // 对析构函数的调用会隐式转换为
    protected override void Finalize() {
        try {
            // cleanup statements
            this.~Destroyer();
        } finally {
            base.Finalize();
        }
    }
}
```

>---
#### 9.10. 保留成员名称

> *为属性保留的成员名*

对于属性 `T P{ get; set; }`，保留成员签名：

```csharp
T get_P();
void set_P(T value);
```

> *为事件保留的成员名*

对于事件 `event Dele E`，保留成员签名：

```csharp
void add_E(Dele handler);
void remove_E(Dele handler);
```

> *为索引保留的成员名*

对于索引器 `T this[<PList>]`，保留成员签名：

```csharp
T Item[PList];     // 关联属性
T get_Item(<PList>);
void set_Item(<PList>, T value);
```

> *为析构函数保留的成员名*

对于析构函数 `~T()`，保留成员签名：

```csharp
void Finalize();
```

>---
#### 9.11. 分部声明

可以在多个编译单元进行分部声明分布类型（类、结构、记录、接口）；分部类型中声明分部成员（事件、实例构造函数、方法、属性、嵌套类型）。

同一成员的两个签名和泛型约束（若泛型分部方法）必须匹配。对于 `partial void func();` 分部方法可以不提供实现，所有的无效调用被删除。

```csharp
// Customer1.cs
public partial class Customer {
    private List<int> orders;
    public partial void SubmitOrder(int orderSubmitted);   // 分部方法原型
}
// Customer2.cs
public partial class Customer {
    public partial void SubmitOrder(int orderSubmitted) => orders.Add(orderSubmitted);
    public bool HasOutstandingOrders() => orders.Count > 0;
}
```

接口分布方法具有访问性修饰时需要提供默认实现：

```csharp
// file1.cs
partial interface ISample {
    partial void Fun();  // 隐式 private，可以不提供实现
    public partial void Fun(int a);
}
// file2.cs
partial interface ISample {
    public partial void Fun(int a) => Fun();
}
```

>---
#### 9.12. 扩展成员声明

在顶级静态类中可以声明扩展方法（`this`）或扩展成员（`extension`），扩展成员可以是索引器、属性、方法、运算符。

```csharp
public record struct Point(double x, double y);
public static class PointExt {
    extension(Point person)
    { // 支持 ref, in, ref readonly 和 scoped/[UnscopedRef] 
        public static Point operator +(Point p1, Point p2) 
            => new Point(p1.x + p2.x, p1.y + p2.y);
        public static Point operator -(Point p1, Point p2)
            => new Point(p1.x - p2.x, p1.y - p2.y);
    }
    public static double Magnitude(this Point p) 
        => Math.Sqrt(p.x * p.x + p.y * p.y);
}

var m = (new Point(1, 2) + new Point(3, 4)).Magnitude();
```

为泛型类型声明扩展成员：

```csharp
public class Array<T>(params List<T> values) where T: unmanaged {
    internal List<T> array = values;
}
public static class ArrayExt {
    extension<T>(Array<T> arr) where T : unmanaged {
        public int Length => arr.array.Count;
        public void Add(T v) => arr.array.Add(v);
    }
    public static void Print<T>(this Array<T> array) where T : unmanaged
        => Console.WriteLine(string.Join(",", array.array));
}
```

---
### 10. 接口类型

接口可以包含方法、属性、事件、索引器、静态构造函数、静态成员、常量、运算符、嵌套类型等，支持多继承。

```csharp
interface ISample
{
    // 实例成员
    void FunA();
    int Value { get; set; }
    event Action MEvent;
    int this[int index] { get; set; }
    // 静态成员
    static ISample() { Console.WriteLine("Static ISample"); }
    static int GUI => 10010;
    static Action StaticEvent;
    const string TypeName = nameof(ISample);
    static ISample operator ++(ISample s) {
        s.Value++;
        return s;
    }
    // 嵌套类型
    delegate void OnInvoke();
    class Nested;
    interface INestedSample;
}
class Sample : ISample
{
    public int this[int index] { get; set; }
    public int Value { get; set; }
    public event Action MEvent;
    public void FunA() { ... }
}
```

>---
#### 10.1. 接口实现

派生类型可以隐式或显式接口方式实现接口，泛型接口实现需满足约束。显式实现无法修改原始访问性限定和签名；隐式实现可以更改为更高访问性限定，属性和索引器可以声明其他访问器。派生可以重写虚方法并更改接口映射关系。

```csharp
interface IBase {
    internal void FunA();
    void FunB();
}
class Base : IBase {
    // 隐式实现，提升可访问限制为 public
    public virtual void FunA() => Console.WriteLine("Base Fun");
    // 显式接口实现，声明为异步方法
    async void IBase.FunB() { /* ... */ }   
}
class Derived : Base {
    // 更改接口映射关系
    public override void FunA() => Console.WriteLine("Derived Fun"); 
    static void Main(string[] args) {
        IBase b = new Base();
        IBase d = new Derived();
        b.FunA();   // Base Fun
        d.FunA();   // Derived Fun
    }
}
```

对于多继承接口相同名称的成员，出现歧义时需要指定接口。可以通过显式接口实现方式消除歧义。

```csharp
interface IFaceA
{
    void Count(int c);
    int Value { get; set; }
}
interface IFaceB
{
    int Count { get; set; }
    int Value { get; set; }
}
interface IFaceC : IFaceA, IFaceB;

x.Value = 10086;   // err；歧义
x.Count(1);
x.Count = 1;       // err；被隐藏
((IFaceB)x).Value = 1;
((IFaceA)x).Value = 2;
```

接口方法的 `params` 参数默认实现方式可省略；

```csharp
interface ISample
{
    void Fun(params int[] arr);
    void FunB(int[] arr);
}
class Sample : ISample
{
    public void Fun(int[] arr) { }          // 忽略 params  
    public void FunB(params int[] arr) { }  // 添加 params
}
```

>---
#### 10.2. 默认实现

接口成员可以默认实现，派生类型可以不提供实现或重映射（非 `sealed` 或 `private`）。`private`、`virtual`、`sealed` 成员必须具有默认实现。默认实现的非 `sealed` 方法可以在派生接口中重新声明为 `abstract`。

```csharp
interface ISampleA
{
    void FunA();
    void FunB() => Console.WriteLine("ISampleA.FunB");  // 默认实现
    void FunC() => Console.WriteLine("ISampleA.FunC");  // 默认实现
}
interface ISampleB : ISampleA
{
    void ISampleA.FunA() => Console.WriteLine("ISampleB.FunA");  // 提供 FunA 的默认实现
    abstract void ISampleA.FunB();   // 重声明为 abstract
}
class Sample : ISampleA, ISampleB
{
    public void FunB() => Console.WriteLine("Sample.FunB");  
    static void Main(string[] args)
    {
        Sample s = new Sample();

        ISampleA sa = s;
        sa.FunA();      // ISampleB.FunA
        sa.FunB();      // Sample.FunB
        sa.FunC();      // ISampleA.FunC

        ISampleB sb = s;
        sb.FunA();      // ISampleB.FunA
        sb.FunB();      // Sample.FunB
        sb.FunC();      // ISampleA.FunC
    }
}
```

>---
#### 10.4. 静态抽象和静态虚拟成员

接口可以声明静态 `abstract` 和 `virtual` 函数类成员，常在泛型接口中声明，由类型参数静态访问。`sealed` 或 `virtual` 静态成员提供默认实现。派生类型提供这些方法的实现。

```csharp
interface ISample {
    static virtual void Func() => Console.WriteLine("ISample.Func");
    static abstract event Action E;
}
interface ISample<T> : ISample where T : ISample<T> {
    static abstract void ISample.Func();  // 重声明
    static abstract T P { get; set; }
    static abstract T operator +(T l, T r);
    static abstract implicit operator T(string s);
    static abstract explicit operator string(T t);
}
class Sample : ISample {
    public static event Action E;  // 自动实现
    // 重映射
    public static void Func() => Console.WriteLine("Sample.Func");
    static void Test<T>() where T : ISample     {
        Sample.Func();   // Static Sample.Func
        T.Func();        // Static Sample.Func
    }
}
```

---
### 12. 记录类型

记录 `record struct/class` 用于封装数据。包含主构造函数时构造位置记录，参数可以是 `in` 或 `params`，编译器为位置参数自动生成公有属性和元组解构函数 `Deconstruct`（可重定义）：
- `record class`，生成 `get/init`。
- `record struct`，生成 `get/set`；`readonly` 生成 `get/init`。

```csharp
public record Person(string FirstName, string LastName);
// 相当于
public record Person{
    public string FirstName { get; init; }
    public string LastName { get; init; }
    // 自动生成，可以声明方法重载或重定义 Deconstruct
    public void Deconstruct(out string firstName, out string lastName) 
        => (firstName, lastName) = (FirstName, LastName);
}
```

>---
#### 12.2. 记录相等性

如果两个记录是相同类型且存储相同的值，则它们相等。

```csharp
public record Person(string FirstName, string LastName, string[] PhoneNumbers);

var phoneNumbers = new string[2];
Person p1 = new("Nancy", "Davolio", phoneNumbers);
Person p2 = new("Nancy", "Davolio", phoneNumbers);

Console.WriteLine(p1 == p2); // True
p1.PhoneNumbers[0] = "555-1234";
Console.WriteLine(p1 == p2); // True
Console.WriteLine(ReferenceEquals(p1, p2)); // False
```

为实现值相等性，编译器为记录类型 `R` 合成了几种方法：
  - 运算符 `==` 和 `!=`，`Object.Equals(Object)`，无法重定义。
  - 重写 `Object.GetHashCode()`，可以重定义。
  - 合成 `IEquatable<T>::Equals(R? other)`，可以显式定义，应该同时定义 `GetHashCode`。
  - 合成 `Type EqualityContract { get; }`，可以显式定义。默认实现的 `GetHashCode` 调用了 `EqualityContract`，因此不建议在此属性中调用 `GetHashCode`。  

```csharp
record Person(string FirstName, string LastName) : IEquatable<Person> {
    public string PhoneNum { get; set; } = "";
    protected virtual Type EqualityContract => this.GetType();
    public override int GetHashCode() {
        Console.WriteLine("Use GetHashCode");
        return unchecked((EqualityComparer<Type>.Default.GetHashCode(EqualityContract) * -1521134295
               + EqualityComparer<string>.Default.GetHashCode(FirstName)) * -1521134295
               + EqualityComparer<string>.Default.GetHashCode(LastName));
    }
    public virtual bool Equals(Person? other) {
        Console.WriteLine("Use Equals");
        return other != null
                && EqualityContract == other.EqualityContract
                && EqualityComparer<string>.Default.Equals(FirstName, other.FirstName)
                && EqualityComparer<string>.Default.Equals(LastName, other.LastName);
    }
    public override string ToString() => $"{this.FirstName} {LastName}: {PhoneNum}";
}
```

>---

#### 12.3. 记录复制与克隆

`with` 表达式中可以更改记录，属性必须包含 `init` 或 `set` 访问器，结果是一个浅拷贝副本。

```csharp
public record Person(string FirstName, string LastName) {
    public required string[] PhoneNumbers { get; init; }
}

Person p1 = new("Nancy", "Davolio") { PhoneNumbers = new string[1] };   
Person p2 = p1 with { FirstName = "John" };  // John Davolio
Console.WriteLine(p1 == (p1 with { PhoneNumbers = new string[1] }));    // false
Console.WriteLine(p1 == (p1 with { }));   // true
```

编译器为记录合成两个复制函数成员：一个复制构造函数和实例方法 ` Clone`。`with` 表达式调用记录的 `Clone` 执行克隆：

```csharp
record Person(string FirstName, string LastName)
{
    [CompilerGenerated]
    protected Person(Person original)  // 默认生成，可显式定义
    {
        FirstName = original.FirstName;
        LastName = original.LastName;
    }
    [CompilerGenerated]
    public virtual Person Clone() => new Person(this);    // 编译器生成，无法重定义
}
```

>---
#### 12.4. 记录格式化

编译器为记录重写 `ToString` 和合成方法 `PrintMembers`，以格式化输出记录的数据成员。

```csharp
public record struct Point(int x, int y)
{
    [CompilerGenerated]
    public override readonly string ToString()
    {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append("Point");
        stringBuilder.Append(" { ");
        if (PrintMembers(stringBuilder))
            stringBuilder.Append(' ');
        stringBuilder.Append('}');
        return stringBuilder.ToString();
    }

    [CompilerGenerated]
    private readonly bool PrintMembers(StringBuilder builder)
    {
        builder.Append("x = ");
        builder.Append(x.ToString());
        builder.Append(", y = ");
        builder.Append(y.ToString());
        return true;
    }
}

Console.WriteLine(new Point(0,0));  // Point { x = 0, y = 0 }
```

> *自定义 ToString*

```csharp
public record struct Point(int x, int y) {
    public static implicit operator Point((int, int) p) => new Point(p.Item1, p.Item2);
    public override string ToString() => $"({this.x},{this.y})";
}
Console.WriteLine((Point)(1,2)); // (1,2)
```

> *自定义 PrintMembers*

```csharp
public record struct Point(int x, int y) {
    public static implicit operator Point((int, int) p) => new Point(p.Item1, p.Item2);
    public override string ToString() => $"({this.x},{this.y})";
}
public readonly record struct PointArray(params Point[] points) {
    public readonly int Length => points.Length;
    private bool PrintMembers(StringBuilder sb) {
        if (points.Length == 0)
            return false;
        else {
            sb.Append($"{points[0]}");
            foreach (Point p in points[1..points.Length])
                sb.Append("," + p);
            return true;
        }
    }
}
PointArray X = new((0, 0), (1, 1), (2, 2), (3, 3), (4, 4));
Console.WriteLine(X);
// PointArray { (0,0),(1,1),(2,2),(3,3),(4,4) }
```

---
### 13. 动态类型

`dynamic` 类型可以引用任何对象，运行时动态绑定，编译时不进行静态解析。动态类型无法使用索引和范围运算。

```csharp
class Sample
{
    static dynamic _field;
    public dynamic Func(dynamic d)
    {
        dynamic local = "Local variable";
        int two = 2;
        return d is int ? local : two;
    }
}

Sample s = new Sample();
Console.WriteLine(s.Func(10));      // Local variable
Console.WriteLine(s.Func("value")); // 2
//Console.WriteLine(s.Func(10, 4));    // 编译时异常
dynamic d = new Sample();
Console.WriteLine(d.Func(10));         // Local variable
```

> **CIL 中的动态类型**

在 CIL 中，编译时 `dynamic` 替换为 `System.Object`，DLR（动态运行时）借助反射来调用成员。首次调用时，构造 `CallSite<T>` 变量生成调用点缓存和操作表达式树，后续相同的动态调用通过 `CallSite<T>.Target()` 映射实际调用的成员。

```csharp
dynamic v = GetDynamicV();
// 编译为
object v = GetDynamicV();

ret = dy.Method(arg);
// 编译为
CallSite<Action<CallSite,object,object>>.Create(...).Invoke(...);
```
```csharp
// C# 调用
class Sample
{
    static void Main(string[] args)
    {
        dynamic dy = 0;
        string str = dy.ToString();
    }
}
// CIL To C#
internal class Sample
{
	[CompilerGenerated]
	private static class o__0   // 生成一个动态绑定关联对象
	{
        public static CallSite<Func<CallSite, object, object>> p__0;
        public static CallSite<Func<CallSite, object, string>> p__1;
	}

	[System.Runtime.CompilerServices.NullableContext(1)]
	private static void Main(string[] args)
	{
        object dy = 0;   // 被视为 `object` 的 `dynamic dy = 0;`
        if (o__0.p__1 == null)
        {
            o__0.p__1 = CallSite<Func<CallSite, object, string>>
                .Create(Binder.Convert(CSharpBinderFlags.None, typeof(string), typeof(Sample)));
        }
        Func<CallSite, object, string> target = o__0.p__1.Target;
        CallSite<Func<CallSite, object, string>> p__ = o__0.p__1;
        if (o__0.p__0 == null)
        {
            o__0.p__0 = CallSite<Func<CallSite, object, object>>
            .Create(Binder.InvokeMember(CSharpBinderFlags.None, "ToString", null, typeof(Sample),
                    new CSharpArgumentInfo[1] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) }));
        }
        string str = target(p__, o__0.p__0.Target(o__0.p__0, dy));  // 调用 CallSite<T>.Target
	}
}
```

---
### 14. 可空值类型

可空值类型 `T?` 额外包含 `null`。可空值类型都是泛型 `System.Nullable<T>` 的实例。当 `t.HasValue = false`，`v.Value = null`。

可空值类型的一元或二元运算中，至少存在一个 `null` 时，结果也为 `null`。对于比较运算符，至少一个为 `null` 时结果为 `false`。`null == null` 返回 `true`。

```csharp
int num = 10010;
int? n_num = num;        // 包装
num = n_num ?? default;  // 展开，检查空引用
```

可空值类型空检查：

```csharp
void NullCheck<T>(T? n) where T : struct
{
    if (n != null) ;
    // do .. with n.Value
    if (n is int temp) ;
    // do .. with temp
    if (n.HasValue) ;
    // do .. with n.Value
    var v = n ?? default(T);
    // do .. with v
}
```

> *确定可空值类型*

```csharp
bool IsNullable(Type type) => Nullable.GetUnderlyingType(type) != null;

Console.WriteLine($"int? is {(IsNullable(typeof(int?)) ? "nullable" : "non nullable")} value type");
// int? is nullable value type
Console.WriteLine($"int is {(IsNullable(typeof(int)) ? "nullable" : "non-nullable")} value type");
// int is non-nullable value type
```

> *可空引用类型*

在可空上下文中使用可空引用类型、`null` 静态分析警告和空包容运算符（`!`）是可选的语言功能。可空引用类型非新类型，编译器使用这些空注释来查找代码中潜在的空引用错误。

两种方式开启可空感知上下文：项目级别 `<Nullable>enable</Nullable>` 设置；或预处理指令 `#nullable enable`。

---
### 15. 匿名类型

匿名类型将一组只读属性封装到单个对象中，支持 `with` 表达式，隐式继承 `object`。初始化属性的表达式不能是 `null`、匿名函数、指针。

```csharp
var v = new { Amount = 108, Message = "Hello" };
Console.WriteLine(v.Amount + v.Message);
var v2 = v with { Amount = 256 };
// 匿名类型数组
var anonArr = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};
```

具有相同顺序、类型、名称的属性序列的两个匿名对象，被视为同一匿名类型的实例。

```csharp
var p1 = new { Name = "Lawnmower", Price = 495.00 };
var p2 = new { Name = "Shovel", Price = 26.95 };
Console.WriteLine(p1.GetType() == p2.GetType());  // true
```

匿名类型通常用在查询表达式的 `select` 子句中：

```csharp
var productQuery =
    from prod in products
    select new { prod.Color, prod.Price };

foreach (var v in productQuery)
    Console.WriteLine("Color={0}, Price={1}", v.Color, v.Price);
```

---
### 16. 泛型构造

泛型构造的实体可以是类、结构、接口、方法和委托等。

```csharp
abstract class GenericSample
{
    // 泛型方法
    public abstract T GetGenericValue<T>();
    // 泛型类
    class GenericClass<T>;
    // 泛型结构
    struct GenericStruct<T>;
    // 泛型接口
    interface IGenericInterface<T>;
    // 泛型委托
    delegate void GenericDelegate<T>();
    // 泛型记录
    record GenericRecordClass<T>;
    record struct GenericRecordStruct<T>;
}
```

>---
#### 16.2. 类型约束

`where` 指定类型约束，默认为 `object`；可以指定的约束有：

```csharp
interface ISample<T> where T : struct;     // 非空值类型
interface ISample<T> where T : class;      // 非空引用类型
interface ISample<T> where T : class?;     // 可空引用类型
interface ISample<T> where T : notnull;    // 非空类型
interface ISample<T> where T : unmanaged;  // 非空非托管类型
interface ISample<T> where T : new();      // 类型具有可访问的无参构造函数
interface ISample<T> where T : Base;       // 指定类型及其派生
interface ISample<T> where T : IBase;      // 指定接口及其派生
interface ISample<T, U> where T : U;       // T 是 U 或 U 的派生类型
interface ISample<T> where T : allows ref struct;   // ref struct 类型
interface ISample<T> where T : default;    // 消除歧义
```

`struct`、`class`、`unmanaged`、`notnull`、`default` 约束不能组合。`new()` 不与 `unmanaged` 和 `struct` 组合。`new()` 或 `allows ref struct` 是约束列表中的最后一个， 

> default 约束

在泛型方法的 `T?` 含义中，引用类型 `T?` 和值类型 `T?` 会产生歧义：值类型 `T?` 与 `System.Nullable<T>` 等价；引用类型 `T?` 在 `#nullable enable` 上下文表示 `null` 是有效值。

当基类或接口声明一个方法的两个重载（一个指定 `struct` 约束，另一个指定 `class` 或未指定约束）时，派生重写或显式实现的方法未声明约束时，会产生歧义，`default` 约束用于解决歧义。

```csharp
abstract class Base {
    public abstract void Func<T>(T? t);
    public abstract void Func<T>(T? t) where T : struct;
}
class Derived : Base {
    public override void Func<T>(T? t) /* where T : struct */ { }
    public override void Func<T>(T? t) where T : default { }
}
```  
  
> 约束继承

类型的约束不被继承，派生类型的类型参数传递给其基类；派生可以声明相同约束或更强限制的约束。

```csharp
class Base<T> where T : class;
class Derived<T> : Base <T> where T : class, new();
```

重写或显式实现的方法的约束从基方法继承，无法指定（除了 `class` 或 `struct`）或更改约束。

```csharp
class Sample
{
    public virtual void FunA<T>() where T : Sample { }
    public virtual void FunB<T>() where T : struct { }
}
class Derived : Sample
{
    public override void FunA<T>() /* where T : Sample */  // okay
        => base.FunA<T>(); 
    public override void FunB<T>() where T : struct        // okay
        => base.FunB<T>();
}
```

>---
#### 16.4. 协变与逆变

类型参数（引用类型）的协变（`out`）或逆变（`in`）可以使用派生程度比目标构造类型更高（协变）或更低（逆变）的类型实参，仅限于泛型接口和委托类型。逆变参数常用作方法参数类型，协变参数常用作返回类型。派生接口不会继承基接口的变体特性。

```csharp
delegate TResult GenericDelegate<in T, out TResult>(T arg);
interface IGeneric<in T, out TResult> {
    TResult GetResult(T arg);
}
```

协变和逆变能够实现类型参数的隐式转换。

```csharp
interface ICovariant<out A>;             // 协变泛型接口
interface IContravariant<in A>;          // 逆变泛型接口
class Base;
class Derived : Base;
class Sample<T> : ICovariant<T>, IContravariant<T>;

ICovariant<Base> I_B = new Sample<Derived>();       // Derived 协变 Base
IContravariant<Derived> I_D2 = new Sample<Base>();  // Base 逆变 Derived 
```

实现变体接口时，有时会导致多义性。编译器不会产生错误，未显式指定将在运行时选择（例如继承顺序先后）。

```csharp
class Animal;
class Dog : Animal;
class Cat : Animal;
interface ICovariant<out T> { void Do(); }
class Pets : ICovariant<Cat>, ICovariant<Dog> {
    void ICovariant<Dog>.Do() => Console.WriteLine("Dog");
    void ICovariant<Cat>.Do() => Console.WriteLine("Cat");
}

ICovariant<Animal> pets = new Pets();
pets.Do();  // Cat ? Dog ? 
```

数组的协变使派生更大类型的数组能够隐式转换为派生更小类型的数组。

```csharp
IEnumerable<object> e = new List<string>();
IEnumerable<object>[] arr = new List<string>[50]; // 数组的协变
```

---
### 17. 指针类型

在 `unsafe` 上下文中，使用指针、分配或释放内存块。指针不受垃圾收集器管理。允许在不同指针类型之间、指针与整型之间进行转换。`void*` 无类型指针可以强制转换为其他指针类型。

```csharp
unsafe {
    void* p;       
    int** p;       
    int*[] p;    // 指针数组  
    int* p1, p2, p3;
    volatile void* p;  // 易变限定
    dynamic* pd;
}
```

指针可作为 `in`、`ref`、`ref readonly`、`out` 的参数传递，但可能会导致未定义行为。指针可能指向局部变量或固定变量，而该变量在函数返回时不存在。

```csharp
unsafe class Sample {
    static int value = 20;
    static void FunUndefined(out int* pi1, ref int* pi2) {
        int i = 10;
        pi1 = &i;       // local variable
        fixed (int* pj = &value)
            pi2 = pj;   // fixed ptr
    }
    static void OtherFunInStack() {
        int i = 60;
    }
    static void Main() {
        int i = 15;
        int* pi2 = &i;
        FunUndefined(out int* pi1, ref pi2);
        OtherFunInStack();   // 刷新调用栈
        int v1 = *pi1; // undefined
        Console.WriteLine(v1);   // 60, not 10
        int v2 = *pi2; // undefined
        Console.WriteLine(v2);   // 20
    }
}
```

>---
#### 17.1. 指针操作

在不安全的上下文中，有几种方式可用于操作所有 **非函数指针的指针类型**：

| Operator                    | Description                                                                |
| :-------------------------- | :------------------------------------------------------------------------- |
| `&v`                        | 取址运算符                                                                 |
| `*p`                        | 间接操作符                                                                 |
| `p[i]`                      | 索引数组指针，`p[i]` 等价于 `*(p + i)`，越界行为未定义                     |
| `p->M`                      | 成员访问，`p->M` 等价于 `(*p).M`                                           |
| `p++`,`p--`,`++p`,`--p`     | 指针自增自减                                                               |
| `p+N`,`p-N`,`p1-p2`         | 指针与整数算术。指针相减返回相对偏移量；指针与整数算术返回指针偏移后的地址 |
| `==`,`!=`,`<=`,`>=`,`<`,`>` | 指针比较，高位地址的指针大于低位地址的指针                                 |
| `stackalloc T[size] `       | 赋值给指针类型、`Span<T>` 或 `ReadOnlySpan<T>`                             |
| `fixed(p = &Value)`         | 固定移动变量地址                                                           |

`pt ± n` 相当于 `(T*)((long)pt ± n*sizeof(T))`。`pt_x - pt_y` 相当于 `((long)(pt_x) - (long)(pt_y)) / sizeof(T)`。

```csharp
int* values = stackalloc int[20];
int* p = &values[1];
int* q = &values[15];
Console.WriteLine($"p - q = {p - q}");  // -14
Console.WriteLine($"q - p = {q - p}");  // 14
```

>---
#### 17.2. 固定与可移动变量

地址运算符 `&` 和固定 `fixed` 语句将变量分为固定变量和可移动变量。固定变量在不受垃圾收集影响（包括局部变量、值形参和解引用指针创建的变量），取址不受限制；可移动变量可由垃圾收集器重新定位或处理（包括对象字段、数组元素、引用传递的参数），仅在 `fixed` 固定语句可取址。

```csharp
static unsafe void Fun(int len, int[] arr){
    int * plen = &len;     // 固定变量
    fixed (int* p = arr)   // 可移动变量
    {
        int * pArr = p;
        for (int i = 0;i < len; i++)
            Console.WriteLine(pArr[i]); ;
    }
}

Fun(10, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
```

`fixed` 固定指针只读，无法作为引用（`ref`、`ref readonly`、`in`、`out`）参数向外部传递。可固定的变量可以是数组、数组元素、对象字段、具有 `ref [readonly]? T GetPinnableReference()` 类型、`System.Span<T>` 或 `System.ReadOnlySpan<T>`、字符串、固定大小的缓冲区。


```csharp
unsafe void ToUpper(string str)
{
    fixed (char* f = str) {
        int index = 0;
        foreach (char c in str)
            f[index] = char.ToUpper(f[index++]);
    }
    Console.WriteLine(str);
}
ToUpper("Hello World");  // HELLO WORLD
```

> 固定具有 `GetPinnableReference` 方法的类型实例

```csharp
record NumberArray(params int[] arr) {
    public ref int GetPinnableReference() => ref arr[0];
}

unsafe {
    NumberArray arr = new(1, 2, 3, 4, 5, 6);
    fixed (int* p = arr)
        for (int i = 0; i < 6; i++)
            Console.WriteLine(p[i]);
}
```

--- 
### 18. 函数指针

`delegate*` 语法声明函数指针，对静态方法取址。委托使用 `callvirt` 指令调用虚函数，函数指针使用 `calli` 指令调用。在性能关键的代码路径中，`calli` 调用效率更高。

```csharp
delegate* calling_convention? <params, TResult> 
/* calling_convention : 调用约定，默认为 managed
    managed : 托管调用
    unmanaged : 运行时平台选择
    unmanaged [ ... ] 
        Cdecl : 调用方清理堆栈
        stdcall : 被调用方清理堆栈
        Thiscall : 指定方法调用的第一个参数是 this 指针, 该指针存储在寄存器 ECX 中
        Fastcall : 调用约定指定在寄存器中传递函数的参数 (如果可能) 
        Swift : Swift 调用约定
        MemberFunction : 指示调用函数变体
        SuppressGCTransition : 指示抑制 GC 转换作为调用约定的一部分
*/
unsafe {
    delegate* <void> pf;
    delegate* managed<void> pf;    // 默认, 可省略
    delegate* unmanaged<void> pf;  // 取决于平台 
    delegate* unmanaged[Cdecl]<void> pf;
    delegate* unmanaged[Stdcall, SuppressGCTransition]<void> pf;  // 组合
}
```

调用约定也是函数指针签名的一部分。

```csharp
unsafe {
    delegate*<int, int, int> p1 = ...;
    delegate* managed<int, int, int> p2 = ...;
    delegate* unmanaged<int, int, int> p3 = ...;

    p1 = p2; // okay : p1, p2 具有相同的签名 
    p2 = p3; // error : 调用约定不兼容
}
```

>---
#### 18.2. UnmanagedCallersOnly

`UnmanagedCallersOnly` 指示方法使用的调用约定。有以下限制：
- 无法直接调用。仅通过调用指向该方法的函数指针。
- 如果方法具有托管类型的参数或返回类型，则会产生错误。
- 无法转换为委托类型。

`UnmanagedCallersOnly(CallKind)` 注释的方法均可在 *Native* 代码中直接调用。如果指定了一种类型 *CallKind*：该类型可以 `CallConvCdecl`、`CallConvThiscall`、`CallConvStdcall`、`CallConvFastcall`、`CallConvSwift`。
  - `CallConvCdecl` 指示调用方清理堆栈，调用可带有 *varargs* 变长参数。默认行为。
  - `CallConvThiscall` 指示方法调用的第一个参数是 `this` 指针，存储在寄存器 `ECX` 中。调用的其他参数推送到堆栈。此调用约定用于对从非托管 DLL 导出的类调用方法。
  - `CallConvStdcall` 指示被调用方清除堆栈。这是从托管代码调用非托管函数的默认约定。
  - `CallConvFastcall` 指示函数参数在可能的情况下通过寄存器传递。在当前 `NET` 不受支持。
  - `CallConvSwift` 指示方法使用 *Swift* 调用约定。

可以和 `MemberFunction`、`SuppressGCTransition` 任一进行组合：
  - `SuppressGCTransition` 指示方法应禁止 GC 转换作为调用约定的一部分。该方法只能在非托管代码中使用。 
  - `MemberFunction` 指示所使用的调用约定是成员函数变体。

```csharp
unsafe 
{
    [UnmanagedCallersOnly(CallConvs = new[] { typeof(CallConvCdecl)})]
    static int Fun(int val) => val;
    delegate* unmanaged[Cdecl]<int, int> pf = &Fun;
    return pf(0);
}
```

>---
#### 18.3. UnmanagedCallConv

`UnmanagedCallConv` 指定在 NET 中调用非托管代码 P/Invoke 方法（本机函数）所需的调用约定。这些方法的调用约定为 `managed`。

当此特性应用于 `DllImport` 的方法，其中 `CallingConvention` 设置为 `Winapi` 时，NET 运行时将使用 `UnmanagedCallConv.CallConvs` 来确定 P/Invoke 的调用约定。

```csharp
unsafe partial class Sample
{
    [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl), typeof(CallConvSuppressGCTransition) })]
    [LibraryImport("msvcrt.dll", StringMarshalling = StringMarshalling.Utf8)]
    internal static partial int puts(string str);
}

unsafe
{
    delegate* managed<string, int> pf = &Sample.puts;
    pf("Hello World");
}
```

---
### 19. 表达式与运算符

> **运算符与优先级**

| **Category**                | **Operators**                                                                                                                                       |
| --------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| 基本表达式                  | `x.y` `x?.y` `x->y` `f(x)` `a[i]` `a?[i]` `x++` `x--` `new` `typeof` `default` `checked` `unchecked` `delegate` `stackalloc` `nameof` `sizeof` `x!` |
| 一元                        | `+x` `-x` `!x` `~x` `++x` `--x` `(Type)value` `await expr` `&x` `*x` `true` `false`                                                                           |
| 索引与范围                  | `^n` `a..b`                                                                                                                                         |
| `switch` 和 `with` 表达式   | `switch {...}` `with {...}`                                                                                                                         |
| 乘法                        | `x * y` `x / y` `x % y`                                                                                                                             |
| 加法                        | `x + y` `x - y`                                                                                                                                     |
| 移位                        | `x << y` `x >> y` `x >>> y`(无符号逻辑右移)                                                                                                                         |
| 关系和类型测试              | `x < y` `x > y` `x <= y` `x >= y` `is` `as`                                                                                                         |
| 相等                        | `x == y` `x != y`                                                                                                                                   |
| 布尔逻辑或按位运算          | `x & y` `x ^ y` `x \| y`                                                                                                                            |
| 条件逻辑                    | `x && y` `x \|\| y`                                                                                                                                 |
| 空合并运算或 `throw` 表达式 | `x ?? y`  `throw x`                                                                                                                                 |
| 条件运算符                  | `cond ? T : F` `cond ? ref T : ref F`                                                                                                                                                |
| 赋值与 Lambda         | `var x` `x = y` `x = ref y` `x *= y` `x /= y ` `x %= y` `x += y` `x -= y` `x <<= y` `x >>= y` `x >>>= y` `x &= y` `x ^= y` `x \|= y` `=>`           |

>---
#### 类型推断声明

`var` 隐式声明局部变量，编译器类型推断。`var` 可作为 `out` 参数传递，发生歧义需要指定类型。

```csharp
class Sample
{
    static void Fun(out int num) => num  = default;
    static void Fun(out string mess) => mess = default;
    static void Main(string[] args)
    {
        Fun(out var num);      // 隐式声明，歧义
        Fun(out string mess);  // 显式输入类型
    }
}
```

>---
#### 值相等性

> 用户定义类型相等性

实现自定义类型相等，重写替代 `object.Equals(object)`，该方法应只调用 `System.IEquatable<T>.Equals(T other)`。可选重载 `==` 和 `!=`。替代的 `Object.GetHashCode`，确保具有值相等性的两个对象生成相同的哈希代码。

实现自定义类型比较，实现 `IComparable<T>`，并重载 `<` 和 `>`。

```csharp
// 结构用户定义相等性
struct Point2D(int x, int y) : IEquatable<Point2D>
{
    public int X { get; private set; } = x;
    public int Y { get; private set; } = y;
    public override bool Equals(object? obj) => obj is Point2D other && this.Equals(other);
    public bool Equals(Point2D p) => X == p.X && Y == p.Y;
    public override int GetHashCode() => (X, Y).GetHashCode();
    public static bool operator ==(Point2D lhs, Point2D rhs) => lhs.Equals(rhs);
    public static bool operator !=(Point2D lhs, Point2D rhs) => !(lhs == rhs);
}
```

> 浮点值的相等性

浮点值由于精度差异，预期相同的浮点值通常不相等，因为它们的最小有效位数存在差异。`Equals` 或 `CompareTo` 确定两个浮点值，通常会产生意外的结果。可以使用 `Math.Round` 方法使两个浮点值具有相同的精度。

```csharp
double value1 = .333333333333333;
double value2 = 1.0/3;
Console.WriteLine("{0:R} = {1:R}: {2}", value1, value2, value1.Equals(value2));
value1 = Math.Round(value1, 15);
value2 = Math.Round(value2, 15);
Console.WriteLine("{0:R} = {1:R}: {2}", value1, value2, value1.Equals(value2));
// 0.333333333333333 = 0.3333333333333333: False
// 0.333333333333333 = 0.333333333333333: True
```

另一种方式是测试近似相等性而不是值相等性。

```csharp

```

可以利用浮点格式的设计功能：两个浮点值的整数表示形式之间的差异指示分隔它们的可能浮点值的数量。例如，`0.0` 和 `double.Epsilon` 的二进制格式表示的整数之间的差值为 1。一般用于与零进行比较 `Math.Abs(val - 0.0) < double.Epsilon`

```csharp
static class Ext {
    public static bool ApproximatelyEqual(this double d, double other, double epsilon) {
        if (d.Equals(other))
            return true;
        // Handle zero to avoid division by zero
        double divisor = Math.Max(d, other);
        if (divisor.Equals(0))
            divisor = Math.Min(d, other);
        return Math.Abs((d - other) / divisor) <= epsilon;
    }
}
double d = 0;
for (int ctr = 1; ctr <= 10; ctr++)
    d += .1;
Console.WriteLine("{0:R} = {1:R}: {2}", 1.0D, d, d.Equals(1.0D));
Console.WriteLine("{0:R} is approximately equal to {1:R}: {2}", 1.0D, d,
                  d.ApproximatelyEqual(d, .000000001));
// 1 = 0.9999999999999999: False
// 1 is approximately equal to 0.9999999999999999: True
```

> 为 *ref* 变量创建引用相等性比较

值类型的引用比较值相等性，引用类型的引用比较引用相等性。若要检查两个 `ref` 值类型是否引用同一个对象，则比较它们的地址值。

```csharp
static class Ext {
    public unsafe static bool RefEquals<T>(this scoped ref T t, scoped ref T other) where T : struct {
        fixed (T* pt = &t, pOther = &other)
            return pt == pOther;
    }
}

int n1 = 0, n2 = n1;
ref int rn1 = ref n1;
ref int rn2 = ref n2;
Console.WriteLine(rn1.RefEquals(ref rn2));  // false
rn2 = ref rn1;
Console.WriteLine(rn1.RefEquals(ref rn2));  // true
rn2 = ref n1;
Console.WriteLine(rn1.RefEquals(ref rn2));  // true
```


>---
#### 19.1. 空条件访问与空合并

`x?.y` 或 `x?[y]` 在 `x` 非空时执行后续访问；否则返回 `null`。支持空条件分配：

```csharp
customer?.Order = GetCurrentOrder();
// 相当于
if(customer is not null)
    customer.Order = GetCurrentOrder();

arr?[index] = value;
// 相当于
if(arr is not null)
    arr[index] = value;
```

`??` 和 `??=` 空合并在左操作数为 `null` 时，返回右操作数。

```csharp
int? num = null;
int _num = num ?? default;
num ??= default;
```

>---
#### 19.7. 空包容

在可为空感知上下文中，空包容 `x!` 来取消编译器空警告，运行时无作用。

```csharp
#nullable enable
class Person(string name);
Person p = new(null!);
```

>---
#### 19.2. 初始化器

初始化器分为对象初始化器和集合初始化器。

```csharp
// 对象初始化器
record struct Sample(int x,int y); 
Sample s = new Sample { x = 1, y = 2 };
// 集合初始化器
Dictionary<string, int> Persons = new Dictionary<string, int>
{
    ["Tom"] = 10,
    ["Mary"] = 13,
    ["Hello"] = 5,
    ["World"] = 12
};
int[] arr1 = new[] { 1, 2, 3, 4, 5, 6 };
int[] arr2 = { 1, 2, 3, 4, 5, 6 };    // 数组初始化器
```

用户定义集合类型实现 `IEnumerable` 和 `Add(T t)`，可以使用集合初始化器。

```csharp
class SampleList<T> : IEnumerable
{
    List<T> list = new List<T>(80);
    public void Add(T val) => list.Add(val);
    IEnumerator IEnumerable.GetEnumerator() => list.GetEnumerator();
}
SampleList<int> arr = new SampleList<int> { 1, 2, 3, 4, 5 };
```

>---
#### 19.3. typeof

`typeof` 或 `obj.GetType()` 用于获取类型（包括未绑定类型）或对象关联的 `System.Type` 对象，通过反射获取有关类型或程序集信息。

```csharp
class Animal;
class Giraffe : Animal;

object b = new Giraffe();
Console.WriteLine(b is Animal);                    // True
Console.WriteLine(b.GetType() == typeof(Animal));  // False
Console.WriteLine(b is Giraffe);                   // True
Console.WriteLine(b.GetType() == typeof(Giraffe)); // True
```

>---
#### 19.4. sizeof 

`sizeof` 返回类型占用字节大小。对于 `nint`、`nuint`、指针、用户结构、托管类型、可空值类型等没有预定义的大小，只能在 `unsafe` 中使用。

```csharp
unsafe
{
    Console.WriteLine(sizeof(char));                     // 2
    Console.WriteLine(sizeof(int));                      // 4
    Console.WriteLine(sizeof(int?));                     // 8
    Console.WriteLine(sizeof(decimal));                  // 16
    Console.WriteLine(sizeof(decimal?));                 // 24
    Console.WriteLine(sizeof(nint));                     // 8
    Console.WriteLine(sizeof(string));                   // 8
    Console.WriteLine(sizeof(List<char>));               // 8
    Console.WriteLine(sizeof(void*));                    // 8
    Console.WriteLine(sizeof(delegate*<void>));          // 8
}
```

>---
#### 19.5. nameof

`nameof`（不求值表达式）返回程序实体（非动态类型）的名称。

```csharp
using TestAlias = System.String;
Console.WriteLine( nameof(System));                       // System
Console.WriteLine( nameof(System.Collections.Generic));   // Generic
Console.WriteLine( nameof(TestAlias));                    // TestAlias
Console.WriteLine( nameof(List<>));                       // List
Console.WriteLine( nameof(List<int>));                    // List
Console.WriteLine( nameof(List<>.AddRange));              // AddRange
Console.WriteLine( nameof(List<int>.AddRange));           // AddRange
Console.WriteLine( nameof(Thread.CurrentThread));         // CurrentThread
Console.WriteLine( nameof(Thread.Sleep));                 // Sleep
```

>---
#### 19.8. checked, unchecked

`checked` 和 `unchecked` 表达式或语句执行整型算术溢出检查，默认为 `unchecked`。对常量表达式，默认始终检查溢出。

```csharp
int Sum(int x, int y) => checked(x + y);
_ = Sum(int.MaxValue, 1);   // 溢出异常
unchecked {
    _ = int.MaxValue + 1;   // 编译时忽略检查
}
```

>---
#### 19.9. stackalloc

`stackalloc UnmanagedT[E]` 声明非托管类型堆栈数组并启用缓冲区溢出检测，表达式结果可以分配给 `Span<T>` 或 `ReadOnlySpan<T>` 和指针 `UnmanagedT*`。

```csharp
Span<int> span1 = stackalloc int[3];  // 非零初始化
Span<int> span2 = stackalloc[] { -10, -15, -30 };
ReadOnlySpan<long> span3 = stackalloc[] { 11, 12L, 13 };
unsafe {
    int* span4 = stackalloc[] { 11, 12, 13 };
    int* span5 = stackalloc int[10];
}
```

>---
#### 19.10. with

`with` 表达式用于创建记录、结构或匿名类型的浅拷贝副本，并附加修改的属性或字段。
 
```csharp
// 记录类型
record Sample(string Name, int ID, params List<string> tels);
Sample s = new Sample("Jimry", ID: 1, new List<string>());
Sample s_copy = s with { Name = "Ychao" };
// 匿名类型
var Point = new { x = 1, y = 1 };
var Point_copy = Point with { x = 10 };
``` 

>---
#### 19.11. await

`await` 表达式阻塞当前线程并等待异步完成。操作数类型是 `Task`、`Task<T>`、`ValueTask`、`ValueTask<T>` 等。

```csharp
class Sample {
    public static async Task PrintA(int times) {
        // await do something
        await Task.Run(() => {
            for (int i = 0; i < times; i++)
                Console.Write("A");
        });
    }
}

List<Task> ts = new List<Task>(10);
for (int i = 0; i < 10; i++)
    ts.Add(Sample.PrintA(100));
Task.WaitAll(ts);
```



>---
#### 19.14. is, as

`E is T` 检查表达式 `E` 的运行时类型是否与 `T` 兼容。可以检查 null 值。

```csharp
class Base;
class Derived : Base;

object b = new Base();
Console.WriteLine(b is Base);     // True
Console.WriteLine(b is Derived);  // False

object d = new Derived();
Console.WriteLine(d is Base);     // True
Console.WriteLine(d is Derived);  // True
```

`E as T` 尝试将 `E` 转换为给定的引用类型或可空值类型 `T`，不会抛出异常，无法转换时返回 `null`。

```csharp
IEnumerable<int> numbers = new[] { 10, 20, 30 };
IList<int> indexable = numbers as IList<int>;
if (indexable != null)
    Console.WriteLine(indexable[0] + indexable[indexable.Count - 1]);  // output: 40
```

>---
#### 19.20. 模式匹配

`is` 表达式、`switch` 语句或表达式将输入表达式与任意数量的特征匹配。弃元 `_` 模式匹配任何表达式。
  - 声明模式：检查运行时类型，在匹配时分配给变量。
  - 类型模式：检查运行时类型。
  - 常量模式：检查结果与常量是否相等。
  - 关系模式：结果与常量比较。
  - 逻辑模式：检查表达式是否与模式的逻辑组合匹配。
  - 属性模式：检查表达式的属性或字段是否与相应嵌套模式匹配。
  - 位置模式：解构表达式结果并检查是否与相应嵌套模式匹配。
  - var 模式：匹配任何表达式并将其结果分配给变量。
  - 列表模式：检查序列元素是否与相应嵌套模式匹配。


```csharp
// is 模式匹配
bool rt_1 = E is <pattern>;
bool rt_2 = E is <pattern> e;
// switch 模式匹配
switch (<switch_on>)
{
    case <exp_1>:
    case <exp_2>: 
        // do...
        break; // return, goto
    default:
        // default do
        break;
}
// switch 表达式
var rt = <switch_on> switch
{
    case_1 => case_1_return,
    case_2 => case_2_return,
    //....cases
    _ => default_return   // 弃元模式
};
```

> is 模式匹配

```csharp
bool 声明模式 = expr is T t;   
bool 类型模式 = expr is T;
bool 常量模式 = expr is not (null or ConstV);   
bool 关系模式 = expr is < 10;
bool 逻辑模式 = expr is not null and < 10;    // not > and > or
bool 属性模式 = expr is { Value: > 10, p: { x: > 10 }, UID.Data: 10086 };  // 嵌套
bool 位置模式 = expr is ( > 0, > 0) { magnitude: < 100 };  // 位置参数
bool VAR_模式 = expr is var (x, y);  // 匹配任意  
bool 列表模式 = arr is [> 0, .. { Length: >= 2 }, > 4 or < 10];   // .. 切片
```

> switch 模式匹配

```csharp
dynamic? rt = expr switch
{
    IA ia => null,                  // 声明模式
    IB => null,                     // 类型模式
    null or ConstV => null,         // 常量模式
    < 10 and > -10 => null,         // 关系模式
    > 10 or (null and ConstV) => null,             // 逻辑模式
    { p: { x: > 10 }, UID.Data: 10086 } => null,   // 属性模式
    ( > 0, > 0) { magnitude: < 100 } => null,      // 位置模式
    var (x, y) when x < y => null,                  // Var 模式
    [< 0, .. { Length: >= 2 and <= 4 }, > 0] => null,   // 列表模式
    _ => default,   // 弃元模式
};
```

>---
#### 19.21. 索引与范围运算符

索引 `^` 和范围 `..` 运算符可以在序列访问器中使用：
- `[^n] = [Length - n]`。
- `a..b` 表示 $[a,b)$。`[a..] = [a..^0]`、`[..b] = [0..b]`、`[..] = [0..^0]`。

单维度数组、交错数组、`List<T>`、`String`、`Span<T>` 和 `ReadOnlySpan<T>` 等类型支持索引和范围。

```csharp
// ^ 末尾运算符
var xs = new int[] { 0, 10, 20, 30, 40 };
int last = xs[^1];  // [^0] 超出索引范围
// .. 范围运算符
var rx = new int[] { 0, 100, 200, 300, 400 };
int half = rx.Length / 2;
var left = rx[..half];  // {0， 100}
var right = rx[^(rx.Length - half)..];  // {200, 300, 400}
```

> **索引和范围的类型支持**

`^0` 是 `Index` 类型，`a..b` 是 `Range` 类型。声明 `this[Index]` 或 `this[Range]` 索引器显式支持索引或范围运算。

```csharp
readonly record struct Point(int x, int y) {
    public override string ToString() => (x, y).ToString();
}
record struct PointArray(params Point[] ps) {
    public Point this[Index i] => ps[i];
    public Point[] this[Range r] => ps[r];
}

PointArray ps = new PointArray(
    new(0, 1), new(1, 2), new(2, 3), 
    new(3, 4), new(4, 5), new(5, 6));
Console.WriteLine("Last Point is " + ps[^1]);    // (5,6)
Console.WriteLine("The Points of range 1~4 are " + string.Join(",", ps[1..5]));
// The Points of range 1~4 are (1, 2),(2, 3),(3, 4),(4, 5)
```

> **索引和范围的隐式支持**

类型包含 `int Length{ get;}` 或 `int Count{ get;}` 和 `T this[int index]`，且无仅 `this[Index]` 索引器时，该类型隐式支持索引运算。

类型包含 `int Length{ get;}` 和 `public T[] Slice(int start, int length)`，且无仅 `this[Range]` 索引器时，该类型隐式支持范围运算。

```csharp
record struct PointArray(params Point[] ps)
{
    public Point this[int i] => ps[i];
    public int Length => ps.Length;
    public Point[] Slice(int start, int length)
    {
        var _ps = new Point[length];
        Array.Copy(ps, start, _ps, 0, length);
        return _ps;
    }
}
```

>---
#### 19.22. 集合表达式

一维数组类型、`Span<T>` 和 `ReadOnlySpan<T>`、支持集合初始化的类型（如 `List<T>` 等）可以使用集合表达式初始化。展开运算符 `..` 在集合表达式中使用内联集合值。

```csharp
int[] left = [1, 2, 3, 4];
int[] right = [5, 6, 7, 8, 9];
int[] all = [.. left, .. right, 0];
Console.WriteLine(string.Join(",", all));  // 1,2,3,4,5,6,7,8,9,0
int[][] arr2 = [[10, 20, 30], [0], arr];      // 交错数组
Span<int> arr = [1, 2, 3, 4, 5];
ReadOnlySpan<int> arr2 = [.. arr, 6, 7, 8, 9];
```

用户定义类型实现 `IEnumerable<T>` 或 `IEnumerable`，并包含一个 `Add` 方法，隐式支持集合表达式。

```csharp
struct ReadOnlyArray<T>() : IEnumerable
{
    private T[] values = new T[100];
    private int Length = 0;
    public T this[int i] => values[i];
    public void Add(T value)
    {
        if (Length > values.Length - 1)
            throw new ArgumentOutOfRangeException("Capacity");
        values[Length++] = value;
    }
    IEnumerator IEnumerable.GetEnumerator() => values[..^(values.Length - Length)].GetEnumerator();
}

ReadOnlyArray<int> arr = [1, 2, 3, 4, 5, 6];
```

> **集合生成器**
 
集合表达式还可转换具有集合生成器的类型。类型通过编写绑定名称的生成器方法（例如 `Create`）和 `CollectionBuilder` 特性（指示生成器方法）来支持集合表达式。

集合类型必须具有迭代器 `GetEnumerator`。集合生成器非泛型，生成器 `static` 并使用 `ReadOnlySpan<T>` 为唯一参数。

```csharp
[CollectionBuilder(typeof(MyCollectionBuilder), "Build")]
public record MyCollection<T>(params T[] Values) {
    public IEnumerator<T> GetEnumerator() => Values.AsEnumerable().GetEnumerator();
}
internal class MyCollectionBuilder {
    internal static MyCollection<T> Build<T>(ReadOnlySpan<T> arr) => new MyCollection<T>(arr.ToArray());
}

MyCollection<int> arr = [1, 2, 3, 4, 5];
arr = [1, 2, 3, .. arr];    // 1,2,3,1,2,3,4,5
```

---
### 20. 语句

#### 20.2. 条件分支语句: if, switch
> **if-else**

```csharp
if (cond1)
    // do
else if (cond2)
    // do
else 
    // do
```

> **switch**

```csharp
switch (n)
{
    case > 0 when n < 10:   // when 筛选
        Console.WriteLine("0 < a < 10");
        break;
    case > 10:
    case < -10:
        break;
    case -5:
        goto case 0;  // 仅 case 常量
    default:   // 默认分支
        break;
}
```

>---
#### 20.3. 迭代语句: for, foreach, do, while

> **for**

```csharp
for( <init>?; <cond>?; <iter>? )
    statements
```

> **foreach**

`foreach` 迭代 `IEnumerable` 或 `IEnumerable<T>`。

```csharp
foreach (var elem in IEnumerables)
    statements
```

`foreach` 也可迭代具有 `GetEnumerator` 的类型，返回类型具有 `Current` 属性（可返回`ref`）和 `bool MoveNext()` 方法。

```csharp
record struct NumArray(params int[] nums) {
    public IEnumerator<int> GetEnumerator() => nums.ToList().GetEnumerator();
}

foreach (int i in new NumArray(1, 2, 3, 4, 5, 6, 7, 8, 9))
    Console.WriteLine(i);
```

对于 `foreach (var v in x)`，迭代器的行为类似于：

```csharp
foreach (var v in x)
{
    E e = ((C)(x)).GetEnumerator();
    try {
        while(e.MoveNext()) {
            V v = (V)(T)e.Current;
            embedded_statement; 
        }
    } finally {
        if(e is IDisposable d)
            d.Dispose();
    }
}
```

`yield` 在 `foreach` 中延迟迭代。`yield break` 跳出迭代。

```csharp
IEnumerable<int> Square(int[] items)
{
    int rt;
    for (int i = 0; i < items.Length; i++)
    {
        try { rt = checked(items[i] * items[i]); }
        catch { yield break; }  // 在溢出时跳出迭代
        yield return rt;
    }
}

foreach (var item in Square([1, 2, 3, 4, 5, 6, 99999/* 溢出位 */, 7, 8, 9]))
    Console.Write(item + " ");  // output: 1 4 9 16 25 36
```

> **await foreach**

`await foreach` 支持异步数据流，迭代器返回 `IAsyncEnumerable<T>` 或 `IAsyncEnumerator<T>`。`IAsyncDisposable` 用于异步清理。迭代类型具有公共无参 `GetAsyncEnumerator` 方法，返回类型具有 `Current` 属性和 `ValueTask<bool> MoveNextAsync` 方法。

`await foreach` 可以视为：
 
```csharp
await foreach(var task in asyncEnumerable) 
    use(task);
// >>>>> 
{
    IAsyncEnumerator<T> asyncEnumerator = asyncEnumerable.GetAsyncEnumerator();
    try {
        while (await asyncEnumerator.MoveNextAsync())
            use(asyncEnumerator.Current);
    }
    finally { 
        await ((System.IAsyncDisposable)asyncEnumerator).DisposeAsync(); 
    }
}
```

异步迭代流 `IAsyncEnumerable<T>`：

```csharp
async IAsyncEnumerable<int> GenerateNumbersAsync(int count) {
    for (int i = 0; i < count; i++)
        yield return await ProduceNumberAsync(i);
}
async Task<int> ProduceNumberAsync(int seed) {
    await Task.Delay(200);
    return 2 * seed;
}

await foreach (int n in GenerateNumbersAsync(50))
    Console.Write(n + " ");
// Output: 0 2 4 6 8 ...
```

> **do** 

```csharp
do {
    statements;
} while (cond);
```

> **while**

```csharp
while (cond) {
    statements
}
```

>---
#### 20.4. 跳转语句: break, continue, goto, return

> **break** 

`break` 跳出最内层循环或跳出 `switch` 语句。

```csharp
while(cond) {
	/* ... */
	break;  // 相当于 goto end;
	/* ... */
}
end:
```

> **continue**

`continue` 跳转至当前循环的末尾。

```csharp
while(cond) {
	/* ... */
	continue;  // 相当于 goto contin;
	/* ... */
contin:
}
```


> **goto**

`goto` 语句将控制权转交给带有标签、`case` 或 `default` 的语句。

```csharp
void func() { 
	{ // block
		goto out;
	}   
out:
    // ...
}
```

> **return**

`return` 终止函数执行并返回（值）到调用方。

```csharp
bool Func() {
    Console.WriteLine("Hello, World");
    return true;
}
```

>---
#### 20.5. lock

`lock(x) { .. }` 锁定引用类型，避免使用 `this`、`Type` 对象、`string` 作为 `lock` 对象。

```csharp
class Sample {
    public readonly static object locker = new();
    public static int count = 0;
    public static async Task Counter(int times) {
        // await do something
        await Task.Run(() => {
            for (int i = 0; i < times; i++)
                lock (locker)
                    count++;
        });
    }
}

List<Task> ts = new List<Task>(10);
for (int i = 0; i < 10; i++)
    ts.Add(Sample.Counter(10000));
Task.WaitAll(ts);
Console.WriteLine(Sample.count);  // 100000

```

>---
#### 20.6. using

`using` 语句确保正确使用 `IDisposable`，在语句结束时正确调用 `Dispose`，相当于 `try { do ... } finally { d.Dispose(); }`。

```csharp
static IEnumerable<int> LoadNumbers(string filePath) {
    var numbers = new List<int>();
    using (StreamReader reader = File.OpenText("numbers.txt"))  
    // using StreamReader reader = File.OpenText(filePath);  // 或 using 声明 
    {
        string line;
        while ((line = reader.ReadLine()) is not null)
            if (int.TryParse(line, out int number))
                numbers.Add(number);
    }
    return numbers; 
}
```

> **await using**

`await using` 语句确保正确使用 `IAsyncDisposable` 对象或拥有 `public async ValueTask DisposeAsync();` 方法的对象。

```csharp
class AsyncDisposableExample{
    public async ValueTask DisposeAsync() => Console.WriteLine("DisposeAsync...");
}
await using (var resource = new AsyncDisposableExample());
    // do with resource ...
```

>---
#### 22. 异常语句

异常派生自 `Exception` 类型，`e.StackTrace` 保存异常发生时的调用堆栈状态。`e.Message` 保存发生异常信息。

```csharp
void ExceptionTest() => throw new NotImplementedException();

try {
    ExceptionTest();
}
catch (NotImplementedException ex) {
    Console.WriteLine($"EROOR : {ex.Message}\n" + ex.StackTrace);
}
```

`throw` 抛出异常，隐式转换为任意类型；`try` 执行安全检查；`catch` 执行异常捕捉；`when` 执行异常筛查；`finally` 执行资源清理。

`catch` 中 `throw;` 重新引发异常，并保留异常的原始堆栈跟踪在 `e.StackTrace`。

```csharp
try {
    // try do ...
}
catch (ArgumentException e) when (e is ArgumentNullException) { 
    Console.WriteLine($"Processing failed: {e.Message}");
}
catch (OperationCanceledException) {
    Console.WriteLine("Processing is cancelled.");
}
catch // 无筛选条件
{
    throw;  // 重新引发异常
} finally {
    // something disposed
    Console.WriteLine("Finally ...");
}
```

> 常见 NET 异常类型

```csharp
ArithmeticException         // 算术运算期间出现的异常的基类，例如 DivideByZeroException 和 OverflowException。
ArgumentException           // 传递给方法的参数无效
ArgumentNullException       // 不应为 null 的参数传递了 null 值
ArrayTypeMismatchException	// 存储数组元素时，由于元素类型与数组类型不兼容引发。
ApplicationException        // 作为应用程序定义的异常的基类。
DivideByZeroException	    // 尝试将整数值除以零时引发。
FormatException             // 当参数的格式无效或复合格式字符串格式不正确时引发的异常。
IndexOutOfRangeException	// 索引小于零或超出数组边界时，尝试对数组编制索引时引发。
InvalidCastException	    // 从基类型显式转换为接口或派生类型在运行时失败时引发。
InvalidOperationException   // 当方法调用对于对象的当前状态无效时引发的异常。
NullReferenceException	    // 尝试引用值为 null 的对象时引发。
NotImplementedException     // 当请求的方法或操作未实现时引发的异常。 
OutOfMemoryException	    // 尝试使用新运算符分配内存失败时引发。 此异常表示可用于公共语言运行时的内存已用尽。
OverflowException	        // checked 上下文中的算术运算溢出时引发。
RuntimeBinderException      // 表示在处理 C# 运行时绑定中的动态绑定时发生的错误。
StackOverflowException	    // 执行堆栈由于有过多挂起的方法调用而用尽时引发；通常表示非常深的递归或无限递归。
TypeInitializationException	// 静态构造函数引发异常并且没有兼容的 catch 子句来捕获异常时引发。
```

> 捕捉非 CLS 异常

包括 C++/CLI 在内的某些 NET 允许引发并非 CLS 异常。可以在 `catch (RuntimeWrappedException ex)` 捕获这些异常。

```csharp
try {
    ThrowNonCLSException();
} catch (System.Runtime.CompilerServices.RuntimeWrappedException e) {
    if (e.WrappedException is String s)
        Console.WriteLine(s);
}
```

默认情况下，CLR 包装所有异常。要禁用此行为，添加到程序集特性：

```csharp
[assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)];
```

---
### 23. 特性

直接或间接派生自抽象类 `System.Attribute` 的类被称为特性类，C#11 起支持泛型。定义特性类时，可以在特性类上附加 `AttributeUsage` 来控制它的使用方式。

全局级别特性需要标识 `assembly` 或 `module`。其他标准化的特性目标包含 `event`、`field`、`method`、`param`、`property`、`return`、`type`、`typevar`。这些目标只能在以下上下文中使用：
- `event`：事件。
- `field`：字段、类似字段的事件、自动实现的属性。
- `method`：构造函数、析构函数、方法、运算符、属性或索引器的访问器、事件的访问器、类似字段的事件。
- `param`：属性或索引器的 `set` 访问器、事件的访问器、构造函数参数、方法参数、运算符参数。
- `property`：属性、索引器。
- `return`：委托、方法、运算符、属性或索引器的 `get` 访问器。
- `type`：委托、类、结构、枚举和接口。
- `typevar`：类型参数。


```csharp
[AttributeUsage(AttributeTargets.All)]
public class TargetAttribute : Attribute;

[type: Target]
class Sample<[typevar: Target] T> where T : notnull
{
    [field: Target] public T AutoValue { get; }

    public T Value
    {
        [return: Target] get => default!;
        [param: Target]  set { }
    }

    [field: Target] event Action fieldEvent;

    event Action accessorEvent
    {
        [return: Target] add { }
        [method: Target] remove { }
    }
}
```

特性类具有位置参数和命名参数，特性类的每个公共构造函数都为该类定义了一个有效的位置参数序列。命名参数由特性类的非静态、公共和读写的字段或属性定义。位置参数或命名参数不能是类型参数或开放式泛型，`Type` 的特性参数可以是未绑定的泛型类型。

特性类的位置参数和命名参数的类型仅限于以下类型之一：`bool`、`char`、`byte`、`sbyte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`float`、`double`、`object`、`System.Type`、枚举类型以及对应的一维数组。

```csharp
public class AuthorAttribute(string name) : Attribute
{
    public string Name { get; } = name;  // name 位置参数初始化
    public string Version;  // 命名参数
}

[Author("Hello", Version = "1.0.0.0")]
class Sample;
```

> **运行时检索特性实例**

特性实例是在运行时表示特性的实例，通过反射检索类型绑定的特性信息。一个特性由特性类、位置参数和命名参数定义。

```csharp
[AttributeUsage(AttributeTargets.Class)]
public class HelpAttribute(string url) : Attribute
{
    public string Topic { get; set; }
    public string Url { get; } = url;
}

[Help("https://github.com/dotnet", Topic = "Help")]
public sealed class InterrogateHelpUrls
{
    public static void Main(string[] args)
    {
        Type helpType = typeof(HelpAttribute);

        var attributes = typeof(InterrogateHelpUrls).GetCustomAttributes(helpType, false);
        var helpers = (HelpAttribute[])attributes;
        foreach (var helper in helpers)
        {
            Console.WriteLine($"Url : {helper.Url}");
            Console.WriteLine($"Topic : {helper.Topic}");
        }
    }
}
```

>---
#### 23.1. AttributeUsage

`AttributeUsage` 用于描述使用特性类的方式。

```csharp
[AttributeUsage(
    AttributeTargets.Class | AttributeTargets.Struct,
    Inherited = false,          // 无法被派生类继承
    AllowMultiple = true
)]
public class AuthorAttribute(string Name) : Attribute;
[Author("Hello"), Author("World")] class Base;

Console.WriteLine(typeof(Base).CustomAttributes.Count());  // 2
Console.WriteLine(typeof(Derived).CustomAttributes.Count());  // 0, Author 特性无法被派生类继承
```

>---
#### 23.2. Conditional 

`Conditional`：指示编译器应忽略方法或特性类的调用，除非定义了指定的条件编译符号。


```csharp
#define Condition
using System.Diagnostics;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
[Conditional("Condition")] class SampleAttribute(string Message) : Attribute;

[Sample("Hello World")]
class SampleClass
{
    [System.Diagnostics.Conditional("Condition")]
    public static void Fun() 
        => Console.WriteLine(typeof(SampleClass).GetCustomAttributesData()[0]);
    // [Sample("Hello World")]
}
```

>---
#### 23.3. Obsolete

`Obsolete` 用于将成员标记为过时的。

```csharp
class Sample
{
    [Obsolete("Use fun instead of ObsoleteFun", true)]
    public static void ObsoleteFun() => Console.WriteLine("ObsoleteFun");
    public static void Fun() => Console.WriteLine("Fun");
}
```

>---
#### 23.4. Caller-info

`CallerArgumentExpression`、`CallerLineNumber`、`CallerFilePath`、`CallerMemberName`：用于向可选参数提供有关调用上下文的信息。


```csharp
class Sample
{
    public static void Expression(object expr,
          [CallerArgumentExpression("expr")] string arg = "",
          [CallerFilePath] string path = "",
          [CallerLineNumber] int line = -1,
          [CallerMemberName] string caller = "")
    {
        Console.WriteLine(
            $"The expression {arg} = {expr}\n " +
                  $"    at {caller} in {path}:{line}");
    }
}

Sample.Expression(25 * 25);
// The expression 25 * 25 = 625
//      at Main in C: Program.cs:17
```

>----
#### 23.5. Flags

`Flags` 标记枚举为位字段，并影响枚举类型的 `ToString()` 和 `Parse` 方法的行为。

```csharp
class Sample
{
    [Flags]
    enum Color
    {
        None = 0, Black = 1, Red = 1 << 1, Green = 1 << 2, Blue = 1 << 3,
    }
    static void Main(string[] args)
    {
        // Display all combinations of values, and invalid values.
        Console.WriteLine("\nAll possible combinations of values with FlagsAttribute:");
        for (int val = 0; val <= 1 << 3; val++)
            Console.WriteLine("{0,3} - {1:G}", val, (Color)val);
    }
    /*
     All possible combinations of values with FlagsAttribute:
        0 - None
        1 - Black
        2 - Red
        3 - Black, Red
        4 - Green
        5 - Black, Green
        6 - Red, Green
        7 - Black, Red, Green
        8 - Blue
     */
}
```

>---
#### 23.6. ModuleInitializer

`ModuleInitializer` 标记一个方法，将其指定为模块初始化器。模块初始化器使程序集加载时立即进行一次性初始化。

```csharp
class ModuleInitializer
{
    [ModuleInitializer]
    internal static void InitModules() => Console.Write("Hello");
    static void Main(string[] args) => Console.Write(" World");   // Hello World
}
```

>---
#### 23.7. SkipLocalsInit

通过指定 `.locals init` 标志，强制从本地内存池分配的所有内容进行零初始化。`SkipLocalsInit` 抑制此标志，可以应用于成员函数、类型、或模块级别。 

```csharp
[module: System.Runtime.CompilerServices.SkipLocalsInit]
[System.Runtime.CompilerServices.SkipLocalsInit]
class Sample;

// For a method
[System.Runtime.CompilerServices.SkipLocalsInit]
void Sample() { }
```

>---
#### 23.8. Experimental

`ExperimentalAttribute` 特性可以应用于程序集中的任何内容，以表明 API 是实验性的。当使用被标记的目标时，编译器发出诊断错误。该错误可以通过将调用方也标记为 `[Experimental]` 来绕过诊断，或者通过编译器 `#pragma warning disable 'diagnosticId'` 显式允许实验代码通过编译：

```csharp
[Experimental(diagnosticId: "Experimental")]
static void ExperimentalMethod()
{
    Console.WriteLine("ExperimentalMethod");
}
// [Experimental(diagnosticId: "Experimental")]
static void Test()
{
#pragma warning disable Experimental
    ExperimentalMethod(); // This now compiles, thanks to the pragma warning disable directives.
#pragma warning restore Experimental
}
```

>---
#### 23.9. Nullable

有时候将数据定义为可空或不可空并不能提高程序的健壮性，可以使用可空特性对方法的输入数据或输出数据进行描述。
- `AllowNull`：不可为 null 的字段、参数或属性可以为 null。
- `DisallowNull`：可为 null 的字段、参数或属性应永不为 null。
- `MaybeNull`：不可为 null 的字段、参数、属性或返回值可以为 null。
- `NotNull`：可为 null 的字段、参数、属性或返回值将永不为 null。
- `MaybeNullWhen`：当方法返回指定的 bool 值时，不可为 null 的参数可以为 null。
- `NotNullWhen`：当方法返回指定的 bool 值时，可以为 null 的参数不会为 null。
- `NotNullIfNotNull`：如果指定参数的自变量不为 null，则参数、属性或返回值不为 null。
- `DoesNotReturn`：方法或属性永远不会返回。 换句话说，它总是引发异常。
- `DoesNotReturnIf`：如果关联的 bool 参数具有指定值，则此方法或属性永远不会返回。

```csharp
class Sample
{
    static bool TryGetDigitAsText(char number, [NotNullWhen(true)] out string? text)
    {
        return (text = number switch
        {
            '0' => "zero",
            '1' => "one",
            '2' => "two",
            '3' => "three",
            '4' => "four",
            '5' => "five",
            '6' => "six",
            '7' => "seven",
            '8' => "eight",
            '9' => "nine",
            _ => null
        }) is string;
    }
    [return: NotNullIfNotNull("text")]
    public static string? TryGetDigitsAsText(string? text)
    {
        if(text is null) return null;
        string rt = "";
        foreach(char c in text) {
            if(TryGetDigitAsText(c, out string? digitText))
            {
                if (rt != "") rt += '-';
                rt += digitText.ToLower(); 
            }
        }
        return rt;
    }
    static void Main(string[] args)
    {
        string t = "132qwe13qwerte31"; // or null
        string rt = TryGetDigitsAsText(t);
        Console.WriteLine(rt.ToLower());
    }
}
```

在泛型编程中，常常标记类型参数是可空类型。由于 `Nullable<T>` 可空值类型与可空引用类型是完全不同的数据类型，声明泛型类型的可空注释（`T?`），则无法判断该泛型类型是值类型或引用类型。可以利用可空特性抑制编译器的空检查警告。

```csharp
class BaseClass
{
    [return: MaybeNull]
    public virtual T Fun<T>([AllowNull] T? t) => t;
}
class DerivedClass : BaseClass
{
    [return: MaybeNull]
    public override T Fun<T>(T? t) where T : default => base.Fun(t);
}
```

>---
#### SetsRequiredMembers

`SetsRequiredMembers` 告知编译器构造函数设置了所有 `required` 成员，调用此构造函数的任何代码可以忽略 `required` 要求。

```csharp
class Person
{
    [System.Diagnostics.CodeAnalysis.SetsRequiredMembers]
    public Person(string firstName, string lastName) => (FirstName, LastName, Age) = (firstName, lastName, 0);
    public Person() { }
    public required string FirstName { get; init; }  // 必填属性
    public required string LastName { get; init; }
    public required int Age;
}

Person p1 = new ("Hello", "World");         // 忽略 Age 必填
Person p2 = new () { FirstName = "Hello", LastName = "World", Age = 6 }; // 初始化设定项
```

---
### 24. LINQ 和查询表达式

查询表达式可用于查询并转换所有启用了 LINQ 的数据源中的数据。查询在 `foreach` 语句中执行，支持 `IEnumerable`、`IEnumerable<T>` 或 `IQueryable`、`IQueryable<T>` 类型称为可查询类型。

可查询类型可以用作 LINQ 的数据源。查询表达式可被编译成表达式树或委托，`IEnumerable<T>` 查询编译为委托。`IQueryable` 和 `IQueryable<T>` 查询编译为表达式树。

查询指定要从数据源中检索的信息，并指定如何对其进行排序、分组和结构化。可以使用查询语法或方法语法来构造查询表达式。查询的实际执行将推迟到在 `foreach` 语句中循环访问查询变量之后进行。

```csharp
int[] numbers = { 5, 10, 8, 3, 6, 12 };
// 查询语法
var numQuery1 =
           from num in numbers
           where num % 2 == 0
           orderby num
           select num;
// 对应 Linq 语法
IEnumerable<int> numQuery2 = numbers
    .Where(num => num % 2 == 0)
    .OrderBy(n => n);

// 查询执行
foreach (int num in numQuery)
    Console.Write("{0,1} ", num);
```

某些查询方法不使用显式 `foreach` 延迟执行，例如 `Count`、`Max`、`Average` 和 `First`。若要立即执行任何查询并缓存其结果，可调用 `ToList` 或 `ToArray` 方法。

```csharp
int[] numbers = { 5, 10, 8, 3, 6, 12 };

int[] Query =
    (from num in numbers
     where (num % 2) == 0
     select num).ToArray();
```

查询表达式以 `from` 子句开头，以 `select` 或 `group` 子句结尾，之间可以包含 `where`、`orderby`、`join`、`let` 或其他 `from` 子句中的一个或多个。可以使用 `into` 使 `join`、`group`、`select` 子句的结果充当同一查询表达式其他子句的数据源。

> **查询表达式示意图**

![查询表达式](.ref/LINQ查询表达式.png)

>---
#### 24.1. 查询表达式

| Clause                                                     | Description                                      |
| :--------------------------------------------------------- | :----------------------------------------------- |
| `from [type]? <id> in <enumerable>`                        | 指定数据源                                       |
| `where <boolean-expr>`                                     | 布尔条件筛选数据源                               |
| `orderby <Primary> <Secondary...> [ascending/descending]?` | 序列以升序或降序排列                             |
| `join <in-id> in <in-seq> on <out-key> equals <in-key>`    | 将两个无直接关系元素的源序列相联结               |
| `let <id> = <expr>`                                        | 引入一个范围变量                                 |
| `select <expr>`                                            | 返回源数据或将源数据映射为新类型                 |
| `group <TElem> by <TKey>`                                  | 分组查询结果并返回一个 `IGrouping<K,E>` 对象序列 |
| `<select\|join\|group> into <id>`                          | 将查询结果存储到新的数据源组中                   |


> **group-by**


`group` 子句返回一个 `IGrouping<TKey,TElement>` 对象序列，这些对象包含零个或多个与该键值匹配的项。

```csharp
group <TElem> by <TKey> [into <identifier>]?
```
`group` 查询产生的 `IGrouping<TKey,TElement>` 对象实质上是一个由列表组成的列表，必须使用嵌套 `foreach` 访问每一分组中的各个项。外部循环访问键，内部循环访问组内的项。

```csharp
foreach (IGrouping<TKey, TElem> Group in Query)
{
    Console.WriteLine(Group.Key);
    foreach (var Elem in Group)
        // do with Elem
}
```

组键可以是任何类型，如字符串、内置数值类型、用户定义的命名类型或匿名类型。

```csharp
// 源数据定义
var students = new[]
{
    new {First="Svetlana", Last="Omelchenko", ID=111, Scores= new List<int> {97, 72, 81, 60}},
    new {First="Claire", Last="O'Donnell", ID=112, Scores= new List<int> {75, 84, 91, 39}},
    new {First="Sven", Last="Mortensen", ID=113, Scores= new List<int> {99, 89, 91, 95}},
    new {First="Cesar", Last="Garcia", ID=114, Scores= new List<int> {72, 81, 65, 84}},
    new {First="Debra", Last="Garcia", ID=115, Scores= new List<int> {97, 89, 85, 82}}
};
// 字符串分组
var StringQuery =
    from student in students
    group student by student.Last;
// 布尔分组
var boolQuery = 
    from student in students
    group student by student.Scores.Average() > 80;  // 分为 true / false 两组
// 数值范围分组
var RangeQuery =
            from student in students
            let avg = (int)student.Scores.Average()
            group student by (avg / 10);  // 以 10 分为范围
```

> **orderby**

`orderby` 返回以升序或降序排序的序列，默认排序顺序为升序 `ascending`，降序为 `descending`。首个排序条件对元素执行主要排序。指定第二个排序条件，可以对每个主要排序组内的元素进行次要排序。

```csharp
orderby <Primary>[,<secondary>...]? [ascending/descending]?
```

主要升序，次要降序：

```csharp
var query = from word in new string[] { "the", "quick", "brown", "fox", "jumps" }
            orderby word.Length ascending, word.Substring(0, 1) descending
            select word;
Console.WriteLine(string.Join(", ", query));
// the, fox, quick, jumps, brown
```

> **join-in-on-equals**

`join` 子句用于将两个没有直接关系元素的源序列相关联（同等联接），要求序列中的每个元素能够与其他序列进行某种比较。`join` 子句使用 `equals` 比较指定的键是否相等（值相等性）。

```csharp
join <inner-identifier> in <inner-sequence> on <outer-key> equals <inner-key> [into <identifier>]?
```

`join` 子句的输出形式取决于执行的联接的具体类型：内部联接、分组联接、左外部联接。

```csharp
var categories = new[]
{
    new { Name = "A", ID = 101 },
    new { Name = "B", ID = 102 },
    new { Name = "C", ID = 103 },
    new { Name = "D", ID = 104 },
};
var products = new[]
{
    new { Name = "Apple", CategoryID = 101 },
    new { Name = "Football", CategoryID = 102 },
    new { Name = "Train", CategoryID = 103 },
    new { Name = "Banana", CategoryID = 101 },
    new { Name = "Car", CategoryID = 103 },
    new { Name = "Basketball", CategoryID = 102 },
};
// 内联联接
Console.WriteLine("----- inner Join Query -----");
var innerJoinQuery =
    from category in categories
    join prod in products on category.ID equals prod.CategoryID
    select new { ProductName = prod.Name, Category = category.Name }; //produces flat sequence
foreach (var product in innerJoinQuery)
    Console.WriteLine("{0} : {1}", product.Category, product.ProductName);

// 分组联接
Console.WriteLine("----- inner Group Join Query -----");
var innerGroupJoinQuery =
    from category in categories
    join prod in products on category.ID equals prod.CategoryID into prodGroup
    select new { CategoryName = category.Name, Products = prodGroup };
foreach (var item in innerGroupJoinQuery)
{
    Console.WriteLine($"{item.CategoryName} : ");
    foreach (var productName in item.Products.Select(p => p.Name))
        Console.WriteLine("    " + productName);
}

// 左外部联接
Console.WriteLine("----- left Outer Join Query -----");
var leftOuterJoinQuery =
    from category in categories
    join prod in products on category.ID equals prod.CategoryID into prodGroup
    from item in prodGroup.DefaultIfEmpty(new { Name = "Empty", CategoryID = 0 })
    select new { CatName = category.Name, ProdName = item.Name };
foreach (var product in leftOuterJoinQuery)
    Console.WriteLine("{0} : {1}", product.CatName, product.ProdName);
```

> **into**

`into` 创建一个临时的标识符，并将 `group`、`join`、`select` 子句的结果存储到新的分组中，该标识符成为附加查询命令的生成器。

```csharp
{select|join|group} into <identifier>
```

`into` 附加 `group` 子句：

```csharp
Random r = new Random();
int[] arr = new int[100];
for (int i = 0; i < 100; i++)
    arr[i] = r.Next(-100, 100);

var query =
    from num in arr
    group num by num / 10 into numGroup
    where numGroup.Count() > 0
    orderby numGroup.Key
    select new { Range = numGroup.Key * 10, Numbers = numGroup.ToArray() };

foreach (var item in query)
    Console.WriteLine($"Numbers in " +
        $"[{(item.Range < 0 ? item.Range - 10 : item.Range)}," +
        $"{(item.Range < 0 ? item.Range : item.Range + 10)})] " +
        $"are {string.Join(",", item.Numbers)}");
```

>---
#### 24.2. 标准查询运算符

查询表达式可以转换为 LINQ 的标准查询运算符，这些方法中的大多数都作用于序列。`Linq.Enumerable` 适用于 `IEnumerable<T>` 对象，`Linq.Queryable` 适用于 `IQueryable<T>` 对象。标准查询运算符提供包括筛选、映射、聚合、排序等在内的查询功能。

```csharp
string[] words = "the quick brown fox jumps over the lazy dog".Split(' ');

// Using query expression syntax.  
var Query = from word in words
            group word.ToUpper() by word.Length into gr
            orderby gr.Key
            select new { Length = gr.Key, Words = gr };

// Using method-based query syntax.  
var Method = words.
    GroupBy(word => word.Length, w => w.ToUpper()).
    OrderBy(gr => gr.Key).
    Select(gr => new { Length = gr.Key, Words = gr });
```

> **查询表达式语法表**

- `Cast`：使用显式类型化范围变量，相当于 `from <type> <variable> in <source-sequence>`。
- `SelectMany`：对应多个 `from` 子句。
- `Select`：对应 `select <...>`。
- `Where` 方法：对应 `where <...>`。
- `OrderBy`：对应 `orderBy <... [ascending]>`。
- `OrderByDescending`：对应 `orderBy <... descending>`。
- `ThenBy`：对应 `orderBy ..., <... [ascending]>`。
- `ThenByDescending`：对应 `orderBy ..., <... descending>`。
- `Join`：对应 `join ... in ... on ... equals ...`。
- `GroupBy`：对应 `group ... by ... [into ...]`。
- `GroupJoin`：对应 `join ... in ... on ... equals ... into ...`。

---
### 25. 预处理指令

预处理指令提供了有条件地跳过部分编译单元、报告错误和警告条件以及描述源代码的不同区域的能力。预处理指令作为词法分析阶段的一部分进行处理。可用的预处理指令有：

- `#define`、`#undef`：分别用于定义和取消定义条件编译符号。
- `#if`、`#elif`、`else`、`endif`：使用条件编译符号以指示在源代码中的哪些部分可以有条件地跳过。
- `#error`：用于发出错误。
- `#warning`：用于发出警告。
- `#region`、`endregion`：用于显式标记或折叠源代码的某些部分。
- `#line`：用于控制错误和警告发出的行号。
- `#nullable`：用于控制可为空注释上下文和可为空警告上下文。
- `#pragma`：用于向编译器指定可选的上下文信息。

>---
#### 25.1. 条件编译


`#if`、`#elif`、`#else` 和 `#endif` 条件编译指令根据当前的条件编译符号有条件地包含或排除源文件的某些部分。条件编译符号存在 `defined` 和 `undefined` 两种状态。

使用 `#define` 指令来定义条件编译符号；`#undef` 指令来取消定义条件编译符号。它们仅对当前编译单元有效。

预处理表达式可以出现在 `#if` 和 `#elif` 指令中，表达式可以使用 `!`、`==`、`!=`、`&&`、`||` 操作符，括号用以分组。表达式求值总是产生一个布尔值，仅可以引用的是条件编译符号和布尔字面值。


```csharp
#define MYTEST
using System;
public class MyClass
{
    static void Main()
    {
#if DEBUG == true
        Console.WriteLine("DEBUG is defined");
#elif (!DEBUG && MYTEST)
        Console.WriteLine("MYTEST is defined");
#elif (DEBUG && MYTEST)
        Console.WriteLine("DEBUG and MYTEST are defined");
#else
        Console.WriteLine("DEBUG and MYTEST are not defined");
#endif
    }
}
```

> `<DefineConstants>`

可以通过 `DefineConstants` 编译器选项来定义项目级别的符号，作用于整个项目域，优先级低于在编译单元内通过 `#define` 定义的条件编译符。在当前编译单元范围中，可以通过 `#undef` 取消定义符号，取消定义的作用域仅限于当前声明的编译单元内。

可以使用 `ConditionalAttribute` 来执行条件编译。可以使用 `#define` 定义的符号，也可以是编译器选项设置的符号。`ConditionalAttribute` 仅对特性类或 `void` 方法有效。未定义符号的条件方法或条件特性在编译时，编译器在其所有调用点删除调用。


```xml
<DefineConstants>CONDITION1</DefineConstants>
```
```csharp
#define CONDITION2
using System.Diagnostics;

class Test
{
    static void Main()
    {
        Console.WriteLine("Calling Method1");
        Method1(3);
        Console.WriteLine("Calling Method2");
        Method2();

        Console.WriteLine("Using the Debug class");
        Trace.Listeners.Add(new ConsoleTraceListener());
        Debug.WriteLine("DEBUG is defined");
    }

    [Conditional("CONDITION1")] 
    public static void Method1(int x) => Console.WriteLine("CONDITION1 is defined");
    [Conditional("CONDITION1"), Conditional("CONDITION2")]
    public static void Method2() => Console.WriteLine("CONDITION1 or CONDITION2 is defined");
}
```

>---
#### 25.2. 诊断指令

诊断指令用于显式生成错误和警告消息，其报告方式与其他编译时错误和警告的方式相同。
- `#warning` 使用指定的消息生成编译器警告。
- `#error` 使用指定的消息生成编译器错误。

```csharp
#warning Code review needed before check-in
#if Debug && Retail
    #error A build can't be both debug and retail
#endif

class Test {...}
```

>---
#### 25.3. 区域指令

区域指令用于显式标记源代码区域。可以使用 `#region` 和 `#endregion` 预处理器指令来标记可折叠的源代码区域。

```csharp
#region MyClass definition 
interface IFace;
public class MyClass;
public delegate MyDelegate;
// ...
#endregion 
```

>---
#### 25.4. 行指令

行指令可用于更改编译器在输出（如警告和错误）中报告的行号和源文件名，这些信息也被调用者信息属性使用。借助 `#line`，可修改编译器的行号及（可选）用于错误和警告的文件名输出。

```csharp
class MainClass
{
    static void Main()
    {
#line 200 "Special"
        int i;
        int j;
#line default
        char c;
        float f;
#line hidden // numbering not affected
        string s;
        double d;
    }
}
/*
Special(200,13): warning CS0168: The variable 'i' is declared but never used
Special(201,13): warning CS0168: The variable 'j' is declared but never used
MainClass.cs(9,14): warning CS0168: The variable 'c' is declared but never used
MainClass.cs(10,15): warning CS0168: The variable 'f' is declared but never used
MainClass.cs(12,16): warning CS0168: The variable 's' is declared but never used
MainClass.cs(13,16): warning CS0168: The variable 'd' is declared but never used
*/
```

> 行指令语法

- `#line num filename` 指示下一行的行号强制设为 `num`，在下一个 `#line` 指令前，文件名都会报告为 `filename`。
- `#line filename` 指令可指定要在编译器输出中显示的文件名。默认情况下，将使用源代码文件的实际名称。文件名必须在行号之后。
- `#line default` 指令将行号恢复至默认行号，并对上一指令重新编号的行进行计数。
- `#line hidden` 指令能对调试程序隐藏连续行，当开发者逐行执行调试代码时，介于 `#line hidden` 和下一 `#line` 指令（假设它不是其他 `#line hidden` 指令）间的任何行都将被跳过。`#line hidden` 指令不影响错误报告中的文件名或行号。 

> C#10 `#line` 指令拓展

```csharp
#line (1, 1) - (5, 60) 10 "partial-class.cs"
/*34567*/int b = 0;
```

- `(1, 1)`：指令后面行上的第一个字符的起始行和列。
- `(5, 60)`：标记区域的结束行和列。
- `10`：将使 `#line` 指令生效的列偏移量。
- `"partial-class.cs"`：输出文件的名称。

>---
#### 25.5. 可空上下文设置指令

`#nullable` 预处理器指令将设置可为空注释上下文和可为空警告上下文。此指令控制是否可为空注释是否有效（引用类型的 `?` 注释），以及是否给出为 `Null` 性警告。

可在项目级别设置 `<Nullable>`，预处理器指令 `#nullable` 优先于项目级设置，用于设置其控制的上下文，直到另一个 `#nullable` 替代它，或到源文件的末尾。

```csharp
#nullable disable      // 将可为空注释和警告上下文设置为“已禁用”。
#nullable enable       // 将可为空注释和警告上下文设置为“已启用”。
#nullable restore      // 将可为空注释和警告上下文还原为项目设置。
#nullable disable annotations   // 将可为空注释上下文设置为“已禁用”。
#nullable enable annotations    // 将可为空注释上下文设置为“已启用”。
#nullable restore annotations   // 将可为空注释上下文还原为项目设置。
#nullable disable warnings      // 将可为空警告上下文设置为“已禁用”。
#nullable enable warnings       // 将可为空警告上下文设置为“已启用”。
#nullable restore warnings      // 将可为空警告上下文还原为项目设置。
```

>---
#### 25.6. 编译指示指令

`#pragma` 预处理指令用于指定编译器的可选上下文信息。`#pragma` 为编译器给出特殊指令以编译它所在的文件，这些指令必须受编译器支持。语法：`#pragma pragma-name pragma-arguments`。
  
> `#pragma warning`

- `#pragma warning` 可以启用或禁用特定警告。

```csharp
#pragma warning disable warning-list    // 禁用
#pragma warning restore warning-list    // 启用
```

- `warning-list` 是以逗号分隔的警告编号的列表。

```csharp
using System;

#pragma warning disable 414, CS3021  // CS 前缀可选，禁用
[CLSCompliant(false)]
public class C
{
    int i = 1;
    static void Main(){}
}
#pragma warning restore CS3021  // 启用
[CLSCompliant(false)]  // CS3021
public class D
{
    int i = 1;
    public static void F(){}
}
```

> `#pragma checksum`

- `#pragma checksum`：生成校验和。

```csharp
#pragma checksum "filename" "{guid}" "checksum bytes"
```

- `filename` 是需要监视更改或更新的文件的名称，`guid` 是哈希算法的全局唯一标识符 GUID，`checksum bytes` 是表示校验和字节的十六进制数字的字符串（偶数个）。
- Visual Studio 调试器使用校验和确保它可始终找到正确的源。编译器为源文件计算校验和，然后将输出发出到程序数据库 PDB 文件。调试器随后使用 PDB 针对它为源文件计算的校验和进行比较。
- 如果编译器在文件中没有找到 `#pragma checksum` 指令，它将计算校验和，并将该值写入 PDB 文件。

---
### 附录

#### 变量转义范围解析

预定义 `rs` 为 `ref struct` 类型的变量。`v` 为非 `ref struct` 的变量。`unscoped` 为 `[UnscopedRef]`。`EInit` 为初始化设定项。*SC* 表示 *safe-context*，*RC* 表示 *ref-safe-context*

> 参数

| Parameter            | safe-context       | ref-safe-context  |
| :------------------- | :----------------- | :---------------- |
| `rs`                 | *caller-context*   | *function-member* |
| `scoped rs`          | *function-context* | *function-member* |
| `ref/in rs`          | *caller-context*   | *return-only*     |
| `scoped ref/in rs`   | *caller-context*   | *function-member* |
| `unscoped ref/in rs` | *caller-context*   | *caller-context*  |
| `out rs`             | *return-only*      | *function-member* |
| `unscoped out rs`    | *return-only*      | *return-only*     |
| `v`                  | *caller-context*   | *function-member* |
| `ref/in v`           | *caller-context*   | *return-only*     |
| `scoped ref/in v`    | *caller-context*   | *function-member* |
| `unscoped ref/in v`  | *caller-context*   | *caller-context*  |
| `out v`              | *caller-context*   | *function-member* |
| `unscoped out v`     | *caller-context*   | *return-only*     |

> 局部变量

| Local                | safe-context      | ref-safe-context  |
| -------------------- | ----------------- | ----------------- |
| `rs = EInit`         | *SC of EInit*     | *function-member* |
| `ref rs = ref EInit` | *SC of EInit*     | *RC of EInit*     |
| `scoped rs`          | *function-member* | *function-member* |
| `scoped ref rs`      | *function-member* | *function-member* |
| `v`                  | *caller-context*  | *function-member* |
| `ref v = ref EInit`  | *caller-context*  | *RC of EInit*     |
| `scoped ref v`       | *caller-context*  | *function-member* |

> 字段

| Field                 | safe-context     | ref-safe-context |
| --------------------- | ---------------- | ---------------- |
| `struct.Field`        | *caller-context* | *RC of struct*   |
| `class.Field`         | *caller-context* | *caller-context* |
| `rs.ref-struct_Field` | *SC of rs*       | *RC of struct*   |
| `rs.Ref_Field`        | *caller-context* | *RC of rs*       |

>---
#### 1.2. 托管执行和 CIL

源代码编译为 CIL 程序集，程序集由 VES（*Virtual Execution System*，虚拟执行系统）加载，运行时按需即时编译（*just-in-time compilation*，JIT 编译）程序集为本机代码。托管代码 （*managed code*）在运行时的上下文中托管执行 （*managed execution*）。

运行时规范包含在一个包容面更广的规范 CLI（*Common Language Infrastructure*，公共语言基础结构 ）中：
- CIL（*Common intermediate Language*）公共中间语言，MSIL 或 IL；
- BCL（*Base Class Library*）基类库，属于 FCL 的一个子集；
- FCL（*Framework Class Library*）框架类库，底层由大部分 BCL 组成，主要对 NET 框架、运行时和 CIL 语言提供支持（预定义类型、集合类型、线程处理、应用程序域、运行时、安全性、互操作等）；中间层是包含了对操作系统功能的封装（文件系统、网络连接、图形图像、XML 操作等）；最外层是包含各种类型的应用程序（Windows Forms、ASP、WPF、WCF、WF 等）；
- CTS（*Common Type System*）公共类型系统；
- CLS（*Common Language Specification*）公共语言规范；
- CLR（*Common Language Runtime*）公共语言运行时，或 VES（*Virtual Execution System*，虚拟执行系统），CLR 是 NET 程序集的运行环境；
- Metadata 元数据包括程序集的布局或文件格式规范。
  
CIL 在 CLR 执行引擎的上下文中运行，其中运行的主要服务和功能包括语言互操作性、类型安全、代码访问安全性、垃圾回收、平台可移植性、BCL（基类库）等。

